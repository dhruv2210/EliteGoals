"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindStateEvents = exports.bindSourceMapCollapseEvents = exports.bindDefaultEvents = exports.bindRadialExplore = void 0;
var util_1 = require("@antv/util");
var constants_1 = require("../constants");
var layout_1 = require("../layout");
var create_fetch_loading_1 = require("./create-fetch-loading");
var close_fetch_loading_1 = require("./close-fetch-loading");
var get_children_data_1 = require("./get-children-data");
var set_level_data_1 = require("./set-level-data");
var is_type_1 = require("./is-type");
var event_data_1 = __importDefault(require("./event-data"));
/** sector layout */
var bindRadialExplore = function (graph, asyncData, layoutCfg, fetchLoading) {
    var onDblClick = function (e) { return __awaiter(void 0, void 0, void 0, function () {
        var item, itemModel, newData, nodes, edges, x, y, centerNodeId, centerNode, _a, centerX, centerY, pureNodes, pureEdges, allNodeModels, allEdgeModels;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    item = e.item;
                    itemModel = item.getModel();
                    (0, create_fetch_loading_1.createFetchLoading)(itemModel, fetchLoading);
                    return [4 /*yield*/, asyncData(item.getModel())];
                case 1:
                    newData = _b.sent();
                    (0, close_fetch_loading_1.closeFetchLoading)();
                    nodes = graph.getNodes();
                    edges = graph.getEdges();
                    x = itemModel.x, y = itemModel.y;
                    centerNodeId = graph.get('centerNode');
                    centerNode = centerNodeId ? graph.findById(centerNodeId) : nodes[0];
                    _a = centerNode.getModel(), centerX = _a.x, centerY = _a.y;
                    pureNodes = newData.nodes.filter(function (item) { return (0, util_1.findIndex)(nodes, function (t) { return t.getModel().id === item.id; }) === -1; });
                    pureEdges = newData.edges.filter(function (item) {
                        return (0, util_1.findIndex)(edges, function (t) {
                            var _a = t.getModel(), source = _a.source, target = _a.target;
                            return source === item.source && target === item.target;
                        }) === -1;
                    });
                    allNodeModels = [];
                    allEdgeModels = [];
                    pureNodes.forEach(function (nodeModel) {
                        // set the initial positions of the new nodes to the focus(clicked) node
                        nodeModel.x = itemModel.x;
                        nodeModel.y = itemModel.y;
                        graph.addItem('node', nodeModel);
                    });
                    // add new edges to graph
                    pureEdges.forEach(function (em, i) {
                        graph.addItem('edge', em);
                    });
                    edges.forEach(function (e) {
                        allEdgeModels.push(e.getModel());
                    });
                    nodes.forEach(function (n) {
                        allNodeModels.push(n.getModel());
                    });
                    // 这里使用了引用类型
                    (0, layout_1.radialSectorLayout)({
                        center: [centerX, centerY],
                        eventNodePosition: [x, y],
                        nodes: nodes.map(function (n) { return n.getModel(); }),
                        layoutNodes: pureNodes,
                        options: layoutCfg,
                    });
                    graph.positionsAnimate();
                    graph.data({
                        nodes: allNodeModels,
                        edges: allEdgeModels,
                    });
                    return [2 /*return*/];
            }
        });
    }); };
    graph.on('node:dblclick', function (e) {
        onDblClick(e);
    });
};
exports.bindRadialExplore = bindRadialExplore;
// 展开&折叠事件
var bindDefaultEvents = function (graph, level, getChildren, fetchLoading) {
    var onClick = function (e) { return __awaiter(void 0, void 0, void 0, function () {
        var item, model, _a, collapsed, g_currentPath_1, _b, children, g_parentId_1, g_level_1, id_1, appendChildren, appendChildrenData;
        var _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    item = e.item;
                    model = item.getModel();
                    if (!((_c = e.target.get('name')) === null || _c === void 0 ? void 0 : _c.startsWith('collapse-icon'))) return [3 /*break*/, 3];
                    _a = item.getModel(), collapsed = _a.collapsed, g_currentPath_1 = _a.g_currentPath, _b = _a.children, children = _b === void 0 ? [] : _b, g_parentId_1 = _a.g_parentId, g_level_1 = _a.g_level, id_1 = _a.id;
                    appendChildren = level &&
                        !children.length &&
                        (0, get_children_data_1.getChildrenData)(graph.get('eventData').getData(), g_currentPath_1);
                    if (!(getChildren && !(children === null || children === void 0 ? void 0 : children.length) && !(appendChildren === null || appendChildren === void 0 ? void 0 : appendChildren.length))) return [3 /*break*/, 2];
                    (0, create_fetch_loading_1.createFetchLoading)(model, fetchLoading);
                    return [4 /*yield*/, getChildren(item.getModel())];
                case 1:
                    appendChildrenData = _d.sent();
                    if (appendChildrenData) {
                        appendChildrenData = appendChildrenData.map(function (t, index) {
                            var _a;
                            return __assign((_a = {}, _a["".concat(constants_1.prefix, "_level")] = g_level_1 + 1, _a["".concat(constants_1.prefix, "_parentId")] = "".concat(g_parentId_1, "-").concat(id_1), _a["".concat(constants_1.prefix, "_currentPath")] = "".concat(g_currentPath_1, "-").concat(index), _a), t);
                        });
                        (0, set_level_data_1.setLevelData)(graph, appendChildrenData, g_currentPath_1);
                    }
                    appendChildren = appendChildrenData;
                    (0, close_fetch_loading_1.closeFetchLoading)();
                    _d.label = 2;
                case 2:
                    if ((appendChildren === null || appendChildren === void 0 ? void 0 : appendChildren.length) > 0) {
                        model.children = appendChildren;
                        graph.updateChild(model, model.id);
                        graph.updateItem(item, {
                            collapsed: false,
                        });
                        graph.refreshItem(item);
                    }
                    else {
                        graph.updateItem(item, {
                            collapsed: !collapsed,
                        });
                        graph.layout();
                    }
                    _d.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    }); };
    graph.on('node:click', function (e) {
        onClick(e);
    });
    graph.on('node:touchstart', function (e) {
        onClick(e);
    });
};
exports.bindDefaultEvents = bindDefaultEvents;
var bindSourceMapCollapseEvents = function (graph, asyncData, fetchLoading) {
    var onClick = function (e) { return __awaiter(void 0, void 0, void 0, function () {
        var controlData, item, collapsed, _a, fullEdges_1, nodeId_1, targetNodeIds_1, updateItems_1, updateIds_1, getLinkedId_1, showNode, _b, nodes, edges, eventData;
        var _c, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    controlData = graph.get('eventData').getData();
                    if (!((_c = e.target.get('name')) === null || _c === void 0 ? void 0 : _c.startsWith('collapse-icon'))) return [3 /*break*/, 5];
                    item = e.item;
                    collapsed = item.getModel().collapsed;
                    if (!(0, is_type_1.isType)(collapsed, 'Boolean')) {
                        // @ts-ignore
                        collapsed = (_d = item._cfg.group
                            .getChildren()
                            .find(function (item) { return item.get('name') === 'main-box'; })) === null || _d === void 0 ? void 0 : _d.attr('defaultCollapsed');
                    }
                    _a = (controlData !== null && controlData !== void 0 ? controlData : {}).edges, fullEdges_1 = _a === void 0 ? [] : _a;
                    nodeId_1 = item.getModel().id;
                    targetNodeIds_1 = [];
                    updateItems_1 = [];
                    updateIds_1 = [];
                    getLinkedId_1 = function (currentId) {
                        fullEdges_1.forEach(function (edge) {
                            var source = edge.source, target = edge.target;
                            if (source === currentId) {
                                targetNodeIds_1.push(target);
                                getLinkedId_1(target);
                            }
                        });
                    };
                    getLinkedId_1(nodeId_1);
                    if (!!collapsed) return [3 /*break*/, 1];
                    // collapse
                    graph.findAll('node', function (node) { return targetNodeIds_1.includes(node.get('id')); }).forEach(function (node) { return graph.hideItem(node); });
                    controlData.nodes.forEach(function (node) {
                        var _a = node.collapsedLevel, collapsedLevel = _a === void 0 ? 0 : _a, id = node.id;
                        if (targetNodeIds_1.includes(id)) {
                            node.collapsedLevel = collapsedLevel + 1;
                        }
                    });
                    return [3 /*break*/, 4];
                case 1:
                    showNode = graph.findAll('node', function (node) {
                        var collapsedLevel = controlData.nodes.find(function (item) { return item.id === node.get('id'); }).collapsedLevel;
                        return targetNodeIds_1.includes(node.get('id')) && (!collapsedLevel || collapsedLevel < 2);
                    });
                    if (!showNode.length) return [3 /*break*/, 2];
                    showNode.forEach(function (node) { return graph.showItem(node); });
                    controlData.nodes.forEach(function (node) {
                        var _a = node.collapsedLevel, collapsedLevel = _a === void 0 ? 0 : _a, id = node.id;
                        if (targetNodeIds_1.includes(id)) {
                            node.collapsedLevel = collapsedLevel - 1;
                        }
                    });
                    return [3 /*break*/, 4];
                case 2:
                    if (!asyncData) return [3 /*break*/, 4];
                    (0, create_fetch_loading_1.createFetchLoading)(item.getModel(), fetchLoading);
                    return [4 /*yield*/, asyncData(item.getModel())];
                case 3:
                    _b = _e.sent(), nodes = _b.nodes, edges = _b.edges;
                    eventData = {
                        nodes: controlData.nodes.concat(nodes),
                        edges: controlData.edges.concat((edges === null || edges === void 0 ? void 0 : edges.length) ? edges : nodes.map(function (item) { return ({ source: nodeId_1, target: item.id }); })),
                    };
                    (0, close_fetch_loading_1.closeFetchLoading)();
                    graph.set('eventData', new event_data_1.default(eventData));
                    graph.changeData(eventData);
                    if (graph.get('fitCenter')) {
                        graph.fitCenter();
                    }
                    return [2 /*return*/];
                case 4:
                    fullEdges_1.forEach(function (edge) {
                        var source = edge.source, target = edge.target;
                        if (targetNodeIds_1.includes(target)) {
                            updateIds_1.push(source);
                        }
                    });
                    updateIds_1 = Array.from(new Set(updateIds_1));
                    updateIds_1.forEach(function (id) {
                        updateItems_1.push(graph.find('node', function (node) { return node.get('id') === id; }));
                    });
                    updateItems_1.forEach(function (nodeItem) {
                        graph.updateItem(nodeItem, {
                            collapsed: !nodeItem.getModel().collapsed,
                        });
                        graph.refreshItem(nodeItem);
                    });
                    _e.label = 5;
                case 5: return [2 /*return*/];
            }
        });
    }); };
    graph.on('node:click', function (e) {
        onClick(e);
    });
    graph.on('node:touchstart', function (e) {
        onClick(e);
    });
};
exports.bindSourceMapCollapseEvents = bindSourceMapCollapseEvents;
// 交互
var bindStateEvents = function (graph, cfg) {
    var _a = cfg !== null && cfg !== void 0 ? cfg : {}, _b = _a.nodeCfg, nodeCfg = _b === void 0 ? {} : _b, _c = _a.edgeCfg, edgeCfg = _c === void 0 ? {} : _c;
    var nodeStateStyles = nodeCfg.nodeStateStyles;
    var edgeStateStyles = edgeCfg.edgeStateStyles;
    /**
     * 存储交互状态
     * id: [[endActive, endDefalut], [startActive, startDefalut]]
     */
    var statusCache = {};
    var updateArrowFill = function (item, endArrowFill, stratArrowFill) {
        graph.updateItem(item, {
            style: {
                endArrow: !!endArrowFill && {
                    fill: endArrowFill,
                },
                startArrow: !!stratArrowFill && {
                    fill: stratArrowFill,
                },
            },
        });
    };
    var setState = function (item, name, status) {
        var _a, _b, _c;
        status ? item.toFront() : item.toBack();
        var _d = (_a = item.getModel().style) !== null && _a !== void 0 ? _a : {}, endArrow = _d.endArrow, startArrow = _d.startArrow;
        if (endArrow || startArrow) {
            if (!statusCache[item.getID()]) {
                // @ts-ignore
                var endArrowFill = (endArrow !== null && endArrow !== void 0 ? endArrow : {}).fill;
                // @ts-ignore
                var startArrowFill = (startArrow !== null && startArrow !== void 0 ? startArrow : {}).fill;
                var hoverStatus = (_c = (_b = item.getModel().style) === null || _b === void 0 ? void 0 : _b[name]) === null || _c === void 0 ? void 0 : _c.stroke;
                statusCache[item.getID()] = [
                    [hoverStatus !== null && hoverStatus !== void 0 ? hoverStatus : endArrowFill, endArrowFill],
                    [hoverStatus !== null && hoverStatus !== void 0 ? hoverStatus : startArrowFill, startArrowFill],
                ];
            }
            var fill = statusCache[item.getID()];
            updateArrowFill(item, endArrow && fill[0][status ? 0 : 1], startArrow && fill[1][status ? 0 : 1]);
        }
        graph.setItemState(item, name, status);
    };
    var getRelationItems = function (currentItem, name, status, type) {
        var relationItems = type === 'node'
            ? graph.findAll('edge', function (edge) { return edge.getSource() === currentItem || edge.getTarget() === currentItem; })
            : graph.findAll('node', function (node) {
                return currentItem.getSource().get('id') === node.get('id') ||
                    currentItem.getTarget().get('id') === node.get('id');
            });
        var highlightItems = [currentItem].concat(relationItems);
        highlightItems.forEach(function (item) {
            setState(item, name, status);
        });
    };
    if (nodeStateStyles) {
        graph.on('node:mouseenter', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', true, 'node');
        });
        graph.on('node:mouseleave', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', false, 'node');
        });
    }
    if (edgeStateStyles) {
        graph.on('edge:mouseenter', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', true, 'edge');
        });
        graph.on('edge:mouseleave', function (evt) {
            var item = evt.item;
            getRelationItems(item, 'hover', false, 'edge');
        });
    }
};
exports.bindStateEvents = bindStateEvents;
