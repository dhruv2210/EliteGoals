{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { FIELD_ORIGIN } from '../constant';\nimport Geometry from './base';\nimport Element from './element';\n/** 引入对应的 ShapeFactory */\nimport './shape/line';\nimport { isModelChange } from './util/is-model-change';\nimport { diff } from './util/diff';\n/**\n * Path 几何标记。\n * 用于绘制路径图等。\n */\nvar Path = /** @class */function (_super) {\n  __extends(Path, _super);\n  function Path(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.type = 'path';\n    _this.shapeType = 'line';\n    var _a = cfg.connectNulls,\n      connectNulls = _a === void 0 ? false : _a,\n      _b = cfg.showSinglePoint,\n      showSinglePoint = _b === void 0 ? true : _b;\n    _this.connectNulls = connectNulls;\n    _this.showSinglePoint = showSinglePoint;\n    return _this;\n  }\n  /**\n   * 创建所有的 Element 实例，对于 Path、Line、Area，一组数据对应一个 Element。\n   * @param mappingData\n   * @param [isUpdate]\n   * @returns elements\n   */\n  Path.prototype.updateElements = function (mappingDataArray, isUpdate) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    // Path 的每个 element 对应一组数据\n    var keyData = new Map();\n    var keyIndex = new Map();\n    var keys = [];\n    var index = 0;\n    for (var i = 0; i < mappingDataArray.length; i++) {\n      var mappingData = mappingDataArray[i];\n      var key = this.getElementId(mappingData);\n      keys.push(key);\n      keyData.set(key, mappingData);\n      keyIndex.set(key, index);\n      index++;\n    }\n    this.elements = new Array(index);\n    var _d = diff(this.lastElementsMap, keys),\n      added = _d.added,\n      updated = _d.updated,\n      removed = _d.removed;\n    try {\n      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {\n        var key = added_1_1.value;\n        var mappingData = keyData.get(key);\n        var shapeFactory = this.getShapeFactory();\n        var shapeCfg = this.getShapeInfo(mappingData);\n        var i = keyIndex.get(key);\n        var element = new Element({\n          shapeFactory: shapeFactory,\n          container: this.container,\n          offscreenGroup: this.getOffscreenGroup(),\n          elementIndex: i\n        });\n        element.geometry = this;\n        element.animate = this.animateOption;\n        element.draw(shapeCfg, isUpdate); // 绘制 shape\n        this.elementsMap[key] = element;\n        this.elements[i] = element;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (added_1_1 && !added_1_1.done && (_a = added_1.return)) _a.call(added_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    try {\n      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {\n        var key = updated_1_1.value;\n        var mappingData = keyData.get(key);\n        var element = this.lastElementsMap[key];\n        var i = keyIndex.get(key);\n        var shapeCfg = this.getShapeInfo(mappingData);\n        var preShapeCfg = element.getModel();\n        if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {\n          element.animate = this.animateOption;\n          // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n          element.update(shapeCfg); // 更新对应的 element\n        }\n\n        this.elementsMap[key] = element;\n        this.elements[i] = element;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    try {\n      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {\n        var key = removed_1_1.value;\n        var element = this.lastElementsMap[key];\n        // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n        element.animate = this.animateOption;\n        element.destroy();\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  /**\n   * 获取组成一条线（一组数据）的所有点以及数据\n   * @param mappingData 映射后的数组\n   */\n  Path.prototype.getPointsAndData = function (mappingData) {\n    var points = [];\n    var data = [];\n    for (var i = 0, len = mappingData.length; i < len; i++) {\n      var obj = mappingData[i];\n      points.push({\n        x: obj.x,\n        y: obj.y\n      });\n      data.push(obj[FIELD_ORIGIN]);\n    }\n    return {\n      points: points,\n      data: data\n    };\n  };\n  Path.prototype.getShapeInfo = function (mappingData) {\n    var shapeCfg = this.getDrawCfg(mappingData[0]);\n    var _a = this.getPointsAndData(mappingData),\n      points = _a.points,\n      data = _a.data;\n    shapeCfg.mappingData = mappingData;\n    shapeCfg.data = data;\n    shapeCfg.isStack = !!this.getAdjust('stack');\n    shapeCfg.points = points;\n    shapeCfg.connectNulls = this.connectNulls;\n    shapeCfg.showSinglePoint = this.showSinglePoint;\n    return shapeCfg;\n  };\n  return Path;\n}(Geometry);\nexport default Path;","map":null,"metadata":{},"sourceType":"module"}