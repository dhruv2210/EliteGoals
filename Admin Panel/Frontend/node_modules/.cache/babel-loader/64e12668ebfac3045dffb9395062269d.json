{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator, __read, __spreadArray, __values } from \"tslib\";\nimport { getAdjust as getAdjustClass } from '@antv/adjust';\nimport { getAttribute as getAttributeClass } from '@antv/attr';\nimport { clone, deepMix, each, flatten, get, isArray, isEmpty, isEqual, isFunction, isNil, isNumber, isObject, isPlainObject, isString, set } from '@antv/util';\nimport { doGroupAppearAnimate, getDefaultAnimateCfg } from '../animate';\nimport Base from '../base';\nimport { FIELD_ORIGIN, GEOMETRY_LIFE_CIRCLE, GROUP_ATTRS } from '../constant';\nimport { uniq } from '../util/helper';\nimport Element from './element';\nimport { getGeometryLabel } from './label';\nimport { getShapeFactory } from './shape/base';\nimport { group } from './util/group-data';\nimport { isModelChange } from './util/is-model-change';\nimport { parseFields } from './util/parse-fields';\nimport { diff } from './util/diff';\nimport { inferScaleType } from '../util/scale';\nimport { getXDimensionLength } from '../util/coordinate';\n/**\n * Geometry 几何标记基类，主要负责数据到图形属性的映射以及绘制逻辑。\n */\nvar Geometry = /** @class */function (_super) {\n  __extends(Geometry, _super);\n  /**\n   * 创建 Geometry 实例。\n   * @param cfg\n   */\n  function Geometry(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /** Geometry 几何标记类型。 */\n    _this.type = 'base';\n    // 内部产生的属性\n    /** Attribute map  */\n    _this.attributes = {};\n    /** Element map */\n    _this.elements = [];\n    /** 使用 key-value 结构存储 Element，key 为每个 Element 实例对应的唯一 ID */\n    _this.elementsMap = {};\n    /** animate 配置项 */\n    _this.animateOption = true;\n    /** 图形属性映射配置 */\n    _this.attributeOption = {};\n    /** 存储上一次渲染时的 element 映射表，用于更新逻辑 */\n    _this.lastElementsMap = {};\n    /** 是否生成多个点来绘制图形。 */\n    _this.generatePoints = false;\n    /** 存储发生图形属性映射前的数据 */\n    _this.beforeMappingData = null;\n    _this.adjusts = {};\n    _this.idFields = [];\n    _this.hasSorted = false;\n    _this.isCoordinateChanged = false;\n    var container = cfg.container,\n      labelsContainer = cfg.labelsContainer,\n      coordinate = cfg.coordinate,\n      data = cfg.data,\n      _a = cfg.sortable,\n      sortable = _a === void 0 ? false : _a,\n      _b = cfg.visible,\n      visible = _b === void 0 ? true : _b,\n      theme = cfg.theme,\n      _c = cfg.scales,\n      scales = _c === void 0 ? {} : _c,\n      _d = cfg.scaleDefs,\n      scaleDefs = _d === void 0 ? {} : _d,\n      // 柱状图间隔与宽度相关配置\n      intervalPadding = cfg.intervalPadding,\n      dodgePadding = cfg.dodgePadding,\n      maxColumnWidth = cfg.maxColumnWidth,\n      minColumnWidth = cfg.minColumnWidth,\n      columnWidthRatio = cfg.columnWidthRatio,\n      roseWidthRatio = cfg.roseWidthRatio,\n      multiplePieWidthRatio = cfg.multiplePieWidthRatio,\n      zIndexReversed = cfg.zIndexReversed,\n      sortZIndex = cfg.sortZIndex,\n      useDeferredLabel = cfg.useDeferredLabel;\n    _this.container = container;\n    _this.labelsContainer = labelsContainer;\n    _this.coordinate = coordinate;\n    _this.data = data;\n    _this.sortable = sortable;\n    _this.visible = visible;\n    _this.userTheme = theme;\n    _this.scales = scales;\n    _this.scaleDefs = scaleDefs;\n    // 柱状图间隔与宽度相关配置\n    _this.intervalPadding = intervalPadding;\n    _this.dodgePadding = dodgePadding;\n    _this.maxColumnWidth = maxColumnWidth;\n    _this.minColumnWidth = minColumnWidth;\n    _this.columnWidthRatio = columnWidthRatio;\n    _this.roseWidthRatio = roseWidthRatio;\n    _this.multiplePieWidthRatio = multiplePieWidthRatio;\n    _this.zIndexReversed = zIndexReversed;\n    _this.sortZIndex = sortZIndex;\n    _this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === 'number' ? useDeferredLabel : Infinity : null;\n    return _this;\n  }\n  /**\n   * 配置 position 通道映射规则。\n   *\n   * @example\n   * ```typescript\n   * // 数据结构: [{ x: 'A', y: 10, color: 'red' }]\n   * geometry.position('x*y');\n   * geometry.position([ 'x', 'y' ]);\n   * geometry.position({\n   *   fields: [ 'x', 'y' ],\n   * });\n   * ```\n   *\n   * @param cfg 映射规则\n   * @returns\n   */\n  Geometry.prototype.position = function (cfg) {\n    var positionCfg = cfg;\n    if (!isPlainObject(cfg)) {\n      // 字符串字段或者数组字段\n      positionCfg = {\n        fields: parseFields(cfg)\n      };\n    }\n    var fields = get(positionCfg, 'fields');\n    if (fields.length === 1) {\n      // 默认填充一维 1*xx\n      fields.unshift('1');\n      set(positionCfg, 'fields', fields);\n    }\n    set(this.attributeOption, 'position', positionCfg);\n    return this;\n  };\n  Geometry.prototype.color = function (field, cfg) {\n    this.createAttrOption('color', field, cfg);\n    return this;\n  };\n  Geometry.prototype.shape = function (field, cfg) {\n    this.createAttrOption('shape', field, cfg);\n    return this;\n  };\n  Geometry.prototype.size = function (field, cfg) {\n    this.createAttrOption('size', field, cfg);\n    return this;\n  };\n  /**\n   * 设置数据调整方式。G2 目前内置了四种类型：\n   * 1. dodge\n   * 2. stack\n   * 3. symmetric\n   * 4. jitter\n   *\n   *\n   * **Tip**\n   * + 对于 'dodge' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('dodge', {\n   *   marginRatio: 0, // 取 0 到 1 范围的值（相对于每个柱子宽度），用于控制一个分组中柱子之间的间距\n   *   dodgeBy: 'x', // 该属性只对 'dodge' 类型生效，声明以哪个数据字段为分组依据\n   * });\n   * ```\n   *\n   * + 对于 'stack' 类型，可以额外进行如下属性的配置:\n   * ```typescript\n   * geometry.adjust('stack', {\n   *   reverseOrder: false, // 用于控制是否对数据进行反序操作\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * geometry.adjust('stack');\n   *\n   * geometry.adjust({\n   *   type: 'stack',\n   *   reverseOrder: false,\n   * });\n   *\n   * // 组合使用 adjust\n   * geometry.adjust([ 'stack', 'dodge' ]);\n   *\n   * geometry.adjust([\n   *   { type: 'stack' },\n   *   { type: 'dodge', dodgeBy: 'x' },\n   * ]);\n   * ```\n   *\n   * @param adjustCfg 数据调整配置\n   * @returns\n   */\n  Geometry.prototype.adjust = function (adjustCfg) {\n    var adjusts = adjustCfg;\n    if (isString(adjustCfg) || isPlainObject(adjustCfg)) {\n      adjusts = [adjustCfg];\n    }\n    each(adjusts, function (adjust, index) {\n      if (!isObject(adjust)) {\n        adjusts[index] = {\n          type: adjust\n        };\n      }\n    });\n    this.adjustOption = adjusts;\n    return this;\n  };\n  Geometry.prototype.style = function (field, styleFunc) {\n    if (isString(field)) {\n      var fields = parseFields(field);\n      this.styleOption = {\n        fields: fields,\n        callback: styleFunc\n      };\n    } else {\n      var _a = field,\n        fields = _a.fields,\n        callback = _a.callback,\n        cfg = _a.cfg;\n      if (fields || callback || cfg) {\n        this.styleOption = field;\n      } else {\n        this.styleOption = {\n          cfg: field\n        };\n      }\n    }\n    return this;\n  };\n  Geometry.prototype.tooltip = function (field, cfg) {\n    if (isString(field)) {\n      var fields = parseFields(field);\n      this.tooltipOption = {\n        fields: fields,\n        callback: cfg\n      };\n    } else {\n      this.tooltipOption = field;\n    }\n    return this;\n  };\n  /**\n   * Geometry 动画配置。\n   *\n   * + `animate(false)` 关闭动画\n   * + `animate(true)` 开启动画，默认开启。\n   *\n   * 我们将动画分为四个场景：\n   * 1. appear: 图表第一次加载时的入场动画；\n   * 2. enter: 图表绘制完成，发生更新后，产生的新图形的进场动画；\n   * 3. update: 图表绘制完成，数据发生变更后，有状态变更的图形的更新动画；\n   * 4. leave: 图表绘制完成，数据发生变更后，被销毁图形的销毁动画。\n   *\n   * @example\n   * ```typescript\n   * animate({\n   *   enter: {\n   *     duration: 1000, // enter 动画执行时间\n   *   },\n   *   leave: false, // 关闭 leave 销毁动画\n   * });\n   * ```\n   *\n   * @param cfg 动画配置\n   * @returns\n   */\n  Geometry.prototype.animate = function (cfg) {\n    this.animateOption = cfg;\n    return this;\n  };\n  Geometry.prototype.label = function (field, secondParam, thirdParam) {\n    if (isString(field)) {\n      var labelOption = {};\n      var fields = parseFields(field);\n      labelOption.fields = fields;\n      if (isFunction(secondParam)) {\n        labelOption.callback = secondParam;\n      } else if (isPlainObject(secondParam)) {\n        labelOption.cfg = secondParam;\n      }\n      if (thirdParam) {\n        labelOption.cfg = thirdParam;\n      }\n      this.labelOption = labelOption;\n    } else {\n      this.labelOption = field;\n    }\n    return this;\n  };\n  /**\n   * 设置状态对应的样式。\n   *\n   * @example\n   * ```ts\n   * chart.interval().state({\n   *   selected: {\n   *     animate: { duration: 100, easing: 'easeLinear' },\n   *     style: {\n   *       lineWidth: 2,\n   *       stroke: '#000',\n   *     },\n   *   },\n   * });\n   * ```\n   *\n   * 如果图形 shape 是由多个 shape 组成，即为一个 G.Group 对象，那么针对 group 中的每个 shape，我们需要使用下列方式进行状态样式设置：\n   * 如果我们为 group 中的每个 shape 设置了 'name' 属性(shape.set('name', 'xx'))，则以 'name' 作为 key，否则默认以索引值（即 shape 的 添加顺序）为 key。\n   *\n   * ```ts\n   * chart.interval().shape('groupShape').state({\n   *   selected: {\n   *     style: {\n   *       0: { lineWidth: 2 },\n   *       1: { fillOpacity: 1 },\n   *     }\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg 状态样式\n   */\n  Geometry.prototype.state = function (cfg) {\n    this.stateOption = cfg;\n    return this;\n  };\n  /**\n   * 用于向 shape 中传入自定义的数据。目前可能仅仅可能用于在自定义 shape 的时候，像自定义 shape 中传入自定义的数据，方便实现自定义 shape 的配置能力。\n   *\n   * @example\n   * ```ts\n   * chart.interval().customInfo({ yourData: 'hello, g2!' });\n   * ```\n   *\n   * 然后在自定义 shape 的时候，可以拿到这个信息。\n   *\n   * ```ts\n   * registerShape('interval', 'your-shape', {\n   *   draw(shapeInfo, container) {\n   *     const { customInfo } = shapeInfo;\n   *     console.log(customInfo); // will log { yourData: 'hello, g2!' }.\n   *   }\n   * });\n   * ```\n   *\n   * @param cfg\n   */\n  Geometry.prototype.customInfo = function (cfg) {\n    this.customOption = cfg;\n    return this;\n  };\n  /**\n   * 初始化 Geomtry 实例：\n   * 创建 [[Attribute]] and [[Scale]] 实例，进行数据处理，包括分组、数值化以及数据调整。\n   */\n  Geometry.prototype.init = function (cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.setCfg(cfg);\n    this.initAttributes(); // 创建图形属性\n    // 数据加工：分组 -> 数字化 -> adjust\n    this.processData(this.data);\n    // 调整 scale\n    this.adjustScale();\n  };\n  /**\n   * Geometry 更新。\n   * @param [cfg] 更新的配置\n   */\n  Geometry.prototype.update = function (cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    var data = cfg.data,\n      isDataChanged = cfg.isDataChanged,\n      isCoordinateChanged = cfg.isCoordinateChanged;\n    var _a = this,\n      attributeOption = _a.attributeOption,\n      lastAttributeOption = _a.lastAttributeOption;\n    if (!isEqual(attributeOption, lastAttributeOption)) {\n      // 映射发生改变，则重新创建图形属性\n      this.init(cfg);\n    } else if (data && (isDataChanged || !isEqual(data, this.data))) {\n      // 数据发生变化\n      this.setCfg(cfg);\n      this.initAttributes(); // 创建图形属性\n      this.processData(data); // 数据加工：分组 -> 数字化 -> adjust\n    } else {\n      // 有可能 coordinate 变化\n      this.setCfg(cfg);\n    }\n    // 调整 scale\n    this.adjustScale();\n    this.isCoordinateChanged = isCoordinateChanged;\n  };\n  /**\n   * 将原始数据映射至图形空间，同时创建图形对象。\n   */\n  Geometry.prototype.paint = function (isUpdate) {\n    var _this = this;\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    if (this.animateOption) {\n      this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);\n    }\n    this.defaultSize = undefined;\n    this.elementsMap = {};\n    this.elements = [];\n    var offscreenGroup = this.getOffscreenGroup();\n    offscreenGroup.clear();\n    var beforeMappingData = this.beforeMappingData;\n    var dataArray = this.beforeMapping(beforeMappingData);\n    this.dataArray = new Array(dataArray.length);\n    for (var i = 0; i < dataArray.length; i++) {\n      var data = dataArray[i];\n      this.dataArray[i] = this.mapping(data);\n    }\n    this.updateElements(this.dataArray, isUpdate);\n    this.lastElementsMap = this.elementsMap;\n    if (this.canDoGroupAnimation(isUpdate)) {\n      // 如果用户没有配置 appear.animation，就默认走整体动画\n      var container = this.container;\n      var type = this.type;\n      var coordinate = this.coordinate;\n      var animateCfg = get(this.animateOption, 'appear');\n      var yScale = this.getYScale();\n      var yMinPoint = coordinate.convert({\n        x: 0,\n        y: yScale.scale(this.getYMinValue())\n      });\n      doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);\n    }\n    // 添加 label\n    if (this.labelOption) {\n      var deferred = this.useDeferredLabel;\n      var callback = function () {\n        return _this.renderLabels(flatten(_this.dataArray), isUpdate);\n      }.bind(this);\n      if (typeof deferred === 'number') {\n        // Use `requestIdleCallback` to render labels in idle time (like react fiber)\n        var timeout = typeof deferred === 'number' && deferred !== Infinity ? deferred : 0;\n        if (!window.requestIdleCallback) {\n          setTimeout(callback, timeout);\n        } else {\n          var options = timeout && timeout !== Infinity ? {\n            timeout: timeout\n          } : undefined;\n          window.requestIdleCallback(callback, options);\n        }\n      } else {\n        callback();\n      }\n    }\n    // 缓存，用于更新\n    this.lastAttributeOption = __assign({}, this.attributeOption);\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  };\n  /**\n   * 清空当前 Geometry，配置项仍保留，但是内部创建的对象全部清空。\n   * @override\n   */\n  Geometry.prototype.clear = function () {\n    var _a = this,\n      container = _a.container,\n      geometryLabel = _a.geometryLabel,\n      offscreenGroup = _a.offscreenGroup;\n    if (container) {\n      container.clear();\n    }\n    if (geometryLabel) {\n      geometryLabel.clear();\n    }\n    if (offscreenGroup) {\n      offscreenGroup.clear();\n    }\n    // 属性恢复至出厂状态\n    this.scaleDefs = undefined;\n    this.attributes = {};\n    this.scales = {};\n    this.elementsMap = {};\n    this.lastElementsMap = {};\n    this.elements = [];\n    this.adjusts = {};\n    this.dataArray = null;\n    this.beforeMappingData = null;\n    this.lastAttributeOption = undefined;\n    this.defaultSize = undefined;\n    this.idFields = [];\n    this.groupScales = undefined;\n    this.hasSorted = false;\n    this.isCoordinateChanged = false;\n  };\n  /**\n   * 销毁 Geometry 实例。\n   */\n  Geometry.prototype.destroy = function () {\n    this.clear();\n    var container = this.container;\n    container.remove(true);\n    if (this.offscreenGroup) {\n      this.offscreenGroup.remove(true);\n      this.offscreenGroup = null;\n    }\n    if (this.geometryLabel) {\n      this.geometryLabel.destroy();\n      this.geometryLabel = null;\n    }\n    this.theme = undefined;\n    this.shapeFactory = undefined;\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 获取决定分组的图形属性对应的 scale 实例。\n   * @returns\n   */\n  Geometry.prototype.getGroupScales = function () {\n    return this.groupScales;\n  };\n  /**\n   * 根据名字获取图形属性实例。\n   */\n  Geometry.prototype.getAttribute = function (name) {\n    return this.attributes[name];\n  };\n  /** 获取 x 轴对应的 scale 实例。 */\n  Geometry.prototype.getXScale = function () {\n    return this.getAttribute('position').scales[0];\n  };\n  /** 获取 y 轴对应的 scale 实例。 */\n  Geometry.prototype.getYScale = function () {\n    return this.getAttribute('position').scales[1];\n  };\n  /**\n   * 获取决定分组的图形属性实例。\n   */\n  Geometry.prototype.getGroupAttributes = function () {\n    var rst = [];\n    each(this.attributes, function (attr) {\n      if (GROUP_ATTRS.includes(attr.type)) {\n        rst.push(attr);\n      }\n    });\n    return rst;\n  };\n  /** 获取图形属性默认的映射值。 */\n  Geometry.prototype.getDefaultValue = function (attrName) {\n    var value;\n    var attr = this.getAttribute(attrName);\n    if (attr && isEmpty(attr.scales)) {\n      // 获取映射至常量的值\n      value = attr.values[0];\n    }\n    return value;\n  };\n  /**\n   * 获取该数据发生图形映射后对应的 Attribute 图形空间数据。\n   * @param attr Attribute 图形属性实例。\n   * @param obj 需要进行映射的原始数据。\n   * @returns\n   */\n  Geometry.prototype.getAttributeValues = function (attr, obj) {\n    var params = [];\n    var scales = attr.scales;\n    for (var index = 0, length_1 = scales.length; index < length_1; index++) {\n      var scale = scales[index];\n      var field = scale.field;\n      if (scale.isIdentity) {\n        params.push(scale.values);\n      } else {\n        params.push(obj[field]);\n      }\n    }\n    return attr.mapping.apply(attr, __spreadArray([], __read(params), false));\n  };\n  /**\n   * 获取对应的 adjust 实例\n   * @param adjustType\n   * @returns\n   */\n  Geometry.prototype.getAdjust = function (adjustType) {\n    return this.adjusts[adjustType];\n  };\n  /**\n   * 获得 coordinate 实例\n   * @returns\n   */\n  Geometry.prototype.getCoordinate = function () {\n    return this.coordinate;\n  };\n  Geometry.prototype.getData = function () {\n    return this.data;\n  };\n  /**\n   * 获取 shape 对应的 marker 样式。\n   * @param shapeName shape 具体名字\n   * @param cfg marker 信息\n   * @returns\n   */\n  Geometry.prototype.getShapeMarker = function (shapeName, cfg) {\n    var shapeFactory = this.getShapeFactory();\n    return shapeFactory.getMarker(shapeName, cfg);\n  };\n  /**\n   * 根据一定的规则查找 Geometry 的 Elements。\n   *\n   * ```typescript\n   * getElementsBy((element) => {\n   *   const data = element.getData();\n   *\n   *   return data.a === 'a';\n   * });\n   * ```\n   *\n   * @param condition 定义查找规则的回调函数。\n   * @returns\n   */\n  Geometry.prototype.getElementsBy = function (condition) {\n    return this.elements.filter(function (element) {\n      return condition(element);\n    });\n  };\n  /**\n   * 获取 Geometry 的所有 Elements。\n   *\n   * ```typescript\n   * getElements();\n   * ```\n   */\n  Geometry.prototype.getElements = function () {\n    return this.elements;\n  };\n  /**\n   * 获取数据对应的唯一 id。\n   * @param data Element 对应的绘制数据\n   * @returns\n   */\n  Geometry.prototype.getElementId = function (data) {\n    data = isArray(data) ? data[0] : data;\n    var originData = data[FIELD_ORIGIN];\n    // 如果用户声明了使用哪些字段作为 id 值\n    if (this.idFields.length) {\n      var elementId = originData[this.idFields[0]];\n      for (var index = 1; index < this.idFields.length; index++) {\n        elementId += '-' + originData[this.idFields[index]];\n      }\n      return elementId;\n    }\n    var type = this.type;\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var xField = xScale.field || 'x';\n    var yField = yScale.field || 'y';\n    var yVal = originData[yField];\n    var xVal;\n    if (xScale.type === 'identity') {\n      xVal = xScale.values[0];\n    } else {\n      xVal = originData[xField];\n    }\n    var id;\n    if (type === 'interval' || type === 'schema') {\n      id = \"\".concat(xVal);\n    } else if (type === 'line' || type === 'area' || type === 'path') {\n      id = type;\n    } else {\n      id = \"\".concat(xVal, \"-\").concat(yVal);\n    }\n    var groupScales = this.groupScales;\n    for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {\n      var groupScale = groupScales[index];\n      var field = groupScale.field;\n      id = \"\".concat(id, \"-\").concat(originData[field]);\n    }\n    // 用户在进行 dodge 类型的 adjust 调整的时候设置了 dodgeBy 属性\n    var dodgeAdjust = this.getAdjust('dodge');\n    if (dodgeAdjust) {\n      var dodgeBy = dodgeAdjust.dodgeBy;\n      if (dodgeBy) {\n        id = \"\".concat(id, \"-\").concat(originData[dodgeBy]);\n      }\n    }\n    if (this.getAdjust('jitter')) {\n      id = \"\".concat(id, \"-\").concat(data.x, \"-\").concat(data.y);\n    }\n    return id;\n  };\n  /**\n   * 获取所有需要创建 scale 的字段名称。\n   */\n  Geometry.prototype.getScaleFields = function () {\n    var fields = [];\n    var tmpMap = new Map();\n    var _a = this,\n      attributeOption = _a.attributeOption,\n      labelOption = _a.labelOption,\n      tooltipOption = _a.tooltipOption;\n    // 获取图形属性上的 fields\n    for (var attributeType in attributeOption) {\n      if (attributeOption.hasOwnProperty(attributeType)) {\n        var eachOpt = attributeOption[attributeType];\n        if (eachOpt.fields) {\n          uniq(eachOpt.fields, fields, tmpMap);\n        } else if (eachOpt.values) {\n          // 考虑 size(10), shape('circle') 等场景\n          uniq(eachOpt.values, fields, tmpMap);\n        }\n      }\n    }\n    // 获取 label 上的字段\n    if (labelOption && labelOption.fields) {\n      uniq(labelOption.fields, fields, tmpMap);\n    }\n    // 获取 tooltip 上的字段\n    if (isObject(tooltipOption) && tooltipOption.fields) {\n      uniq(tooltipOption.fields, fields, tmpMap);\n    }\n    return fields;\n  };\n  /**\n   * 显示或者隐藏 geometry。\n   * @param visible\n   */\n  Geometry.prototype.changeVisible = function (visible) {\n    _super.prototype.changeVisible.call(this, visible);\n    var elements = this.elements;\n    for (var index = 0, length_3 = elements.length; index < length_3; index++) {\n      var element = elements[index];\n      element.changeVisible(visible);\n    }\n    if (visible) {\n      if (this.container) {\n        this.container.show();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.show();\n      }\n    } else {\n      if (this.container) {\n        this.container.hide();\n      }\n      if (this.labelsContainer) {\n        this.labelsContainer.hide();\n      }\n    }\n  };\n  /**\n   * 获得所有的字段\n   */\n  Geometry.prototype.getFields = function () {\n    var uniqMap = new Map();\n    var fields = [];\n    Object.values(this.attributeOption).forEach(function (cfg) {\n      var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];\n      fs.forEach(function (f) {\n        if (!uniqMap.has(f)) {\n          fields.push(f);\n        }\n        uniqMap.set(f, true);\n      });\n    }, []);\n    return fields;\n  };\n  /**\n   * 获取当前配置中的所有分组 & 分类的字段。\n   * @return fields string[]\n   */\n  Geometry.prototype.getGroupFields = function () {\n    var groupFields = [];\n    var tmpMap = new Map(); // 用于去重过滤\n    for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {\n      var attributeName = GROUP_ATTRS[index];\n      var cfg = this.attributeOption[attributeName];\n      if (cfg && cfg.fields) {\n        uniq(cfg.fields, groupFields, tmpMap);\n      }\n    }\n    return groupFields;\n  };\n  /**\n   * 获得图形的 x y 字段。\n   */\n  Geometry.prototype.getXYFields = function () {\n    var _a = __read(this.attributeOption.position.fields, 2),\n      x = _a[0],\n      y = _a[1];\n    return [x, y];\n  };\n  /**\n   * x 字段\n   * @returns\n   */\n  Geometry.prototype.getXField = function () {\n    return get(this.getXYFields(), [0]);\n  };\n  /**\n   * y 字段\n   * @returns\n   */\n  Geometry.prototype.getYField = function () {\n    return get(this.getXYFields(), [1]);\n  };\n  /**\n   * 获取该 Geometry 下所有生成的 shapes。\n   * @returns shapes\n   */\n  Geometry.prototype.getShapes = function () {\n    return this.elements.map(function (element) {\n      return element.shape;\n    });\n  };\n  /**\n   * 获取虚拟 Group。\n   * @returns\n   */\n  Geometry.prototype.getOffscreenGroup = function () {\n    if (!this.offscreenGroup) {\n      var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n    return this.offscreenGroup;\n  };\n  // 对数据进行排序\n  Geometry.prototype.sort = function (mappingArray) {\n    if (!this.hasSorted) {\n      // 未发生过排序\n      var xScale_1 = this.getXScale();\n      var xField_1 = xScale_1.field;\n      for (var index = 0; index < mappingArray.length; index++) {\n        var itemArr = mappingArray[index];\n        itemArr.sort(function (obj1, obj2) {\n          return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);\n        });\n      }\n    }\n    this.hasSorted = true;\n  };\n  /**\n   * 调整度量范围。主要针对发生层叠以及一些特殊需求的 Geometry，比如 Interval 下的柱状图 Y 轴默认从 0 开始。\n   */\n  Geometry.prototype.adjustScale = function () {\n    var yScale = this.getYScale();\n    // 如果数据发生过 stack adjust，需要调整下 yScale 的数据范围\n    if (yScale && this.getAdjust('stack')) {\n      this.updateStackRange(yScale, this.beforeMappingData);\n    }\n  };\n  /**\n   * 获取当前 Geometry 对应的 Shape 工厂实例。\n   */\n  Geometry.prototype.getShapeFactory = function () {\n    var shapeType = this.shapeType;\n    if (!getShapeFactory(shapeType)) {\n      return;\n    }\n    if (!this.shapeFactory) {\n      this.shapeFactory = clone(getShapeFactory(shapeType)); // 防止多个 view 共享一个 shapeFactory 实例，导致 coordinate 被篡改\n    }\n    // 因为这里缓存了 shapeFactory，但是外部可能会变更 coordinate，导致无法重新设置到 shapeFactory 中\n    this.shapeFactory.coordinate = this.coordinate;\n    // theme 原因同上\n    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};\n    return this.shapeFactory;\n  };\n  /**\n   * 获取每个 Shape 对应的关键点数据。\n   * @param obj 经过分组 -> 数字化 -> adjust 调整后的数据记录\n   * @returns\n   */\n  Geometry.prototype.createShapePointsCfg = function (obj) {\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n    var x = this.normalizeValues(obj[xScale.field], xScale);\n    var y; // 存在没有 y 的情况\n    if (yScale) {\n      y = this.normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n    return {\n      x: x,\n      y: y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  };\n  /**\n   * 创建 Element 实例。\n   * @param mappingDatum Element 对应的绘制数据\n   * @param [isUpdate] 是否处于更新阶段\n   * @returns element 返回创建的 Element 实例\n   */\n  Geometry.prototype.createElement = function (mappingDatum, index, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    var container = this.container;\n    var shapeCfg = this.getDrawCfg(mappingDatum); // 获取绘制图形的配置信息\n    var shapeFactory = this.getShapeFactory();\n    var element = new Element({\n      shapeFactory: shapeFactory,\n      container: container,\n      offscreenGroup: this.getOffscreenGroup(),\n      elementIndex: index\n    });\n    element.animate = this.animateOption;\n    element.geometry = this;\n    element.draw(shapeCfg, isUpdate); // 绘制\n    return element;\n  };\n  /**\n   * 获取每条数据对应的图形绘制数据。\n   * @param mappingDatum 映射后的数据\n   * @returns draw cfg\n   */\n  Geometry.prototype.getDrawCfg = function (mappingDatum) {\n    var originData = mappingDatum[FIELD_ORIGIN]; // 原始数据\n    var cfg = {\n      mappingData: mappingDatum,\n      data: originData,\n      x: mappingDatum.x,\n      y: mappingDatum.y,\n      color: mappingDatum.color,\n      size: mappingDatum.size,\n      isInCircle: this.coordinate.isPolar,\n      customInfo: this.customOption\n    };\n    var shapeName = mappingDatum.shape;\n    if (!shapeName && this.getShapeFactory()) {\n      shapeName = this.getShapeFactory().defaultShapeType;\n    }\n    cfg.shape = shapeName;\n    // 获取默认样式\n    var theme = this.theme.geometries[this.shapeType];\n    cfg.defaultStyle = get(theme, [shapeName, 'default'], {}).style;\n    if (!cfg.defaultStyle && this.getShapeFactory()) {\n      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);\n    }\n    var styleOption = this.styleOption;\n    if (styleOption) {\n      cfg.style = this.getStyleCfg(styleOption, originData);\n    }\n    if (this.generatePoints) {\n      cfg.points = mappingDatum.points;\n      cfg.nextPoints = mappingDatum.nextPoints;\n    }\n    return cfg;\n  };\n  Geometry.prototype.updateElements = function (mappingDataArray, isUpdate) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    var keyDatum = new Map();\n    var keys = [];\n    // 用来保持 diff 元素之后 added, updated 的相对顺序\n    var keyIndex = new Map();\n    var index = 0;\n    // 获得更新数据所有的 keys\n    // 将更新的数据用 key 索引\n    for (var i = 0; i < mappingDataArray.length; i++) {\n      var mappingData = mappingDataArray[i];\n      for (var j = 0; j < mappingData.length; j++) {\n        var mappingDatum = mappingData[j];\n        var key = this.getElementId(mappingDatum);\n        var finalKey = keyDatum.has(key) ? \"\".concat(key, \"-\").concat(i, \"-\").concat(j) : key;\n        keys.push(finalKey);\n        keyDatum.set(finalKey, mappingDatum);\n        keyIndex.set(finalKey, index);\n        index++;\n      }\n    }\n    this.elements = new Array(index);\n    var _d = diff(this.lastElementsMap, keys),\n      added = _d.added,\n      updated = _d.updated,\n      removed = _d.removed;\n    try {\n      // 新建 element\n      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {\n        var key = added_1_1.value;\n        var mappingDatum = keyDatum.get(key);\n        var i = keyIndex.get(key);\n        var element = this.createElement(mappingDatum, i, isUpdate);\n        this.elements[i] = element;\n        this.elementsMap[key] = element;\n        if (element.shape) {\n          element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (added_1_1 && !added_1_1.done && (_a = added_1.return)) _a.call(added_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    try {\n      // 更新 element\n      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {\n        var key = updated_1_1.value;\n        var element = this.lastElementsMap[key];\n        var mappingDatum = keyDatum.get(key);\n        var currentShapeCfg = this.getDrawCfg(mappingDatum);\n        var preShapeCfg = element.getModel();\n        var i = keyIndex.get(key);\n        if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {\n          element.animate = this.animateOption;\n          // 通过绘制数据的变更来判断是否需要更新，因为用户有可能会修改图形属性映射\n          element.update(currentShapeCfg); // 更新对应的 element\n        }\n\n        this.elements[i] = element;\n        this.elementsMap[key] = element;\n        if (element.shape) {\n          element.shape.set('zIndex', this.zIndexReversed ? this.elements.length - i : i);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return)) _b.call(updated_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    // 全部 setZIndex 之后，再执行 sort\n    if (this.container) {\n      this.container.sort();\n    }\n    try {\n      // 销毁被删除的 elements\n      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {\n        var key = removed_1_1.value;\n        var element = this.lastElementsMap[key];\n        // 更新动画配置，用户有可能在更新之前有对动画进行配置操作\n        element.animate = this.animateOption;\n        element.destroy();\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return)) _c.call(removed_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n  /**\n   * 获取渲染的 label 类型。\n   */\n  Geometry.prototype.getLabelType = function () {\n    var _a = this,\n      labelOption = _a.labelOption,\n      coordinate = _a.coordinate,\n      type = _a.type;\n    var coordinateType = coordinate.type,\n      isTransposed = coordinate.isTransposed;\n    var labelType = get(labelOption, ['cfg', 'type']);\n    if (!labelType) {\n      // 用户未定义，则进行默认的逻辑\n      if (coordinateType === 'polar') {\n        // 极坐标下使用通用的极坐标文本，转置则使用饼图\n        labelType = isTransposed ? 'pie' : 'polar';\n      } else if (coordinateType === 'theta') {\n        // theta 坐标系下使用饼图文本\n        labelType = 'pie';\n      } else if (type === 'interval' || type === 'polygon') {\n        labelType = 'interval';\n      } else {\n        labelType = 'base';\n      }\n    }\n    return labelType;\n  };\n  /**\n   * 获取 Y 轴上的最小值。\n   */\n  Geometry.prototype.getYMinValue = function () {\n    var yScale = this.getYScale();\n    var min = yScale.min,\n      max = yScale.max;\n    var value;\n    if (min >= 0) {\n      value = min;\n    } else if (max <= 0) {\n      // 当值全位于负区间时，需要保证 ymin 在区域内，不可为 0\n      value = max;\n    } else {\n      value = 0;\n    }\n    return value;\n  };\n  // 创建图形属性相关的配置项\n  Geometry.prototype.createAttrOption = function (attrName, field, cfg) {\n    if (isNil(field) || isObject(field)) {\n      if (isObject(field) && isEqual(Object.keys(field), ['values'])) {\n        // shape({ values: [ 'funnel' ] })\n        set(this.attributeOption, attrName, {\n          fields: field.values\n        });\n      } else {\n        set(this.attributeOption, attrName, field);\n      }\n    } else {\n      var attrCfg = {};\n      if (isNumber(field)) {\n        // size(3)\n        attrCfg.values = [field];\n      } else {\n        attrCfg.fields = parseFields(field);\n      }\n      if (cfg) {\n        if (isFunction(cfg)) {\n          attrCfg.callback = cfg;\n        } else {\n          attrCfg.values = cfg;\n        }\n      }\n      set(this.attributeOption, attrName, attrCfg);\n    }\n  };\n  Geometry.prototype.initAttributes = function () {\n    var _this = this;\n    var _a = this,\n      attributes = _a.attributes,\n      attributeOption = _a.attributeOption,\n      theme = _a.theme,\n      shapeType = _a.shapeType;\n    this.groupScales = [];\n    var tmpMap = {};\n    var _loop_1 = function _loop_1(attrType) {\n      if (attributeOption.hasOwnProperty(attrType)) {\n        var option = attributeOption[attrType];\n        if (!option) {\n          return {\n            value: void 0\n          };\n        }\n        var attrCfg = __assign({}, option);\n        var callback = attrCfg.callback,\n          values = attrCfg.values,\n          _b = attrCfg.fields,\n          fields = _b === void 0 ? [] : _b;\n        // 获取每一个字段对应的 scale\n        var scales = fields.map(function (field) {\n          var scale = _this.scales[field];\n          if (!tmpMap[field] && GROUP_ATTRS.includes(attrType)) {\n            var inferedScaleType = inferScaleType(scale, get(_this.scaleDefs, field), attrType, _this.type);\n            if (inferedScaleType === 'cat') {\n              _this.groupScales.push(scale);\n              tmpMap[field] = true;\n            }\n          }\n          return scale;\n        });\n        attrCfg.scales = scales;\n        if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {\n          // 用户在图形通道上声明了常量字段 color('red'), size(5)\n          attrCfg.values = scales[0].values;\n        } else if (!callback && !values) {\n          // 用户没有指定任何规则，则使用默认的映射规则\n          if (attrType === 'size') {\n            attrCfg.values = theme.sizes;\n          } else if (attrType === 'shape') {\n            attrCfg.values = theme.shapes[shapeType] || [];\n          } else if (attrType === 'color') {\n            if (scales.length) {\n              // 根据数值个数使用对应的色板\n              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;\n            } else {\n              attrCfg.values = theme.colors10;\n            }\n          }\n        }\n        var AttributeCtor = getAttributeClass(attrType);\n        attributes[attrType] = new AttributeCtor(attrCfg);\n      }\n    };\n    // 遍历每一个 attrOption，各自创建 Attribute 实例\n    for (var attrType in attributeOption) {\n      var state_1 = _loop_1(attrType);\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n  };\n  // 处理数据：分组 -> 数字化 -> adjust 调整\n  Geometry.prototype.processData = function (data) {\n    var e_4, _a;\n    this.hasSorted = false;\n    var scales = this.getAttribute('position').scales;\n    var categoryScales = scales.filter(function (scale) {\n      return scale.isCategory;\n    });\n    var groupedArray = this.groupData(data); // 数据分组\n    var beforeAdjust = [];\n    for (var i = 0, len = groupedArray.length; i < len; i++) {\n      var subData = groupedArray[i];\n      var arr = [];\n      for (var j = 0, subLen = subData.length; j < subLen; j++) {\n        var originData = subData[j];\n        var item = {};\n        // tslint:disable-next-line: forin\n        for (var k in originData) {\n          item[k] = originData[k];\n        }\n        item[FIELD_ORIGIN] = originData;\n        try {\n          // 将分类数据翻译成数据, 仅对位置相关的度量进行数字化处理\n          for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {\n            var scale = categoryScales_1_1.value;\n            var field = scale.field;\n            item[field] = scale.translate(item[field]);\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (categoryScales_1_1 && !categoryScales_1_1.done && (_a = categoryScales_1.return)) _a.call(categoryScales_1);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n        arr.push(item);\n      }\n      beforeAdjust.push(arr);\n    }\n    var dataArray = this.adjustData(beforeAdjust); // 进行 adjust 数据调整\n    this.beforeMappingData = dataArray;\n    return dataArray;\n  };\n  // 调整数据\n  Geometry.prototype.adjustData = function (dataArray) {\n    var adjustOption = this.adjustOption;\n    var _a = this,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding,\n      theme = _a.theme;\n    // 兼容theme配置\n    var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;\n    var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;\n    var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;\n    var result = dataArray;\n    if (adjustOption) {\n      var xScale_2 = this.getXScale();\n      var yScale = this.getYScale();\n      var xField = xScale_2.field;\n      var yField = yScale ? yScale.field : null;\n      var xDimensionLength = getXDimensionLength(this.coordinate);\n      var groupNum = xScale_2.values.length;\n      // 传入size计算相关参数，默认宽度、最大最小宽度约束\n      var sizeAttr = this.getAttribute('size');\n      var defaultSize = void 0;\n      if (sizeAttr) {\n        defaultSize = sizeAttr.values[0];\n      }\n      for (var i = 0, len = adjustOption.length; i < len; i++) {\n        var adjust = adjustOption[i];\n        var adjustCfg = __assign({\n          xField: xField,\n          yField: yField,\n          intervalPadding: intervalPadding,\n          dodgePadding: dodgePadding,\n          xDimensionLength: xDimensionLength,\n          groupNum: groupNum,\n          defaultSize: defaultSize,\n          maxColumnWidth: maxColumnWidth,\n          minColumnWidth: minColumnWidth,\n          columnWidthRatio: columnWidthRatio\n        }, adjust);\n        var type = adjust.type;\n        if (type === 'dodge') {\n          var adjustNames = [];\n          if (xScale_2.isCategory || xScale_2.type === 'identity') {\n            adjustNames.push('x');\n          } else if (!yScale) {\n            adjustNames.push('y');\n          } else {\n            throw new Error('dodge is not support linear attribute, please use category attribute!');\n          }\n          adjustCfg.adjustNames = adjustNames;\n          // 每个分组内每条柱子的宽度占比，用户不可指定，用户需要通过 columnWidthRatio 指定\n          // 兼容theme配置\n          adjustCfg.dodgeRatio = columnWidthRatio;\n        } else if (type === 'stack') {\n          var coordinate = this.coordinate;\n          if (!yScale) {\n            // 一维的情况下获取高度和默认size\n            adjustCfg.height = coordinate.getHeight();\n            var size = this.getDefaultValue('size') || 3;\n            adjustCfg.size = size;\n          }\n          // 不进行 transpose 时，用户又没有设置这个参数时，默认从上向下\n          if (!coordinate.isTransposed && isNil(adjustCfg.reverseOrder)) {\n            adjustCfg.reverseOrder = true;\n          }\n        }\n        var adjustCtor = getAdjustClass(type);\n        adjustCfg.dimValuesMap = {};\n        //生成dimValuesMap\n        if (xScale_2 && xScale_2.values) {\n          adjustCfg.dimValuesMap[xScale_2.field] = xScale_2.values.map(function (v) {\n            return xScale_2.translate(v);\n          });\n        }\n        var adjustInstance = new adjustCtor(adjustCfg);\n        result = adjustInstance.process(result);\n        this.adjusts[type] = adjustInstance;\n      }\n    }\n    return result;\n  };\n  // 对数据进行分组\n  Geometry.prototype.groupData = function (data) {\n    var groupScales = this.getGroupScales();\n    var scaleDefs = this.scaleDefs;\n    var appendConditions = {};\n    var groupFields = [];\n    for (var index = 0; index < groupScales.length; index++) {\n      var scale = groupScales[index];\n      var field = scale.field;\n      groupFields.push(field);\n      if (get(scaleDefs, [field, 'values'])) {\n        // 用户通过 view.scale() 接口指定了 values 属性\n        appendConditions[field] = scaleDefs[field].values;\n      }\n    }\n    return group(data, groupFields, appendConditions);\n  };\n  // 更新发生层叠后的数据对应的度量范围\n  Geometry.prototype.updateStackRange = function (scale, dataArray) {\n    var mergeArray = flatten(dataArray);\n    var field = scale.field;\n    var min = scale.min;\n    var max = scale.max;\n    for (var index = 0; index < mergeArray.length; index++) {\n      var obj = mergeArray[index];\n      var tmpMin = Math.min.apply(null, obj[field]);\n      var tmpMax = Math.max.apply(null, obj[field]);\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n    var scaleDefs = this.scaleDefs;\n    var cfg = {};\n    if (min < scale.min && !get(scaleDefs, [field, 'min'])) {\n      // 用户如果在列定义中定义了 min，则以用户定义的为准\n      cfg.min = min;\n    }\n    if (max > scale.max && !get(scaleDefs, [field, 'max'])) {\n      // 用户如果在列定义中定义了 max\n      cfg.max = max;\n    }\n    scale.change(cfg);\n  };\n  // 将数据映射至图形空间前的操作：排序以及关键点的生成\n  Geometry.prototype.beforeMapping = function (beforeMappingData) {\n    // 当初加 clone 是因为 points 的引用关系，导致更新失败，可是现在貌似复现不出来了，所以暂时不进行 clone\n    // const source = clone(beforeMappingData);\n    var source = beforeMappingData;\n    if (this.sortable) {\n      this.sort(source);\n    }\n    if (this.generatePoints) {\n      // 需要生成关键点\n      for (var index = 0, length_5 = source.length; index < length_5; index++) {\n        var currentData = source[index];\n        this.generateShapePoints(currentData);\n        var nextData = source[index + 1];\n        if (nextData) {\n          this.generateShapePoints(nextData);\n          currentData[0].nextPoints = nextData[0].points;\n        }\n      }\n    }\n    return source;\n  };\n  // 生成 shape 的关键点\n  Geometry.prototype.generateShapePoints = function (data) {\n    var shapeFactory = this.getShapeFactory();\n    var shapeAttr = this.getAttribute('shape');\n    for (var index = 0; index < data.length; index++) {\n      var obj = data[index];\n      var cfg = this.createShapePointsCfg(obj);\n      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;\n      var points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  };\n  // 将数据归一化\n  Geometry.prototype.normalizeValues = function (values, scale) {\n    var rst = [];\n    if (isArray(values)) {\n      for (var index = 0; index < values.length; index++) {\n        var value = values[index];\n        rst.push(scale.scale(value));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n    return rst;\n  };\n  // 将数据映射至图形空间\n  Geometry.prototype.mapping = function (data) {\n    var attributes = this.attributes;\n    var mappingData = [];\n    for (var index = 0; index < data.length; index++) {\n      var record = data[index];\n      var newRecord = {\n        _origin: record[FIELD_ORIGIN],\n        points: record.points,\n        nextPoints: record.nextPoints\n      };\n      for (var k in attributes) {\n        if (attributes.hasOwnProperty(k)) {\n          var attr = attributes[k];\n          var names = attr.names;\n          var values = this.getAttributeValues(attr, record);\n          if (names.length > 1) {\n            // position 之类的生成多个字段的属性\n            for (var j = 0; j < values.length; j += 1) {\n              var val = values[j];\n              var name_1 = names[j];\n              newRecord[name_1] = isArray(val) && val.length === 1 ? val[0] : val; // 只有一个值时返回第一个属性值\n            }\n          } else {\n            // values.length === 1 的判断是以下情况，获取用户设置的图形属性值\n            // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n      this.convertPoint(newRecord); // 将 x、y 转换成画布坐标\n      mappingData.push(newRecord);\n    }\n    return mappingData;\n  };\n  // 将归一化的坐标值转换成画布坐标\n  Geometry.prototype.convertPoint = function (mappingRecord) {\n    var x = mappingRecord.x,\n      y = mappingRecord.y;\n    var rstX;\n    var rstY;\n    var obj;\n    var coordinate = this.coordinate;\n    if (isArray(x) && isArray(y)) {\n      rstX = [];\n      rstY = [];\n      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {\n        obj = coordinate.convert({\n          x: x[i],\n          y: y[j]\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      rstY = [];\n      for (var index = 0; index < y.length; index++) {\n        var yVal = y[index];\n        obj = coordinate.convert({\n          x: x,\n          y: yVal\n        });\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n        rstY.push(obj.y);\n      }\n    } else if (isArray(x)) {\n      rstX = [];\n      for (var index = 0; index < x.length; index++) {\n        var xVal = x[index];\n        obj = coordinate.convert({\n          x: xVal,\n          y: y\n        });\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n        rstX.push(obj.x);\n      }\n    } else {\n      var point = coordinate.convert({\n        x: x,\n        y: y\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n    mappingRecord.x = rstX;\n    mappingRecord.y = rstY;\n  };\n  // 获取 style 配置\n  Geometry.prototype.getStyleCfg = function (styleOption, originData) {\n    var _a = styleOption.fields,\n      fields = _a === void 0 ? [] : _a,\n      callback = styleOption.callback,\n      cfg = styleOption.cfg;\n    if (cfg) {\n      // 用户直接配置样式属性\n      return cfg;\n    }\n    var params = fields.map(function (field) {\n      return originData[field];\n    });\n    return callback.apply(void 0, __spreadArray([], __read(params), false));\n  };\n  Geometry.prototype.setCfg = function (cfg) {\n    var _this = this;\n    var coordinate = cfg.coordinate,\n      data = cfg.data,\n      theme = cfg.theme,\n      scaleDefs = cfg.scaleDefs;\n    if (coordinate) {\n      this.coordinate = coordinate;\n    }\n    if (data) {\n      this.data = data;\n    }\n    if (scaleDefs) {\n      this.scaleDefs = scaleDefs;\n      this.idFields = [];\n      each(scaleDefs, function (scaleDef, field) {\n        if (scaleDef && scaleDef.key) {\n          _this.idFields.push(field);\n        }\n      });\n    }\n    if (theme) {\n      this.theme = this.userTheme ? deepMix({}, theme, this.userTheme) : theme; // 支持 geometry 层级的主题设置\n    }\n  };\n\n  Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a, _b, _c, element, labels;\n      var e_5, _d;\n      var _this = this;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            geometryLabel = this.geometryLabel;\n            this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);\n            if (!geometryLabel) {\n              labelType = this.getLabelType();\n              GeometryLabelsCtor = getGeometryLabel(labelType);\n              geometryLabel = new GeometryLabelsCtor(this);\n              this.geometryLabel = geometryLabel;\n            }\n            return [4 /*yield*/, geometryLabel.render(mappingArray, isUpdate)];\n          case 1:\n            _e.sent();\n            labelsMap = geometryLabel.labelsRenderer.shapesMap;\n            elementLabels = new Map();\n            each(labelsMap, function (labelGroup, labelGroupId) {\n              var labelChildren = labelGroup.getChildren() || [];\n              for (var j = 0; j < labelChildren.length; j++) {\n                var labelShape = labelChildren[j];\n                var element = _this.elementsMap[labelShape.get('elementId') || labelGroupId.split(' ')[0]];\n                if (element) {\n                  labelShape.cfg.name = ['element', 'label'];\n                  labelShape.cfg.element = element;\n                  var labels = elementLabels.get(element) || new Set();\n                  labels.add(labelGroup);\n                  elementLabels.set(element, labels);\n                }\n              }\n            });\n            try {\n              for (_a = __values(elementLabels.entries()), _b = _a.next(); !_b.done; _b = _a.next()) {\n                _c = __read(_b.value, 2), element = _c[0], labels = _c[1];\n                element.labelShape = __spreadArray([], __read(labels), false);\n              }\n            } catch (e_5_1) {\n              e_5 = {\n                error: e_5_1\n              };\n            } finally {\n              try {\n                if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\n              } finally {\n                if (e_5) throw e_5.error;\n              }\n            }\n            this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * 是否需要进行群组入场动画\n   * 规则：\n   * 1. 如果发生更新，则不进行\n   * 2. 如果用户关闭 geometry 动画，则不进行\n   * 3. 如果用户关闭了 appear 动画，则不进行\n   * 4. 如果用户配置了 appear.animation，则不进行\n   */\n  Geometry.prototype.canDoGroupAnimation = function (isUpdate) {\n    return !isUpdate && this.animateOption && (get(this.animateOption, 'appear') === undefined || get(this.animateOption, 'appear') && get(this.animateOption, ['appear', 'animation']) === undefined);\n  };\n  return Geometry;\n}(Base);\nexport default Geometry;","map":null,"metadata":{},"sourceType":"module"}