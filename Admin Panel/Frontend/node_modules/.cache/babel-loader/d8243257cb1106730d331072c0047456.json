{"ast":null,"code":"import { justify } from './align';\nimport { constant, maxValueBy, minValueBy, sumBy } from './helper';\nfunction ascendingSourceBreadth(a, b) {\n  return ascendingBreadth(a.source, b.source) || a.index - b.index;\n}\nfunction ascendingTargetBreadth(a, b) {\n  return ascendingBreadth(a.target, b.target) || a.index - b.index;\n}\nfunction ascendingBreadth(a, b) {\n  return a.y0 - b.y0;\n}\nfunction value(d) {\n  return d.value;\n}\nfunction defaultId(d) {\n  return d.index;\n}\nfunction defaultNodes(graph) {\n  return graph.nodes;\n}\nfunction defaultLinks(graph) {\n  return graph.links;\n}\nfunction find(nodeById, id) {\n  var node = nodeById.get(id);\n  if (!node) throw new Error('missing: ' + id);\n  return node;\n}\nfunction computeLinkBreadths(_a) {\n  var nodes = _a.nodes;\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n    var y0 = node.y0;\n    var y1 = y0;\n    for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {\n      var link = _c[_b];\n      link.y0 = y0 + link.width / 2;\n      y0 += link.width;\n    }\n    for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {\n      var link = _e[_d];\n      link.y1 = y1 + link.width / 2;\n      y1 += link.width;\n    }\n  }\n}\nexport function Sankey() {\n  var x0 = 0,\n    y0 = 0,\n    x1 = 1,\n    y1 = 1; // extent\n  var dx = 24; // nodeWidth\n  var dy = 8,\n    py; // nodePadding\n  var id = defaultId;\n  var align = justify;\n  var depth;\n  var sort;\n  var linkSort;\n  var nodes = defaultNodes;\n  var links = defaultLinks;\n  var iterations = 6;\n  function sankey(arg) {\n    var graph = {\n      nodes: nodes(arg),\n      links: links(arg)\n    };\n    computeNodeLinks(graph);\n    computeNodeValues(graph);\n    computeNodeDepths(graph);\n    computeNodeHeights(graph);\n    computeNodeBreadths(graph);\n    computeLinkBreadths(graph);\n    return graph;\n  }\n  sankey.update = function (graph) {\n    computeLinkBreadths(graph);\n    return graph;\n  };\n  sankey.nodeId = function (_) {\n    return arguments.length ? (id = typeof _ === 'function' ? _ : constant(_), sankey) : id;\n  };\n  sankey.nodeAlign = function (_) {\n    return arguments.length ? (align = typeof _ === 'function' ? _ : constant(_), sankey) : align;\n  };\n  sankey.nodeDepth = function (_) {\n    return arguments.length ? (depth = typeof _ === 'function' ? _ : _, sankey) : depth;\n  };\n  sankey.nodeSort = function (_) {\n    return arguments.length ? (sort = _, sankey) : sort;\n  };\n  sankey.nodeWidth = function (_) {\n    return arguments.length ? (dx = +_, sankey) : dx;\n  };\n  sankey.nodePadding = function (_) {\n    return arguments.length ? (dy = py = +_, sankey) : dy;\n  };\n  sankey.nodes = function (_) {\n    return arguments.length ? (nodes = typeof _ === 'function' ? _ : constant(_), sankey) : nodes;\n  };\n  sankey.links = function (_) {\n    return arguments.length ? (links = typeof _ === 'function' ? _ : constant(_), sankey) : links;\n  };\n  sankey.linkSort = function (_) {\n    return arguments.length ? (linkSort = _, sankey) : linkSort;\n  };\n  sankey.size = function (_) {\n    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n  };\n  sankey.extent = function (_) {\n    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n  };\n  sankey.iterations = function (_) {\n    return arguments.length ? (iterations = +_, sankey) : iterations;\n  };\n  function computeNodeLinks(_a) {\n    var nodes = _a.nodes,\n      links = _a.links;\n    nodes.forEach(function (node, idx) {\n      node.index = idx;\n      node.sourceLinks = [];\n      node.targetLinks = [];\n    });\n    var nodeById = new Map(nodes.map(function (d) {\n      return [id(d), d];\n    }));\n    links.forEach(function (link, idx) {\n      link.index = idx;\n      var source = link.source,\n        target = link.target;\n      if (typeof source !== 'object') source = link.source = find(nodeById, source);\n      if (typeof target !== 'object') target = link.target = find(nodeById, target);\n      source.sourceLinks.push(link);\n      target.targetLinks.push(link);\n    });\n    if (linkSort != null) {\n      for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n        var _b = nodes_2[_i],\n          sourceLinks = _b.sourceLinks,\n          targetLinks = _b.targetLinks;\n        sourceLinks.sort(linkSort);\n        targetLinks.sort(linkSort);\n      }\n    }\n  }\n  function computeNodeValues(_a) {\n    var nodes = _a.nodes;\n    for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {\n      var node = nodes_3[_i];\n      node.value = node.fixedValue === undefined ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value)) : node.fixedValue;\n    }\n  }\n  function computeNodeDepths(_a) {\n    var nodes = _a.nodes;\n    var n = nodes.length;\n    var current = new Set(nodes);\n    var next = new Set();\n    var x = 0;\n    while (current.size) {\n      current.forEach(function (node) {\n        node.depth = x;\n        for (var _i = 0, _a = node.sourceLinks; _i < _a.length; _i++) {\n          var target = _a[_i].target;\n          next.add(target);\n        }\n      });\n      if (++x > n) throw new Error('circular link');\n      current = next;\n      next = new Set();\n    }\n    // 如果配置了 depth，则设置自定义 depth\n    if (depth) {\n      var maxDepth = Math.max(maxValueBy(nodes, function (d) {\n        return d.depth;\n      }) + 1, 0);\n      var node = void 0;\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.depth = depth.call(null, node, maxDepth);\n      }\n    }\n  }\n  function computeNodeHeights(_a) {\n    var nodes = _a.nodes;\n    var n = nodes.length;\n    var current = new Set(nodes);\n    var next = new Set();\n    var x = 0;\n    while (current.size) {\n      current.forEach(function (node) {\n        node.height = x;\n        for (var _i = 0, _a = node.targetLinks; _i < _a.length; _i++) {\n          var source = _a[_i].source;\n          next.add(source);\n        }\n      });\n      if (++x > n) throw new Error('circular link');\n      current = next;\n      next = new Set();\n    }\n  }\n  function computeNodeLayers(_a) {\n    var nodes = _a.nodes;\n    var x = Math.max(maxValueBy(nodes, function (d) {\n      return d.depth;\n    }) + 1, 0);\n    var kx = (x1 - x0 - dx) / (x - 1);\n    var columns = new Array(x).fill(0).map(function () {\n      return [];\n    });\n    for (var _i = 0, nodes_4 = nodes; _i < nodes_4.length; _i++) {\n      var node = nodes_4[_i];\n      var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));\n      node.layer = i;\n      node.x0 = x0 + i * kx;\n      node.x1 = node.x0 + dx;\n      if (columns[i]) columns[i].push(node);else columns[i] = [node];\n    }\n    if (sort) for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) {\n      var column = columns_1[_b];\n      column.sort(sort);\n    }\n    return columns;\n  }\n  function initializeNodeBreadths(columns) {\n    var ky = minValueBy(columns, function (c) {\n      return (y1 - y0 - (c.length - 1) * py) / sumBy(c, value);\n    });\n    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n      var nodes_6 = columns_2[_i];\n      var y = y0;\n      for (var _a = 0, nodes_5 = nodes_6; _a < nodes_5.length; _a++) {\n        var node = nodes_5[_a];\n        node.y0 = y;\n        node.y1 = y + node.value * ky;\n        y = node.y1 + py;\n        for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {\n          var link = _c[_b];\n          link.width = link.value * ky;\n        }\n      }\n      y = (y1 - y + py) / (nodes_6.length + 1);\n      for (var i = 0; i < nodes_6.length; ++i) {\n        var node = nodes_6[i];\n        node.y0 += y * (i + 1);\n        node.y1 += y * (i + 1);\n      }\n      reorderLinks(nodes_6);\n    }\n  }\n  function computeNodeBreadths(graph) {\n    var columns = computeNodeLayers(graph);\n    py = Math.min(dy, (y1 - y0) / (maxValueBy(columns, function (c) {\n      return c.length;\n    }) - 1));\n    initializeNodeBreadths(columns);\n    for (var i = 0; i < iterations; ++i) {\n      var alpha = Math.pow(0.99, i);\n      var beta = Math.max(1 - alpha, (i + 1) / iterations);\n      relaxRightToLeft(columns, alpha, beta);\n      relaxLeftToRight(columns, alpha, beta);\n    }\n  }\n  // Reposition each node based on its incoming (target) links.\n  function relaxLeftToRight(columns, alpha, beta) {\n    for (var i = 1, n = columns.length; i < n; ++i) {\n      var column = columns[i];\n      for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {\n        var target = column_1[_i];\n        var y = 0;\n        var w = 0;\n        for (var _a = 0, _b = target.targetLinks; _a < _b.length; _a++) {\n          var _c = _b[_a],\n            source = _c.source,\n            value_1 = _c.value;\n          var v = value_1 * (target.layer - source.layer);\n          y += targetTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        var dy_1 = (y / w - target.y0) * alpha;\n        target.y0 += dy_1;\n        target.y1 += dy_1;\n        reorderNodeLinks(target);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      if (column.length) resolveCollisions(column, beta);\n    }\n  }\n  // Reposition each node based on its outgoing (source) links.\n  function relaxRightToLeft(columns, alpha, beta) {\n    for (var n = columns.length, i = n - 2; i >= 0; --i) {\n      var column = columns[i];\n      for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {\n        var source = column_2[_i];\n        var y = 0;\n        var w = 0;\n        for (var _a = 0, _b = source.sourceLinks; _a < _b.length; _a++) {\n          var _c = _b[_a],\n            target = _c.target,\n            value_2 = _c.value;\n          var v = value_2 * (target.layer - source.layer);\n          y += sourceTop(source, target) * v;\n          w += v;\n        }\n        if (!(w > 0)) continue;\n        var dy_2 = (y / w - source.y0) * alpha;\n        source.y0 += dy_2;\n        source.y1 += dy_2;\n        reorderNodeLinks(source);\n      }\n      if (sort === undefined) column.sort(ascendingBreadth);\n      if (column.length) resolveCollisions(column, beta);\n    }\n  }\n  function resolveCollisions(nodes, alpha) {\n    var i = nodes.length >> 1;\n    var subject = nodes[i];\n    resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);\n    resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);\n    resolveCollisionsTopToBottom(nodes, y0, 0, alpha);\n  }\n  // Push any overlapping nodes down.\n  function resolveCollisionsTopToBottom(nodes, y, i, alpha) {\n    for (; i < nodes.length; ++i) {\n      var node = nodes[i];\n      var dy_3 = (y - node.y0) * alpha;\n      if (dy_3 > 1e-6) node.y0 += dy_3, node.y1 += dy_3;\n      y = node.y1 + py;\n    }\n  }\n  // Push any overlapping nodes up.\n  function resolveCollisionsBottomToTop(nodes, y, i, alpha) {\n    for (; i >= 0; --i) {\n      var node = nodes[i];\n      var dy_4 = (node.y1 - y) * alpha;\n      if (dy_4 > 1e-6) node.y0 -= dy_4, node.y1 -= dy_4;\n      y = node.y0 - py;\n    }\n  }\n  function reorderNodeLinks(_a) {\n    var sourceLinks = _a.sourceLinks,\n      targetLinks = _a.targetLinks;\n    if (linkSort === undefined) {\n      for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) {\n        var sourceLinks_2 = targetLinks_1[_i].source.sourceLinks;\n        sourceLinks_2.sort(ascendingTargetBreadth);\n      }\n      for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) {\n        var targetLinks_2 = sourceLinks_1[_b].target.targetLinks;\n        targetLinks_2.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n  function reorderLinks(nodes) {\n    if (linkSort === undefined) {\n      for (var _i = 0, nodes_7 = nodes; _i < nodes_7.length; _i++) {\n        var _a = nodes_7[_i],\n          sourceLinks = _a.sourceLinks,\n          targetLinks = _a.targetLinks;\n        sourceLinks.sort(ascendingTargetBreadth);\n        targetLinks.sort(ascendingSourceBreadth);\n      }\n    }\n  }\n  // Returns the target.y0 that would produce an ideal link from source to target.\n  function targetTop(source, target) {\n    var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;\n    for (var _i = 0, _a = source.sourceLinks; _i < _a.length; _i++) {\n      var _b = _a[_i],\n        node = _b.target,\n        width = _b.width;\n      if (node === target) break;\n      y += width + py;\n    }\n    for (var _c = 0, _d = target.targetLinks; _c < _d.length; _c++) {\n      var _e = _d[_c],\n        node = _e.source,\n        width = _e.width;\n      if (node === source) break;\n      y -= width;\n    }\n    return y;\n  }\n  // Returns the source.y0 that would produce an ideal link from source to target.\n  function sourceTop(source, target) {\n    var y = target.y0 - (target.targetLinks.length - 1) * py / 2;\n    for (var _i = 0, _a = target.targetLinks; _i < _a.length; _i++) {\n      var _b = _a[_i],\n        node = _b.source,\n        width = _b.width;\n      if (node === source) break;\n      y += width + py;\n    }\n    for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {\n      var _e = _d[_c],\n        node = _e.target,\n        width = _e.width;\n      if (node === target) break;\n      y -= width;\n    }\n    return y;\n  }\n  return sankey;\n}","map":null,"metadata":{},"sourceType":"module"}