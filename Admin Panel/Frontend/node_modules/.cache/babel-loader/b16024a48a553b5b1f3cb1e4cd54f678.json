{"ast":null,"code":"import { Quad as QuadUtil, Cubic as CubicUtil, Arc as EllipseArcUtil } from '@antv/g-math';\nimport { path2Segments } from '@antv/path-util';\nimport { isNumberEqual, max, min } from '@antv/util';\nimport { mergeArrowBBox } from './util';\nfunction getPathBox(segments, lineWidth) {\n  var xArr = [];\n  var yArr = [];\n  var segmentsWithAngle = [];\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n      params = segment.params,\n      prePoint = segment.prePoint;\n    var box = void 0;\n    switch (segment.command) {\n      case 'Q':\n        box = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n        break;\n      case 'C':\n        box = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);\n        break;\n      case 'A':\n        var arcParams = segment.arcParams;\n        box = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);\n        break;\n      default:\n        xArr.push(currentPoint[0]);\n        yArr.push(currentPoint[1]);\n        break;\n    }\n    if (box) {\n      segment.box = box;\n      xArr.push(box.x, box.x + box.width);\n      yArr.push(box.y, box.y + box.height);\n    }\n    if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {\n      segmentsWithAngle.push(segment);\n    }\n  }\n  // bbox calculation should ignore NaN for path attribute\n  // ref: https://github.com/antvis/g/issues/210\n  // ref: https://github.com/antvis/G2/issues/3109\n  xArr = xArr.filter(function (item) {\n    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;\n  });\n  yArr = yArr.filter(function (item) {\n    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;\n  });\n  var minX = min(xArr);\n  var minY = min(yArr);\n  var maxX = max(xArr);\n  var maxY = max(yArr);\n  if (segmentsWithAngle.length === 0) {\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n  for (var i = 0; i < segmentsWithAngle.length; i++) {\n    var segment = segmentsWithAngle[i];\n    var currentPoint = segment.currentPoint;\n    var extra = void 0;\n    if (currentPoint[0] === minX) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      minX = minX - extra.xExtra;\n    } else if (currentPoint[0] === maxX) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      maxX = maxX + extra.xExtra;\n    }\n    if (currentPoint[1] === minY) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      minY = minY - extra.yExtra;\n    } else if (currentPoint[1] === maxY) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      maxY = maxY + extra.yExtra;\n    }\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getExtraFromSegmentWithAngle(segment, lineWidth) {\n  var prePoint = segment.prePoint,\n    currentPoint = segment.currentPoint,\n    nextPoint = segment.nextPoint;\n  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\n  // 以 currentPoint 为顶点的夹角\n  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));\n  // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n  // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {\n    return {\n      xExtra: 0,\n      yExtra: 0\n    };\n  }\n  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\n  // 将夹角转为锐角\n  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\n  // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n  // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n  var extra = {\n    // 水平方向投影\n    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n    // 垂直方向投影\n    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0\n  };\n  return extra;\n}\nexport default function (shape) {\n  var attrs = shape.attr();\n  var path = attrs.path,\n    stroke = attrs.stroke;\n  var lineWidth = stroke ? attrs.lineWidth : 0; // 只有有 stroke 时，lineWidth 才生效\n  var segments = shape.get('segments') || path2Segments(path);\n  var _a = getPathBox(segments, lineWidth),\n    x = _a.x,\n    y = _a.y,\n    width = _a.width,\n    height = _a.height;\n  var bbox = {\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height\n  };\n  bbox = mergeArrowBBox(shape, bbox);\n  return {\n    x: bbox.minX,\n    y: bbox.minY,\n    width: bbox.maxX - bbox.minX,\n    height: bbox.maxY - bbox.minY\n  };\n}","map":null,"metadata":{},"sourceType":"module"}