{"ast":null,"code":"import { nelderMead } from 'fmin';\nimport { distance, getCenter, intersectionArea } from './circleintersection';\nfunction circleMargin(current, interior, exterior) {\n  var margin = interior[0].radius - distance(interior[0], current),\n    i,\n    m;\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  for (i = 0; i < exterior.length; ++i) {\n    m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  var points = [];\n  var i;\n  for (i = 0; i < interior.length; ++i) {\n    var c = interior[i];\n    points.push({\n      x: c.x,\n      y: c.y\n    });\n    points.push({\n      x: c.x + c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x - c.radius / 2,\n      y: c.y\n    });\n    points.push({\n      x: c.x,\n      y: c.y + c.radius / 2\n    });\n    points.push({\n      x: c.x,\n      y: c.y - c.radius / 2\n    });\n  }\n  var initial = points[0],\n    margin = circleMargin(points[0], interior, exterior);\n  for (i = 1; i < points.length; ++i) {\n    var m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n  // maximize the margin numerically\n  var solution = nelderMead(function (p) {\n    return -1 * circleMargin({\n      x: p[0],\n      y: p[1]\n    }, interior, exterior);\n  }, [initial.x, initial.y], {\n    maxIterations: 500,\n    minErrorDelta: 1e-10\n  }).x;\n  var ret = {\n    x: solution[0],\n    y: solution[1]\n  };\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  var valid = true;\n  for (i = 0; i < interior.length; ++i) {\n    if (distance(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n  for (i = 0; i < exterior.length; ++i) {\n    if (distance(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (!valid) {\n    if (interior.length == 1) {\n      ret = {\n        x: interior[0].x,\n        y: interior[0].y\n      };\n    } else {\n      var areaStats = {};\n      intersectionArea(interior, areaStats);\n      if (areaStats.arcs.length === 0) {\n        ret = {\n          x: 0,\n          y: -1000,\n          disjoint: true\n        };\n      } else if (areaStats.arcs.length == 1) {\n        ret = {\n          x: areaStats.arcs[0].circle.x,\n          y: areaStats.arcs[0].circle.y\n        };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCentre(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(areaStats.arcs.map(function (a) {\n          return a.p1;\n        }));\n      }\n    }\n  }\n  return ret;\n}\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  var ret = {},\n    circleids = [];\n  for (var circleid in circles) {\n    circleids.push(circleid);\n    ret[circleid] = [];\n  }\n  for (var i = 0; i < circleids.length; i++) {\n    var a = circles[circleids[i]];\n    for (var j = i + 1; j < circleids.length; ++j) {\n      var b = circles[circleids[j]],\n        d = distance(a, b);\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleids[j]].push(circleids[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleids[i]].push(circleids[j]);\n      }\n    }\n  }\n  return ret;\n}\nexport function computeTextCentres(circles, areas) {\n  var ret = {},\n    overlapped = getOverlappingCircles(circles);\n  for (var i = 0; i < areas.length; ++i) {\n    var area = areas[i].sets,\n      areaids = {},\n      exclude = {};\n    for (var j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      var overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (var k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n    var interior = [],\n      exterior = [];\n    for (var setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    var centre = computeTextCentre(interior, exterior);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n/**\n * 根据圆心(x, y) 半径 r 返回圆的绘制 path\n * @param x 圆心点 x\n * @param y 圆心点 y\n * @param r 圆的半径\n * @returns 圆的 path\n */\nexport function circlePath(x, y, r) {\n  var ret = [];\n  // ret.push('\\nM', x, y);\n  // ret.push('\\nm', -r, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  // ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  var x0 = x - r;\n  var y0 = y;\n  ret.push('M', x0, y0);\n  ret.push('A', r, r, 0, 1, 0, x0 + 2 * r, y0);\n  ret.push('A', r, r, 0, 1, 0, x0, y0);\n  return ret.join(' ');\n}\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n  var tokens = path.split(' ');\n  return {\n    x: parseFloat(tokens[1]),\n    y: parseFloat(tokens[2]),\n    radius: -parseFloat(tokens[4])\n  };\n}\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n  var stats = {};\n  intersectionArea(circles, stats);\n  var arcs = stats.arcs;\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  } else if (arcs.length == 1) {\n    var circle = arcs[0].circle;\n    return circlePath(circle.x, circle.y, circle.radius);\n  } else {\n    // draw path around arcs\n    var ret = ['\\nM', arcs[0].p2.x, arcs[0].p2.y];\n    for (var i = 0; i < arcs.length; ++i) {\n      var arc = arcs[i],\n        r = arc.circle.radius,\n        wide = arc.width > r;\n      ret.push('\\nA', r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n    }\n    return ret.join(' ');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}