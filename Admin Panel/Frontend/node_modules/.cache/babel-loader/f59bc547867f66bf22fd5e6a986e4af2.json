{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { get, deepMix, isArray } from '@antv/util';\nimport GeometryLabel from './base';\n/**\n * 柱状图 label\n */\nvar IntervalLabel = /** @class */function (_super) {\n  __extends(IntervalLabel, _super);\n  function IntervalLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * 获取 interval label 的方向，取决于 value 的值是正还是负\n   * @param labelCfg\n   */\n  IntervalLabel.prototype.getLabelValueDir = function (mappingData) {\n    // points 中的 x/y 和 transpose 无关\n    var dim = 'y';\n    var points = mappingData.points;\n    return points[0][dim] <= points[2][dim] ? 1 : -1;\n  };\n  /**\n   * 重载：根据 interval 值的正负来调整 label 偏移量\n   * @param labelCfg\n   * @param index\n   * @param total\n   */\n  IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total, position) {\n    var _a;\n    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var dir = this.getLabelValueDir(labelCfg.mappingData);\n    point = __assign(__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));\n    if (coordinate.isReflect('x')) {\n      point = __assign(__assign({}, point), {\n        x: point.x * -1\n      });\n    }\n    if (coordinate.isReflect('y')) {\n      point = __assign(__assign({}, point), {\n        y: point.y * -1\n      });\n    }\n    return point;\n  };\n  /**\n   * 重载：定制 interval label 的默认主题配置\n   * @param labelCfg\n   */\n  IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var theme = geometry.theme;\n    // 如果 interval label position 设置为 middle，则将主题中的 offset 覆盖为 0\n    return deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {\n      offset: 0\n    } : {}, labelCfg);\n  };\n  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var shapePoints = mappingData.points;\n    var point0 = coordinate.convert(shapePoints[0]);\n    var point2 = coordinate.convert(shapePoints[2]);\n    var dir = this.getLabelValueDir(mappingData);\n    var top;\n    var right;\n    var bottom;\n    var left;\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    if (shape === 'funnel' || shape === 'pyramid') {\n      // 处理漏斗图\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        var p0 = coordinate.convert(points[0]);\n        var p1 = coordinate.convert(points[1]);\n        var nextP0 = coordinate.convert(nextPoints[0]);\n        var nextP1 = coordinate.convert(nextPoints[1]);\n        // TODO: 使用包围盒的计算方法\n        if (transposed) {\n          top = Math.min(nextP0.y, p0.y);\n          bottom = Math.max(nextP0.y, p0.y);\n          right = (p1.x + nextP1.x) / 2;\n          left = (p0.x + nextP0.x) / 2;\n        } else {\n          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);\n          right = nextP1.x;\n          left = p0.x;\n        }\n      } else {\n        top = Math.min(point2.y, point0.y);\n        bottom = Math.max(point2.y, point0.y);\n        right = point2.x;\n        left = point0.x;\n      }\n    } else {\n      top = Math.min(point2.y, point0.y);\n      bottom = Math.max(point2.y, point0.y);\n      right = point2.x;\n      left = point0.x;\n    }\n    switch (position) {\n      case 'right':\n        labelPointCfg.x = right;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'left':\n        labelPointCfg.x = left;\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');\n        break;\n      case 'bottom':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = bottom;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      case 'middle':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = (top + bottom) / 2;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', 'middle');\n        break;\n      case 'top':\n        if (transposed) {\n          labelPointCfg.x = (right + left) / 2;\n        }\n        labelPointCfg.y = top;\n        labelPointCfg.textAlign = get(labelPointCfg, 'textAlign', 'center');\n        labelPointCfg.textBaseline = get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');\n        break;\n      default:\n        break;\n    }\n  };\n  return IntervalLabel;\n}(GeometryLabel);\nexport default IntervalLabel;","map":null,"metadata":{},"sourceType":"module"}