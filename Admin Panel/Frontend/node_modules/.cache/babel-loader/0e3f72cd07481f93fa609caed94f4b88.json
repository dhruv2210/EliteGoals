{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { get, keys } from '@antv/util';\nimport { animation as commonAnimation, interaction as commonInteraction, limitInPlot as commonLimitInPlot, scale, theme as commonTheme, tooltip } from '../../adaptor/common';\nimport { interval } from '../../adaptor/geometries';\nimport { deepAssign, findGeometry, findViewById, flow, transformLabel } from '../../utils';\nimport { FIRST_AXES_VIEW, SECOND_AXES_VIEW, SERIES_FIELD_KEY } from './constant';\nimport { isHorizontal, transformData } from './utils';\n/**\n * geometry 处理\n * @param params\n */\nfunction geometry(params) {\n  var chart = params.chart,\n    options = params.options;\n  var data = options.data,\n    xField = options.xField,\n    yField = options.yField,\n    color = options.color,\n    barStyle = options.barStyle,\n    widthRatio = options.widthRatio,\n    legend = options.legend,\n    layout = options.layout;\n  // 处理数据\n  var groupData = transformData(xField, yField, SERIES_FIELD_KEY, data, isHorizontal(layout));\n  // 在创建子 view 执行后不行，需要在前面处理 legend\n  if (legend) {\n    chart.legend(SERIES_FIELD_KEY, legend);\n  } else if (legend === false) {\n    chart.legend(false);\n  }\n  // 创建 view\n  var firstView;\n  var secondView;\n  var firstViewData = groupData[0],\n    secondViewData = groupData[1];\n  // 横向\n  if (isHorizontal(layout)) {\n    firstView = chart.createView({\n      region: {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 0.5,\n          y: 1\n        }\n      },\n      id: FIRST_AXES_VIEW\n    });\n    firstView.coordinate().transpose().reflect('x');\n    secondView = chart.createView({\n      region: {\n        start: {\n          x: 0.5,\n          y: 0\n        },\n        end: {\n          x: 1,\n          y: 1\n        }\n      },\n      id: SECOND_AXES_VIEW\n    });\n    secondView.coordinate().transpose();\n    // @说明: 测试发现，横向因为轴的反转，需要数据也反转，不然会图形渲染是反的(翻转操作进入到 transform 中处理)\n    firstView.data(firstViewData);\n    secondView.data(secondViewData);\n  } else {\n    // 纵向\n    firstView = chart.createView({\n      region: {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 1,\n          y: 0.5\n        }\n      },\n      id: FIRST_AXES_VIEW\n    });\n    secondView = chart.createView({\n      region: {\n        start: {\n          x: 0,\n          y: 0.5\n        },\n        end: {\n          x: 1,\n          y: 1\n        }\n      },\n      id: SECOND_AXES_VIEW\n    });\n    secondView.coordinate().reflect('y');\n    firstView.data(firstViewData);\n    secondView.data(secondViewData);\n  }\n  var left = deepAssign({}, params, {\n    chart: firstView,\n    options: {\n      widthRatio: widthRatio,\n      xField: xField,\n      yField: yField[0],\n      seriesField: SERIES_FIELD_KEY,\n      interval: {\n        color: color,\n        style: barStyle\n      }\n    }\n  });\n  interval(left);\n  var right = deepAssign({}, params, {\n    chart: secondView,\n    options: {\n      xField: xField,\n      yField: yField[1],\n      seriesField: SERIES_FIELD_KEY,\n      widthRatio: widthRatio,\n      interval: {\n        color: color,\n        style: barStyle\n      }\n    }\n  });\n  interval(right);\n  return params;\n}\n/**\n * meta 配置\n * - 对称条形图对数据进行了处理，通过 SERIES_FIELD_KEY 来对两条 yField 数据进行分类\n * @param params\n */\nfunction meta(params) {\n  var _a, _b, _c;\n  var options = params.options,\n    chart = params.chart;\n  var xAxis = options.xAxis,\n    yAxis = options.yAxis,\n    xField = options.xField,\n    yField = options.yField;\n  var firstView = findViewById(chart, FIRST_AXES_VIEW);\n  var secondView = findViewById(chart, SECOND_AXES_VIEW);\n  var aliasMap = {};\n  keys((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function (metaKey) {\n    if (get(options === null || options === void 0 ? void 0 : options.meta, [metaKey, 'alias'])) {\n      aliasMap[metaKey] = options.meta[metaKey].alias;\n    }\n  });\n  chart.scale((_a = {}, _a[SERIES_FIELD_KEY] = {\n    sync: true,\n    formatter: function formatter(v) {\n      return get(aliasMap, v, v);\n    }\n  }, _a));\n  scale((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))(deepAssign({}, params, {\n    chart: firstView\n  }));\n  scale((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))(deepAssign({}, params, {\n    chart: secondView\n  }));\n  return params;\n}\n/**\n * axis 配置\n * @param params\n */\nfunction axis(params) {\n  var chart = params.chart,\n    options = params.options;\n  var xAxis = options.xAxis,\n    yAxis = options.yAxis,\n    xField = options.xField,\n    yField = options.yField,\n    layout = options.layout;\n  var firstView = findViewById(chart, FIRST_AXES_VIEW);\n  var secondView = findViewById(chart, SECOND_AXES_VIEW);\n  // 第二个 view axis 始终隐藏; 注意 bottom 的时候，只隐藏 label，其他共用配置\n  // @ts-ignore\n  if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === 'bottom') {\n    // fixme 直接设置 label: null 会导致 tickLine 无法显示\n    secondView.axis(xField, __assign(__assign({}, xAxis), {\n      label: {\n        formatter: function formatter() {\n          return '';\n        }\n      }\n    }));\n  } else {\n    secondView.axis(xField, false);\n  }\n  // 为 false 则是不显示 firstView 轴\n  if (xAxis === false) {\n    firstView.axis(xField, false);\n  } else {\n    firstView.axis(xField, __assign({\n      // 不同布局 firstView 的坐标轴显示位置\n      position: isHorizontal(layout) ? 'top' : 'bottom'\n    }, xAxis));\n  }\n  if (yAxis === false) {\n    firstView.axis(yField[0], false);\n    secondView.axis(yField[1], false);\n  } else {\n    firstView.axis(yField[0], yAxis[yField[0]]);\n    secondView.axis(yField[1], yAxis[yField[1]]);\n  }\n  /**\n   *  这个注入，主要是在syncViewPadding时候拿到相对应的配置：布局和轴的位置\n   *  TODO 之后希望 g2 View 对象可以开放 setter 可以设置一些需要的东西\n   */\n  //@ts-ignore\n  chart.__axisPosition = {\n    position: firstView.getOptions().axes[xField].position,\n    layout: layout\n  };\n  return params;\n}\n/**\n * interaction 配置\n * @param params\n */\nexport function interaction(params) {\n  var chart = params.chart;\n  commonInteraction(deepAssign({}, params, {\n    chart: findViewById(chart, FIRST_AXES_VIEW)\n  }));\n  commonInteraction(deepAssign({}, params, {\n    chart: findViewById(chart, SECOND_AXES_VIEW)\n  }));\n  return params;\n}\n/**\n * limitInPlot\n * @param params\n */\nexport function limitInPlot(params) {\n  var chart = params.chart,\n    options = params.options;\n  var yField = options.yField,\n    yAxis = options.yAxis;\n  commonLimitInPlot(deepAssign({}, params, {\n    chart: findViewById(chart, FIRST_AXES_VIEW),\n    options: {\n      yAxis: yAxis[yField[0]]\n    }\n  }));\n  commonLimitInPlot(deepAssign({}, params, {\n    chart: findViewById(chart, SECOND_AXES_VIEW),\n    options: {\n      yAxis: yAxis[yField[1]]\n    }\n  }));\n  return params;\n}\n/**\n * theme\n * @param params\n */\nexport function theme(params) {\n  var chart = params.chart;\n  commonTheme(deepAssign({}, params, {\n    chart: findViewById(chart, FIRST_AXES_VIEW)\n  }));\n  commonTheme(deepAssign({}, params, {\n    chart: findViewById(chart, SECOND_AXES_VIEW)\n  }));\n  commonTheme(params);\n  return params;\n}\n/**\n * animation\n * @param params\n */\nexport function animation(params) {\n  var chart = params.chart;\n  commonAnimation(deepAssign({}, params, {\n    chart: findViewById(chart, FIRST_AXES_VIEW)\n  }));\n  commonAnimation(deepAssign({}, params, {\n    chart: findViewById(chart, SECOND_AXES_VIEW)\n  }));\n  return params;\n}\n/**\n * label 配置 (1. 设置 offset 偏移量默认值 2. leftView 偏移量需要 *= -1)\n * @param params\n */\nfunction label(params) {\n  var _this = this;\n  var _a, _b;\n  var chart = params.chart,\n    options = params.options;\n  var label = options.label,\n    yField = options.yField,\n    layout = options.layout;\n  var firstView = findViewById(chart, FIRST_AXES_VIEW);\n  var secondView = findViewById(chart, SECOND_AXES_VIEW);\n  var leftGeometry = findGeometry(firstView, 'interval');\n  var rightGeometry = findGeometry(secondView, 'interval');\n  if (!label) {\n    leftGeometry.label(false);\n    rightGeometry.label(false);\n  } else {\n    var callback = label.callback,\n      cfg_1 = __rest(label, [\"callback\"]);\n    /** ---- 设置默认配置 ---- */\n    // 默认居中\n    if (!cfg_1.position) {\n      cfg_1.position = 'middle';\n    }\n    if (cfg_1.offset === undefined) {\n      cfg_1.offset = 2;\n    }\n    /** ---- leftView label 设置 ---- */\n    var leftLabelCfg = __assign({}, cfg_1);\n    if (isHorizontal(layout)) {\n      // 设置 textAlign 默认值\n      var textAlign = ((_a = leftLabelCfg.style) === null || _a === void 0 ? void 0 : _a.textAlign) || (cfg_1.position === 'middle' ? 'center' : 'left');\n      cfg_1.style = deepAssign({}, cfg_1.style, {\n        textAlign: textAlign\n      });\n      var textAlignMap = {\n        left: 'right',\n        right: 'left',\n        center: 'center'\n      };\n      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, {\n        textAlign: textAlignMap[textAlign]\n      });\n    } else {\n      var positionMap_1 = {\n        top: 'bottom',\n        bottom: 'top',\n        middle: 'middle'\n      };\n      if (typeof cfg_1.position === 'string') {\n        cfg_1.position = positionMap_1[cfg_1.position];\n      } else if (typeof cfg_1.position === 'function') {\n        cfg_1.position = function () {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n          return positionMap_1[cfg_1.position.apply(_this, args)];\n        };\n      }\n      // 设置 textBaseline 默认值\n      var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || 'bottom';\n      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, {\n        textBaseline: textBaseline\n      });\n      var textBaselineMap = {\n        top: 'bottom',\n        bottom: 'top',\n        middle: 'middle'\n      };\n      cfg_1.style = deepAssign({}, cfg_1.style, {\n        textBaseline: textBaselineMap[textBaseline]\n      });\n    }\n    leftGeometry.label({\n      fields: [yField[0]],\n      callback: callback,\n      cfg: transformLabel(leftLabelCfg)\n    });\n    rightGeometry.label({\n      fields: [yField[1]],\n      callback: callback,\n      cfg: transformLabel(cfg_1)\n    });\n  }\n  return params;\n}\n/**\n * 对称条形图适配器\n * @param chart\n * @param options\n */\nexport function adaptor(params) {\n  // flow 的方式处理所有的配置到 G2 API\n  return flow(geometry, meta, axis, limitInPlot, theme, label, tooltip, interaction, animation)(params);\n}","map":null,"metadata":{},"sourceType":"module"}