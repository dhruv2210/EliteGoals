{"ast":null,"code":"import { __assign, __extends, __values } from \"tslib\";\n/**\n * Create By Bruce Too\n * On 2020-02-10\n */\nimport { assign, deepMix, each, get } from '@antv/util';\nimport { DIRECTION, VIEW_LIFE_CIRCLE } from '../constant';\nimport { getFactTitleConfig } from '../util/facet';\nimport { Facet } from './facet';\n/**\n * @ignore\n * Tree Facet\n */\nvar Tree = /** @class */function (_super) {\n  __extends(Tree, _super);\n  function Tree() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.afterChartRender = function () {\n      if (_this.facets && _this.cfg.line) {\n        _this.container.clear();\n        _this.drawLines(_this.facets);\n      }\n    };\n    return _this;\n  }\n  Tree.prototype.afterEachView = function (view, facet) {\n    this.processAxis(view, facet);\n  };\n  Tree.prototype.beforeEachView = function (view, facet) {};\n  Tree.prototype.init = function () {\n    _super.prototype.init.call(this);\n    this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);\n  };\n  Tree.prototype.getDefaultCfg = function () {\n    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {\n      type: 'tree',\n      line: {\n        style: {\n          lineWidth: 1,\n          stroke: '#ddd'\n        },\n        smooth: false\n      },\n      showTitle: true,\n      title: _super.prototype.getDefaultTitleCfg.call(this)\n    });\n  };\n  Tree.prototype.generateFacets = function (data) {\n    var fields = this.cfg.fields;\n    if (!fields.length) {\n      throw new Error('Please specify for the fields for rootFacet!');\n    }\n    var rst = [];\n    var rootFacet = {\n      type: this.cfg.type,\n      data: data,\n      region: null,\n      rowValuesLength: this.getRows(),\n      columnValuesLength: 1,\n      rowIndex: 0,\n      columnIndex: 0,\n      rowField: '',\n      columnField: '',\n      rowValue: '',\n      columnValue: ''\n    };\n    rst.push(rootFacet);\n    rootFacet.children = this.getChildFacets(data, 1, rst);\n    this.setRegion(rst);\n    return rst;\n  };\n  Tree.prototype.setRegion = function (facets) {\n    var _this = this;\n    this.forceColIndex(facets);\n    facets.forEach(function (facet) {\n      // @ts-ignore 允许调整\n      facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);\n    });\n  };\n  Tree.prototype.getRegion = function (rows, cols, xIndex, yIndex) {\n    var xWidth = 1 / cols; // x轴方向的每个分面的偏移\n    var yWidth = 1 / rows; // y轴方向的每个分面的偏移\n    var start = {\n      x: xWidth * xIndex,\n      y: yWidth * yIndex\n    };\n    var end = {\n      x: start.x + xWidth,\n      y: start.y + yWidth * 2 / 3 // 预留1/3的空隙，方便添加连接线\n    };\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n  Tree.prototype.forceColIndex = function (facets) {\n    var e_1, _a;\n    var _this = this;\n    var leafs = [];\n    var index = 0;\n    facets.forEach(function (facet) {\n      if (_this.isLeaf(facet)) {\n        leafs.push(facet);\n        // @ts-ignore 允许调整\n        facet.columnIndex = index;\n        index++;\n      }\n    });\n    leafs.forEach(function (facet) {\n      // @ts-ignore\n      facet.columnValuesLength = leafs.length;\n    });\n    var maxLevel = this.cfg.fields.length;\n    for (var i = maxLevel - 1; i >= 0; i--) {\n      var levelFacets = this.getFacetsByLevel(facets, i);\n      try {\n        // var yIndex = maxLevel - i;\n        for (var levelFacets_1 = (e_1 = void 0, __values(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {\n          var facet = levelFacets_1_1.value;\n          if (!this.isLeaf(facet)) {\n            facet.originColIndex = facet.columnIndex;\n            // @ts-ignore\n            facet.columnIndex = this.getRegionIndex(facet.children);\n            // @ts-ignore\n            facet.columnValuesLength = leafs.length;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (levelFacets_1_1 && !levelFacets_1_1.done && (_a = levelFacets_1.return)) _a.call(levelFacets_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n  };\n  // get facet use level\n  Tree.prototype.getFacetsByLevel = function (facets, level) {\n    var rst = [];\n    facets.forEach(function (facet) {\n      if (facet.rowIndex === level) {\n        rst.push(facet);\n      }\n    });\n    return rst;\n  };\n  // if the facet has children , make it's column index in the middle of it's children\n  Tree.prototype.getRegionIndex = function (children) {\n    var first = children[0];\n    var last = children[children.length - 1];\n    return (last.columnIndex - first.columnIndex) / 2 + first.columnIndex;\n  };\n  // is  a leaf without children\n  Tree.prototype.isLeaf = function (facet) {\n    return !facet.children || !facet.children.length;\n  };\n  Tree.prototype.getRows = function () {\n    return this.cfg.fields.length + 1;\n  };\n  // get child\n  Tree.prototype.getChildFacets = function (data, level, arr) {\n    var _this = this;\n    // [ 'grade', 'class' ]\n    var fields = this.cfg.fields;\n    var length = fields.length;\n    if (length < level) {\n      return;\n    }\n    var rst = [];\n    // get fist level except root node\n    var field = fields[level - 1];\n    // get field value\n    var values = this.getFieldValues(data, field);\n    values.forEach(function (value, index) {\n      var conditions = [{\n        field: field,\n        value: value,\n        values: values\n      }];\n      var subData = data.filter(_this.getFacetDataFilter(conditions));\n      if (subData.length) {\n        var facet = {\n          type: _this.cfg.type,\n          data: subData,\n          region: null,\n          columnValue: value,\n          rowValue: '',\n          columnField: field,\n          rowField: '',\n          columnIndex: index,\n          rowValuesLength: _this.getRows(),\n          columnValuesLength: 1,\n          rowIndex: level,\n          children: _this.getChildFacets(subData, level + 1, arr)\n        };\n        rst.push(facet);\n        arr.push(facet);\n      }\n    });\n    return rst;\n  };\n  Tree.prototype.render = function () {\n    _super.prototype.render.call(this);\n    if (this.cfg.showTitle) {\n      this.renderTitle();\n    }\n  };\n  Tree.prototype.renderTitle = function () {\n    var _this = this;\n    each(this.facets, function (facet) {\n      var columnValue = facet.columnValue,\n        view = facet.view;\n      var formatter = get(_this.cfg.title, 'formatter');\n      var config = deepMix({\n        position: ['50%', '0%'],\n        content: formatter ? formatter(columnValue) : columnValue\n      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);\n      view.annotation().text(config);\n    });\n  };\n  Tree.prototype.drawLines = function (facets) {\n    var _this = this;\n    facets.forEach(function (facet) {\n      if (!_this.isLeaf(facet)) {\n        var children = facet.children;\n        _this.addFacetLines(facet, children);\n      }\n    });\n  };\n  // add lines with it's children\n  Tree.prototype.addFacetLines = function (facet, children) {\n    var _this = this;\n    var view = facet.view;\n    var region = view.coordinateBBox;\n    // top, right, bottom, left\n    var start = {\n      x: region.x + region.width / 2,\n      y: region.y + region.height\n    };\n    children.forEach(function (subFacet) {\n      var subRegion = subFacet.view.coordinateBBox;\n      var end = {\n        x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,\n        y: subRegion.tr.y\n      };\n      var middle1 = {\n        x: start.x,\n        y: start.y + (end.y - start.y) / 2\n      };\n      var middle2 = {\n        x: end.x,\n        y: middle1.y\n      };\n      _this.drawLine([start, middle1, middle2, end]);\n    });\n  };\n  Tree.prototype.getPath = function (points) {\n    var path = [];\n    var smooth = this.cfg.line.smooth;\n    if (smooth) {\n      path.push(['M', points[0].x, points[0].y]);\n      path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    } else {\n      points.forEach(function (point, index) {\n        if (index === 0) {\n          path.push(['M', point.x, point.y]);\n        } else {\n          path.push(['L', point.x, point.y]);\n        }\n      });\n    }\n    return path;\n  };\n  // draw line width points\n  Tree.prototype.drawLine = function (points) {\n    var path = this.getPath(points);\n    var line = this.cfg.line.style;\n    this.container.addShape('path', {\n      attrs: assign({\n        // @ts-ignore\n        path: path\n      }, line)\n    });\n  };\n  Tree.prototype.getXAxisOption = function (x, axes, option, facet) {\n    if (facet.rowIndex !== facet.rowValuesLength - 1) {\n      return __assign(__assign({}, option), {\n        title: null,\n        label: null\n      });\n    }\n    return option;\n  };\n  Tree.prototype.getYAxisOption = function (y, axes, option, facet) {\n    if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {\n      return __assign(__assign({}, option), {\n        title: null,\n        label: null\n      });\n    }\n    return option;\n  };\n  return Tree;\n}(Facet);\nexport default Tree;","map":null,"metadata":{},"sourceType":"module"}