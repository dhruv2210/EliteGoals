{"ast":null,"code":"var TAU = Math.PI * 2;\nvar mapToEllipse = function mapToEllipse(_a, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _a.x,\n    y = _a.y;\n  x *= rx;\n  y *= ry;\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  return [centerx, centery, ang1, ang2];\n};\nvar arcToBezier = function arcToBezier(_a) {\n  var px = _a.px,\n    py = _a.py,\n    cx = _a.cx,\n    cy = _a.cy,\n    rx = _a.rx,\n    ry = _a.ry,\n    _b = _a.xAxisRotation,\n    xAxisRotation = _b === void 0 ? 0 : _b,\n    _c = _a.largeArcFlag,\n    largeArcFlag = _c === void 0 ? 0 : _c,\n    _d = _a.sweepFlag,\n    sweepFlag = _d === void 0 ? 0 : _d;\n  var curves = [];\n  if (rx === 0 || ry === 0) {\n    return [{\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      x: cx,\n      y: cy\n    }];\n  }\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return [{\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      x: cx,\n      y: cy\n    }];\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  var _e = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n    centerx = _e[0],\n    centery = _e[1],\n    ang1 = _e[2],\n    ang2 = _e[3];\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n  var segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n  return curves.map(function (curve) {\n    var _a = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n      x1 = _a.x,\n      y1 = _a.y;\n    var _b = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n      x2 = _b.x,\n      y2 = _b.y;\n    var _c = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n      x = _c.x,\n      y = _c.y;\n    return {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      x: x,\n      y: y\n    };\n  });\n};\nexport function arcToCubic(x1, y1, rx, ry, angle, LAF, SF, x2, y2) {\n  var curves = arcToBezier({\n    px: x1,\n    py: y1,\n    cx: x2,\n    cy: y2,\n    rx: rx,\n    ry: ry,\n    xAxisRotation: angle,\n    largeArcFlag: LAF,\n    sweepFlag: SF\n  });\n  return curves.reduce(function (prev, cur) {\n    var x1 = cur.x1,\n      y1 = cur.y1,\n      x2 = cur.x2,\n      y2 = cur.y2,\n      x = cur.x,\n      y = cur.y;\n    prev.push(x1, y1, x2, y2, x, y);\n    return prev;\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}