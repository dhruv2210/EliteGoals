{"ast":null,"code":"import { head, indexOf, size, last } from '@antv/util';\nimport { prettyNumber } from './pretty-number';\nexport var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];\nexport var ALL_Q = [1, 5, 2, 2.5, 4, 3, 1.5, 7, 6, 8, 9];\nvar eps = Number.EPSILON * 100;\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\nfunction round(n) {\n  return Math.round(n * 1e12) / 1e12;\n}\nfunction simplicity(q, Q, j, lmin, lmax, lstep) {\n  var n = size(Q);\n  var i = indexOf(Q, q);\n  var v = 0;\n  var m = mod(lmin, lstep);\n  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {\n    v = 1;\n  }\n  return 1 - i / (n - 1) - j + v;\n}\nfunction simplicityMax(q, Q, j) {\n  var n = size(Q);\n  var i = indexOf(Q, q);\n  var v = 1;\n  return 1 - i / (n - 1) - j + v;\n}\nfunction density(k, m, dMin, dMax, lMin, lMax) {\n  var r = (k - 1) / (lMax - lMin);\n  var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));\n  return 2 - Math.max(r / rt, rt / r);\n}\nfunction densityMax(k, m) {\n  if (k >= m) {\n    return 2 - (k - 1) / (m - 1);\n  }\n  return 1;\n}\nfunction coverage(dMin, dMax, lMin, lMax) {\n  var range = dMax - dMin;\n  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);\n}\nfunction coverageMax(dMin, dMax, span) {\n  var range = dMax - dMin;\n  if (span > range) {\n    var half = (span - range) / 2;\n    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);\n  }\n  return 1;\n}\nfunction legibility() {\n  return 1;\n}\n/**\n * An Extension of Wilkinson's Algorithm for Position Tick Labels on Axes\n * https://www.yuque.com/preview/yuque/0/2019/pdf/185317/1546999150858-45c3b9c2-4e86-4223-bf1a-8a732e8195ed.pdf\n * @param dMin 最小值\n * @param dMax 最大值\n * @param m tick个数\n * @param onlyLoose 是否允许扩展min、max，不绝对强制，例如[3, 97]\n * @param Q nice numbers集合\n * @param w 四个优化组件的权重\n */\nexport default function extended(dMin, dMax, n, onlyLoose, Q, w) {\n  if (n === void 0) {\n    n = 5;\n  }\n  if (onlyLoose === void 0) {\n    onlyLoose = true;\n  }\n  if (Q === void 0) {\n    Q = DEFAULT_Q;\n  }\n  if (w === void 0) {\n    w = [0.25, 0.2, 0.5, 0.05];\n  }\n  // 处理小于 0 和小数的 tickCount\n  var m = n < 0 ? 0 : Math.round(n);\n  // nan 也会导致异常\n  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== 'number' || typeof dMax !== 'number' || !m) {\n    return {\n      min: 0,\n      max: 0,\n      ticks: []\n    };\n  }\n  // js 极大值极小值问题，差值小于 1e-15 会导致计算出错\n  if (dMax - dMin < 1e-15 || m === 1) {\n    return {\n      min: dMin,\n      max: dMax,\n      ticks: [dMin]\n    };\n  }\n  // js 超大值问题\n  if (dMax - dMin > 1e148) {\n    var count = n || 5;\n    var step_1 = (dMax - dMin) / count;\n    return {\n      min: dMin,\n      max: dMax,\n      ticks: Array(count).fill(null).map(function (_, idx) {\n        return prettyNumber(dMin + step_1 * idx);\n      })\n    };\n  }\n  var best = {\n    score: -2,\n    lmin: 0,\n    lmax: 0,\n    lstep: 0\n  };\n  var j = 1;\n  while (j < Infinity) {\n    for (var i = 0; i < Q.length; i += 1) {\n      var q = Q[i];\n      var sm = simplicityMax(q, Q, j);\n      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {\n        j = Infinity;\n        break;\n      }\n      var k = 2;\n      while (k < Infinity) {\n        var dm = densityMax(k, m);\n        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {\n          break;\n        }\n        var delta = (dMax - dMin) / (k + 1) / j / q;\n        var z = Math.ceil(Math.log10(delta));\n        while (z < Infinity) {\n          var step = j * q * Math.pow(10, z);\n          var cm = coverageMax(dMin, dMax, step * (k - 1));\n          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {\n            break;\n          }\n          var minStart = Math.floor(dMax / step) * j - (k - 1) * j;\n          var maxStart = Math.ceil(dMin / step) * j;\n          if (minStart <= maxStart) {\n            var count = maxStart - minStart;\n            for (var i_1 = 0; i_1 <= count; i_1 += 1) {\n              var start = minStart + i_1;\n              var lMin = start * (step / j);\n              var lMax = lMin + step * (k - 1);\n              var lStep = step;\n              var s = simplicity(q, Q, j, lMin, lMax, lStep);\n              var c = coverage(dMin, dMax, lMin, lMax);\n              var g = density(k, m, dMin, dMax, lMin, lMax);\n              var l = legibility();\n              var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;\n              if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {\n                best.lmin = lMin;\n                best.lmax = lMax;\n                best.lstep = lStep;\n                best.score = score;\n              }\n            }\n          }\n          z += 1;\n        }\n        k += 1;\n      }\n    }\n    j += 1;\n  }\n  // 处理精度问题，保证这三个数没有精度问题\n  var lmax = prettyNumber(best.lmax);\n  var lmin = prettyNumber(best.lmin);\n  var lstep = prettyNumber(best.lstep);\n  // 加 round 是为处理 extended(0.94, 1, 5)\n  // 保证生成的 tickCount 没有精度问题\n  var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;\n  var ticks = new Array(tickCount);\n  // 少用乘法：防止出现 -1.2 + 1.2 * 3 = 2.3999999999999995 的情况\n  ticks[0] = prettyNumber(lmin);\n  for (var i = 1; i < tickCount; i++) {\n    ticks[i] = prettyNumber(ticks[i - 1] + lstep);\n  }\n  return {\n    min: Math.min(dMin, head(ticks)),\n    max: Math.max(dMax, last(ticks)),\n    ticks: ticks\n  };\n}","map":null,"metadata":{},"sourceType":"module"}