{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { addEventListener } from '@antv/dom-util';\nimport { clamp, deepMix, get, noop } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nvar DEFAULT_STYLE = {\n  trackColor: 'rgba(0,0,0,0)',\n  thumbColor: 'rgba(0,0,0,0.15)',\n  size: 8,\n  lineCap: 'round'\n};\nexport var DEFAULT_THEME = {\n  // 默认样式\n  default: DEFAULT_STYLE,\n  // 鼠标 hover 的样式\n  hover: {\n    thumbColor: 'rgba(0,0,0,0.2)'\n  }\n};\nvar Scrollbar = /** @class */function (_super) {\n  __extends(Scrollbar, _super);\n  function Scrollbar() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.clearEvents = noop;\n    _this.onStartEvent = function (isMobile) {\n      return function (e) {\n        _this.isMobile = isMobile;\n        e.originalEvent.preventDefault();\n        var clientX = isMobile ? get(e.originalEvent, 'touches.0.clientX') : e.clientX;\n        var clientY = isMobile ? get(e.originalEvent, 'touches.0.clientY') : e.clientY;\n        // 将开始的点记录下来\n        _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;\n        _this.bindLaterEvent();\n      };\n    };\n    _this.bindLaterEvent = function () {\n      var containerDOM = _this.getContainerDOM();\n      var events = [];\n      if (_this.isMobile) {\n        events = [addEventListener(containerDOM, 'touchmove', _this.onMouseMove), addEventListener(containerDOM, 'touchend', _this.onMouseUp), addEventListener(containerDOM, 'touchcancel', _this.onMouseUp)];\n      } else {\n        events = [addEventListener(containerDOM, 'mousemove', _this.onMouseMove), addEventListener(containerDOM, 'mouseup', _this.onMouseUp),\n        // 为了保证划出 canvas containerDom 时还没触发 mouseup\n        addEventListener(containerDOM, 'mouseleave', _this.onMouseUp)];\n      }\n      _this.clearEvents = function () {\n        events.forEach(function (e) {\n          e.remove();\n        });\n      };\n    };\n    // 拖拽滑块的事件回调\n    // 这里是 dom 原生事件，绑定在 dom 元素上的\n    _this.onMouseMove = function (e) {\n      var _a = _this.cfg,\n        isHorizontal = _a.isHorizontal,\n        thumbOffset = _a.thumbOffset;\n      e.preventDefault();\n      var clientX = _this.isMobile ? get(e, 'touches.0.clientX') : e.clientX;\n      var clientY = _this.isMobile ? get(e, 'touches.0.clientY') : e.clientY;\n      // 鼠标松开的位置\n      var endPos = isHorizontal ? clientX : clientY;\n      // 滑块需要移动的距离, 由于这里是对滑块监听，所以移动的距离就是 diffDis, 如果监听对象是 container dom，则需要算比例\n      var diff = endPos - _this.startPos;\n      // 更新 _startPos\n      _this.startPos = endPos;\n      _this.updateThumbOffset(thumbOffset + diff);\n    };\n    _this.onMouseUp = function (e) {\n      e.preventDefault();\n      _this.clearEvents();\n    };\n    // 点击滑道的事件回调,移动滑块位置\n    _this.onTrackClick = function (e) {\n      var _a = _this.cfg,\n        isHorizontal = _a.isHorizontal,\n        x = _a.x,\n        y = _a.y,\n        thumbLen = _a.thumbLen;\n      var containerDOM = _this.getContainerDOM();\n      var rect = containerDOM.getBoundingClientRect();\n      var clientX = e.clientX,\n        clientY = e.clientY;\n      var offset = isHorizontal ? clientX - rect.left - x - thumbLen / 2 : clientY - rect.top - y - thumbLen / 2;\n      var newOffset = _this.validateRange(offset);\n      _this.updateThumbOffset(newOffset);\n    };\n    _this.onThumbMouseOver = function () {\n      var thumbColor = _this.cfg.theme.hover.thumbColor;\n      _this.getElementByLocalId('thumb').attr('stroke', thumbColor);\n      _this.draw();\n    };\n    _this.onThumbMouseOut = function () {\n      var thumbColor = _this.cfg.theme.default.thumbColor;\n      _this.getElementByLocalId('thumb').attr('stroke', thumbColor);\n      _this.draw();\n    };\n    return _this;\n  }\n  Scrollbar.prototype.setRange = function (min, max) {\n    this.set('minLimit', min);\n    this.set('maxLimit', max);\n    var curValue = this.getValue();\n    var newValue = clamp(curValue, min, max);\n    if (curValue !== newValue && !this.get('isInit')) {\n      this.setValue(newValue);\n    }\n  };\n  Scrollbar.prototype.getRange = function () {\n    var min = this.get('minLimit') || 0;\n    var max = this.get('maxLimit') || 1;\n    return {\n      min: min,\n      max: max\n    };\n  };\n  Scrollbar.prototype.setValue = function (value) {\n    var range = this.getRange();\n    var originalValue = this.getValue();\n    this.update({\n      thumbOffset: (this.get('trackLen') - this.get('thumbLen')) * clamp(value, range.min, range.max)\n    });\n    this.delegateEmit('valuechange', {\n      originalValue: originalValue,\n      value: this.getValue()\n    });\n  };\n  Scrollbar.prototype.getValue = function () {\n    return clamp(this.get('thumbOffset') / (this.get('trackLen') - this.get('thumbLen')), 0, 1);\n  };\n  Scrollbar.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      name: 'scrollbar',\n      isHorizontal: true,\n      minThumbLen: 20,\n      thumbOffset: 0,\n      theme: DEFAULT_THEME\n    });\n  };\n  Scrollbar.prototype.renderInner = function (group) {\n    this.renderTrackShape(group);\n    this.renderThumbShape(group);\n  };\n  Scrollbar.prototype.applyOffset = function () {\n    this.moveElementTo(this.get('group'), {\n      x: this.get('x'),\n      y: this.get('y')\n    });\n  };\n  Scrollbar.prototype.initEvent = function () {\n    this.bindEvents();\n  };\n  // 创建滑道的 shape\n  Scrollbar.prototype.renderTrackShape = function (group) {\n    var _a = this.cfg,\n      trackLen = _a.trackLen,\n      _b = _a.theme,\n      theme = _b === void 0 ? {\n        default: {}\n      } : _b;\n    var _c = deepMix({}, DEFAULT_THEME, theme).default,\n      lineCap = _c.lineCap,\n      trackColor = _c.trackColor,\n      themeSize = _c.size;\n    var size = get(this.cfg, 'size', themeSize);\n    var attrs = this.get('isHorizontal') ? {\n      x1: 0 + size / 2,\n      y1: size / 2,\n      x2: trackLen - size / 2,\n      y2: size / 2,\n      lineWidth: size,\n      stroke: trackColor,\n      lineCap: lineCap\n    } : {\n      x1: size / 2,\n      y1: 0 + size / 2,\n      x2: size / 2,\n      y2: trackLen - size / 2,\n      lineWidth: size,\n      stroke: trackColor,\n      lineCap: lineCap\n    };\n    return this.addShape(group, {\n      id: this.getElementId('track'),\n      name: 'track',\n      type: 'line',\n      attrs: attrs\n    });\n  };\n  // 创建滑块的 shape\n  Scrollbar.prototype.renderThumbShape = function (group) {\n    var _a = this.cfg,\n      thumbOffset = _a.thumbOffset,\n      thumbLen = _a.thumbLen,\n      theme = _a.theme;\n    var _b = deepMix({}, DEFAULT_THEME, theme).default,\n      themeSize = _b.size,\n      lineCap = _b.lineCap,\n      thumbColor = _b.thumbColor;\n    var size = get(this.cfg, 'size', themeSize);\n    var attrs = this.get('isHorizontal') ? {\n      x1: thumbOffset + size / 2,\n      y1: size / 2,\n      x2: thumbOffset + thumbLen - size / 2,\n      y2: size / 2,\n      lineWidth: size,\n      stroke: thumbColor,\n      lineCap: lineCap,\n      cursor: 'default'\n    } : {\n      x1: size / 2,\n      y1: thumbOffset + size / 2,\n      x2: size / 2,\n      y2: thumbOffset + thumbLen - size / 2,\n      lineWidth: size,\n      stroke: thumbColor,\n      lineCap: lineCap,\n      cursor: 'default'\n    };\n    return this.addShape(group, {\n      id: this.getElementId('thumb'),\n      name: 'thumb',\n      type: 'line',\n      attrs: attrs\n    });\n  };\n  Scrollbar.prototype.bindEvents = function () {\n    var group = this.get('group');\n    group.on('mousedown', this.onStartEvent(false));\n    group.on('mouseup', this.onMouseUp);\n    group.on('touchstart', this.onStartEvent(true));\n    group.on('touchend', this.onMouseUp);\n    var trackShape = group.findById(this.getElementId('track'));\n    trackShape.on('click', this.onTrackClick);\n    var thumbShape = group.findById(this.getElementId('thumb'));\n    thumbShape.on('mouseover', this.onThumbMouseOver);\n    thumbShape.on('mouseout', this.onThumbMouseOut);\n  };\n  Scrollbar.prototype.getContainerDOM = function () {\n    var container = this.get('container');\n    var canvas = container && container.get('canvas');\n    return canvas && canvas.get('container');\n  };\n  Scrollbar.prototype.validateRange = function (offset) {\n    var _a = this.cfg,\n      thumbLen = _a.thumbLen,\n      trackLen = _a.trackLen;\n    var newOffset = offset;\n    if (offset + thumbLen > trackLen) {\n      newOffset = trackLen - thumbLen;\n    } else if (offset + thumbLen < thumbLen) {\n      newOffset = 0;\n    }\n    return newOffset;\n  };\n  Scrollbar.prototype.draw = function () {\n    var container = this.get('container');\n    var canvas = container && container.get('canvas');\n    if (canvas) {\n      canvas.draw();\n    }\n  };\n  Scrollbar.prototype.updateThumbOffset = function (offset) {\n    var _a = this.cfg,\n      thumbOffset = _a.thumbOffset,\n      isHorizontal = _a.isHorizontal,\n      thumbLen = _a.thumbLen,\n      size = _a.size;\n    var newOffset = this.validateRange(offset);\n    if (newOffset === thumbOffset) {\n      // 如果更新后的 offset 与原值相同，则不改变\n      return;\n    }\n    var thumbShape = this.getElementByLocalId('thumb');\n    if (isHorizontal) {\n      thumbShape.attr({\n        x1: newOffset + size / 2,\n        x2: newOffset + thumbLen - size / 2\n      });\n    } else {\n      thumbShape.attr({\n        y1: newOffset + size / 2,\n        y2: newOffset + thumbLen - size / 2\n      });\n    }\n    this.emitOffsetChange(newOffset);\n  };\n  Scrollbar.prototype.emitOffsetChange = function (offset) {\n    var _a = this.cfg,\n      originalValue = _a.thumbOffset,\n      trackLen = _a.trackLen,\n      thumbLen = _a.thumbLen;\n    this.cfg.thumbOffset = offset;\n    // 发送事件\n    this.emit('scrollchange', {\n      thumbOffset: offset,\n      ratio: clamp(offset / (trackLen - thumbLen), 0, 1)\n    });\n    this.delegateEmit('valuechange', {\n      originalValue: originalValue,\n      value: offset\n    });\n  };\n  return Scrollbar;\n}(GroupComponent);\nexport { Scrollbar };","map":null,"metadata":{},"sourceType":"module"}