{"ast":null,"code":"import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport { getEasing } from './register';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape, animation, ratio) {\n  var cProps = {}; // 此刻属性\n  var fromAttrs = animation.fromAttrs,\n    toAttrs = animation.toAttrs;\n  if (shape.destroyed) {\n    return;\n  }\n  var interf; //  差值函数\n  for (var k in toAttrs) {\n    if (!isEqual(fromAttrs[k], toAttrs[k])) {\n      if (k === 'path') {\n        var toPath = toAttrs[k];\n        var fromPath = fromAttrs[k];\n        if (toPath.length > fromPath.length) {\n          toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n        } else if (!animation.pathFormatted) {\n          toPath = PathUtil.parsePathString(toAttrs[k]);\n          fromPath = PathUtil.parsePathString(fromAttrs[k]);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n          animation.pathFormatted = true;\n        }\n        cProps[k] = [];\n        for (var i = 0; i < toPath.length; i++) {\n          var toPathPoint = toPath[i];\n          var fromPathPoint = fromPath[i];\n          var cPathPoint = [];\n          for (var j = 0; j < toPathPoint.length; j++) {\n            if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n              interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n              cPathPoint.push(interf(ratio));\n            } else {\n              cPathPoint.push(toPathPoint[j]);\n            }\n          }\n          cProps[k].push(cPathPoint);\n        }\n      } else if (k === 'matrix') {\n        /*\n         对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n         TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n         */\n        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n        var currentMatrix = matrixFn(ratio);\n        cProps[k] = currentMatrix;\n      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n        cProps[k] = toAttrs[k];\n      } else if (!isFunction(toAttrs[k])) {\n        // 非函数类型的值才能做插值\n        interf = interpolate(fromAttrs[k], toAttrs[k]);\n        cProps[k] = interf(ratio);\n      }\n    }\n  }\n  shape.attr(cProps);\n}\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape, animation, elapsed) {\n  var startTime = animation.startTime,\n    delay = animation.delay;\n  // 如果还没有开始执行或暂停，先不更新\n  if (elapsed < startTime + delay || animation._paused) {\n    return false;\n  }\n  var ratio;\n  var duration = animation.duration;\n  var easing = animation.easing;\n  var easeFn = getEasing(easing);\n  // 已执行时间\n  elapsed = elapsed - startTime - animation.delay;\n  if (animation.repeat) {\n    // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n    ratio = elapsed % duration / duration;\n    ratio = easeFn(ratio);\n  } else {\n    ratio = elapsed / duration;\n    if (ratio < 1) {\n      // 动画未执行完\n      ratio = easeFn(ratio);\n    } else {\n      // 动画已执行完\n      if (animation.onFrame) {\n        shape.attr(animation.onFrame(1));\n      } else {\n        shape.attr(animation.toAttrs);\n      }\n      return true;\n    }\n  }\n  if (animation.onFrame) {\n    var attrs = animation.onFrame(ratio);\n    shape.attr(attrs);\n  } else {\n    _update(shape, animation, ratio);\n  }\n  return false;\n}\nvar Timeline = /** @class */function () {\n  /**\n   * 时间轴构造函数，依赖于画布\n   * @param {}\n   */\n  function Timeline(canvas) {\n    /**\n     * 执行动画的元素列表\n     * @type {IElement[]}\n     */\n    this.animators = [];\n    /**\n     * 当前时间\n     * @type {number}\n     */\n    this.current = 0;\n    /**\n     * 定时器\n     * @type {d3Timer.Timer}\n     */\n    this.timer = null;\n    this.canvas = canvas;\n  }\n  /**\n   * 初始化定时器\n   */\n  Timeline.prototype.initTimer = function () {\n    var _this = this;\n    var isFinished = false;\n    var shape;\n    var animations;\n    var animation;\n    this.timer = d3Timer.timer(function (elapsed) {\n      _this.current = elapsed;\n      if (_this.animators.length > 0) {\n        for (var i = _this.animators.length - 1; i >= 0; i--) {\n          shape = _this.animators[i];\n          if (shape.destroyed) {\n            // 如果已经被销毁，直接移出队列\n            _this.removeAnimator(i);\n            continue;\n          }\n          if (!shape.isAnimatePaused()) {\n            animations = shape.get('animations');\n            for (var j = animations.length - 1; j >= 0; j--) {\n              animation = animations[j];\n              isFinished = update(shape, animation, elapsed);\n              if (isFinished) {\n                animations.splice(j, 1);\n                isFinished = false;\n                if (animation.callback) {\n                  animation.callback();\n                }\n              }\n            }\n          }\n          if (animations.length === 0) {\n            _this.removeAnimator(i);\n          }\n        }\n        var autoDraw = _this.canvas.get('autoDraw');\n        // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n        if (!autoDraw) {\n          _this.canvas.draw();\n        }\n      }\n    });\n  };\n  /**\n   * 增加动画元素\n   */\n  Timeline.prototype.addAnimator = function (shape) {\n    this.animators.push(shape);\n  };\n  /**\n   * 移除动画元素\n   */\n  Timeline.prototype.removeAnimator = function (index) {\n    this.animators.splice(index, 1);\n  };\n  /**\n   * 是否有动画在执行\n   */\n  Timeline.prototype.isAnimating = function () {\n    return !!this.animators.length;\n  };\n  /**\n   * 停止定时器\n   */\n  Timeline.prototype.stop = function () {\n    if (this.timer) {\n      this.timer.stop();\n    }\n  };\n  /**\n   * 停止时间轴上所有元素的动画，并置空动画元素列表\n   * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n   */\n  Timeline.prototype.stopAllAnimations = function (toEnd) {\n    if (toEnd === void 0) {\n      toEnd = true;\n    }\n    this.animators.forEach(function (animator) {\n      animator.stopAnimate(toEnd);\n    });\n    this.animators = [];\n    this.canvas.draw();\n  };\n  /**\n   * 获取当前时间\n   */\n  Timeline.prototype.getTime = function () {\n    return this.current;\n  };\n  return Timeline;\n}();\nexport default Timeline;","map":null,"metadata":{},"sourceType":"module"}