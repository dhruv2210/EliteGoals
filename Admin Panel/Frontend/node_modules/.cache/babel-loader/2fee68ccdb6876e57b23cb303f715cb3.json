{"ast":null,"code":"import { assign, isArray, reduce, size } from '@antv/util';\nimport * as d3Hierarchy from 'd3-hierarchy';\nimport { getAllNodes, getField } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  size: [1, 1],\n  round: false,\n  padding: 0,\n  // 默认降序\n  sort: function sort(a, b) {\n    return b.value - a.value;\n  },\n  as: ['x', 'y'],\n  // 是否忽略 parentValue, 当设置为 true 时，父节点的权重由子元素决定\n  ignoreParentValue: true\n};\nexport function partition(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n  var field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n  var partition = function partition(data) {\n    return d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(\n    /**\n     * d3Hierarchy 布局中需指定 sum 函数计算 node 值，规则是：从当前 node 开始以 post-order traversal 的次序为当前节点以及每个后代节点调用指定的 value 函数，并返回当前 node。\n     * for example:\n     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}\n     * parent 所得的计算值是 sum(node(parent)) + sum(node(child1)) + sum(node(child2))\n     * sum 函数中，d 为用户传入的 data, children 为保留字段\n     */\n    d3Hierarchy.hierarchy(data).sum(function (d) {\n      return size(d.children) ? options.ignoreParentValue ? 0 : d[field] - reduce(d.children, function (a, b) {\n        return a + b[field];\n      }, 0) : d[field];\n    }).sort(options.sort));\n  };\n  var root = partition(data);\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  var x = as[0];\n  var y = as[1];\n  root.each(function (node) {\n    var _a, _b;\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    // 旭日图兼容下 旧版本\n    node.name = node.name || ((_a = node.data) === null || _a === void 0 ? void 0 : _a.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);\n    node.data.name = node.name;\n    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n  return getAllNodes(root);\n}","map":null,"metadata":{},"sourceType":"module"}