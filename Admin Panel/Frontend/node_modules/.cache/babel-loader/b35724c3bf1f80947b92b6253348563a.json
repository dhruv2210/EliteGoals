{"ast":null,"code":"import { each, isArray } from '@antv/util';\nimport { catmullRom2bezier, getLinePath } from '../../geometry/shape/util/path';\nimport { toPoints } from '../../util/bbox';\nimport { isPolygonsIntersect } from '@antv/path-util';\nfunction getMaskBBox(context, tolerance) {\n  var event = context.event;\n  var maskShape = event.target;\n  var maskBBox = maskShape.getCanvasBBox();\n  // 如果 bbox 过小则不返回\n  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {\n    return null;\n  }\n  return maskBBox;\n}\nfunction getMaskPath(context, tolerance) {\n  var event = context.event;\n  var maskShape = event.target;\n  var maskBBox = maskShape.getCanvasBBox();\n  // 如果 bbox 过小则不返回\n  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {\n    return null;\n  }\n  return maskShape.attr('path');\n}\n/**\n * 获取当前事件相关的图表元素\n * @param context 交互的上下文\n * @ignore\n */\nexport function getCurrentElement(context) {\n  var event = context.event;\n  var element;\n  var target = event.target;\n  if (target) {\n    element = target.get('element');\n  }\n  return element;\n}\n/**\n * 获取委托对象\n * @param context 上下文\n * @ignore\n */\nexport function getDelegationObject(context) {\n  var event = context.event;\n  var target = event.target;\n  var delegateObject;\n  if (target) {\n    delegateObject = target.get('delegateObject');\n  }\n  return delegateObject;\n}\nexport function isElementChange(context) {\n  var event = context.event.gEvent;\n  // 在同一个 element 内部移动，label 和 shape 之间\n  if (event && event.fromShape && event.toShape && event.fromShape.get('element') === event.toShape.get('element')) {\n    return false;\n  }\n  return true;\n}\n/**\n * 是否是列表组件\n * @param delegateObject 委托对象\n * @ignore\n */\nexport function isList(delegateObject) {\n  return delegateObject && delegateObject.component && delegateObject.component.isList();\n}\n/**\n * 是否是滑块组件\n * @param delegateObject 委托对象\n * @ignore\n */\nexport function isSlider(delegateObject) {\n  return delegateObject && delegateObject.component && delegateObject.component.isSlider();\n}\n/**\n * 是否由 mask 触发\n * @param context 上下文\n * @ignore\n */\nexport function isMask(context) {\n  var event = context.event;\n  var target = event.target;\n  return target && target.get('name') === 'mask';\n}\n/**\n * 获取被遮挡的 elements\n * @param context 上下文\n * @ignore\n */\nexport function getMaskedElements(context, tolerance) {\n  var target = context.event.target;\n  if (target.get('type') === 'path') {\n    var maskPath = getMaskPath(context, tolerance);\n    if (!maskPath) {\n      return;\n    }\n    return getElementsByPath(context.view, maskPath);\n  }\n  var maskBBox = getMaskBBox(context, tolerance);\n  // 如果 bbox 过小则不返回\n  if (!maskBBox) {\n    return null;\n  }\n  return getIntersectElements(context.view, maskBBox);\n}\n/**\n * @ignore\n */\nexport function getSiblingMaskElements(context, sibling, tolerance) {\n  var maskBBox = getMaskBBox(context, tolerance);\n  // 如果 bbox 过小则不返回\n  if (!maskBBox) {\n    return null;\n  }\n  var view = context.view;\n  var start = getSiblingPoint(view, sibling, {\n    x: maskBBox.x,\n    y: maskBBox.y\n  });\n  var end = getSiblingPoint(view, sibling, {\n    x: maskBBox.maxX,\n    y: maskBBox.maxY\n  });\n  var box = {\n    minX: start.x,\n    minY: start.y,\n    maxX: end.x,\n    maxY: end.y\n  };\n  return getIntersectElements(sibling, box);\n}\n/**\n * 获取所有的图表元素\n * @param view View/Chart\n * @ignore\n */\nexport function getElements(view) {\n  var geometries = view.geometries;\n  var rst = [];\n  each(geometries, function (geom) {\n    var elements = geom.elements;\n    rst = rst.concat(elements);\n  });\n  if (view.views && view.views.length) {\n    each(view.views, function (subView) {\n      rst = rst.concat(getElements(subView));\n    });\n  }\n  return rst;\n}\n/**\n * 获取所有的图表元素\n * @param view View/Chart\n * @param field 字段名\n * @param value 字段值\n * @ignore\n */\nexport function getElementsByField(view, field, value) {\n  var elements = getElements(view);\n  return elements.filter(function (el) {\n    return getElementValue(el, field) === value;\n  });\n}\n/**\n * 根据状态名获取图表元素\n * @param view View/Chart\n * @param stateName 状态名\n * @ignore\n */\nexport function getElementsByState(view, stateName) {\n  var geometries = view.geometries;\n  var rst = [];\n  each(geometries, function (geom) {\n    var elements = geom.getElementsBy(function (el) {\n      return el.hasState(stateName);\n    });\n    rst = rst.concat(elements);\n  });\n  return rst;\n}\n/**\n * 获取图表元素对应字段的值\n * @param element 图表元素\n * @param field 字段名\n * @ignore\n */\nexport function getElementValue(element, field) {\n  var model = element.getModel();\n  var record = model.data;\n  var value;\n  if (isArray(record)) {\n    value = record[0][field];\n  } else {\n    value = record[field];\n  }\n  return value;\n}\n/**\n * 两个包围盒是否相交\n * @param box1 包围盒1\n * @param box2 包围盒2\n * @ignore\n */\nexport function intersectRect(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n}\n/**\n * 获取包围盒内的图表元素\n * @param view View/Chart\n * @param box 包围盒\n * @ignore\n */\nexport function getIntersectElements(view, box) {\n  var elements = getElements(view);\n  var rst = [];\n  each(elements, function (el) {\n    var shape = el.shape;\n    var shapeBBox = shape.getCanvasBBox();\n    if (intersectRect(box, shapeBBox)) {\n      rst.push(el);\n    }\n  });\n  return rst;\n}\nfunction pathToPoints(path) {\n  var points = [];\n  each(path, function (seg) {\n    var command = seg[0];\n    if (command !== 'A') {\n      for (var i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1]]);\n      }\n    } else {\n      var length_1 = seg.length;\n      points.push([seg[length_1 - 2], seg[length_1 - 1]]);\n    }\n  });\n  return points;\n}\n/**\n * 获取包围盒内的图表元素\n * @param view View/Chart\n * @param path 路径\n * @ignore\n */\nexport function getElementsByPath(view, path) {\n  var elements = getElements(view);\n  var points = pathToPoints(path);\n  var rst = elements.filter(function (el) {\n    var shape = el.shape;\n    var shapePoints;\n    if (shape.get('type') === 'path') {\n      shapePoints = pathToPoints(shape.attr('path'));\n    } else {\n      var shapeBBox = shape.getCanvasBBox();\n      shapePoints = toPoints(shapeBBox);\n    }\n    return isPolygonsIntersect(points, shapePoints);\n  });\n  return rst;\n}\n/**\n * 获取当前 View 的所有组件\n * @param view View/Chart\n * @ignore\n */\nexport function getComponents(view) {\n  return view.getComponents().map(function (co) {\n    return co.component;\n  });\n}\n/** @ignore */\nexport function distance(p1, p2) {\n  var dx = p2.x - p1.x;\n  var dy = p2.y - p1.y;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n/** @ignore */\nexport function getSpline(points, z) {\n  if (points.length <= 2) {\n    return getLinePath(points, false);\n  }\n  var first = points[0];\n  var arr = [];\n  each(points, function (point) {\n    arr.push(point.x);\n    arr.push(point.y);\n  });\n  var path = catmullRom2bezier(arr, z, null);\n  path.unshift(['M', first.x, first.y]);\n  return path;\n}\n/**\n * 检测点是否在包围盒内\n * @param box 包围盒\n * @param point 点\n * @ignore\n */\nexport function isInBox(box, point) {\n  return box.x <= point.x && box.maxX >= point.x && box.y <= point.y && box.maxY > point.y;\n}\n/**\n * 获取同 view 同一级的 views\n * @param view 当前 view\n * @returns 同一级的 views\n * @ignore\n */\nexport function getSilbings(view) {\n  var parent = view.parent;\n  var siblings = null;\n  if (parent) {\n    siblings = parent.views.filter(function (sub) {\n      return sub !== view;\n    });\n  }\n  return siblings;\n}\nfunction point2Normalize(view, point) {\n  var coord = view.getCoordinate();\n  return coord.invert(point);\n}\n/**\n * 将 view 上的一点转换成另一个 view 的点\n * @param view 当前的 view\n * @param sibling 同一层级的 view\n * @param point 指定点\n * @ignore\n */\nexport function getSiblingPoint(view, sibling, point) {\n  var normalPoint = point2Normalize(view, point);\n  return sibling.getCoordinate().convert(normalPoint);\n}\n/**\n * 是否在记录中，临时因为所有的 view 中的数据不是引用，而使用的方法\n * 不同 view 上对数据的引用不相等，导致无法直接用 includes\n * 假设 x, y 值相等时是同一条数据，这个假设不完全正确，而改成 isEqual 则成本太高\n * 后面改成同一个引用时可以修改回来\n * @param records\n * @param record\n * @param xFiled\n * @param yField\n * @returns\n * @ignore\n */\nexport function isInRecords(records, record, xFiled, yField) {\n  var isIn = false;\n  each(records, function (r) {\n    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {\n      isIn = true;\n      return false;\n    }\n  });\n  return isIn;\n}\n// 级联获取 field 对应的 scale，如果 view 上没有，遍历子 view\nexport function getScaleByField(view, field) {\n  var scale = view.getScaleByField(field);\n  if (!scale && view.views) {\n    each(view.views, function (subView) {\n      scale = getScaleByField(subView, field);\n      if (scale) {\n        return false; // 终止循环\n      }\n    });\n  }\n\n  return scale;\n}","map":null,"metadata":{},"sourceType":"module"}