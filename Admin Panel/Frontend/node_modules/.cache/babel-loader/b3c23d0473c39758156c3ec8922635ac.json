{"ast":null,"code":"import parsePathString from './parse-path-string';\nvar REGEX_MD = /[a-z]/;\nfunction toSymmetry(p, c) {\n  return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];\n}\nexport default function pathToAbsolute(pathString) {\n  var pathArray = parsePathString(pathString);\n  if (!pathArray || !pathArray.length) {\n    return [['M', 0, 0]];\n  }\n  var needProcess = false; // 如果存在小写的命令或者 V,H,T,S 则需要处理\n  for (var i = 0; i < pathArray.length; i++) {\n    var cmd = pathArray[i][0];\n    // 如果存在相对位置的命令，则中断返回\n    if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {\n      needProcess = true;\n      break;\n    }\n  }\n  // 如果不存在相对命令，则直接返回\n  // 如果在业务上都写绝对路径，这种方式最快，仅做了一次检测\n  if (!needProcess) {\n    return pathArray;\n  }\n  var res = [];\n  var x = 0;\n  var y = 0;\n  var mx = 0;\n  var my = 0;\n  var start = 0;\n  var pa0;\n  var dots;\n  var first = pathArray[0];\n  if (first[0] === 'M' || first[0] === 'm') {\n    x = +first[1];\n    y = +first[2];\n    mx = x;\n    my = y;\n    start++;\n    res[0] = ['M', x, y];\n  }\n  for (var i = start, ii = pathArray.length; i < ii; i++) {\n    var pa = pathArray[i];\n    var preParams = res[i - 1]; // 取前一个已经处理后的节点，否则会出现问题\n    var r = [];\n    var cmd = pa[0];\n    var upCmd = cmd.toUpperCase();\n    if (cmd !== upCmd) {\n      r[0] = upCmd;\n      switch (upCmd) {\n        case 'A':\n          r[1] = pa[1];\n          r[2] = pa[2];\n          r[3] = pa[3];\n          r[4] = pa[4];\n          r[5] = pa[5];\n          r[6] = +pa[6] + x;\n          r[7] = +pa[7] + y;\n          break;\n        case 'V':\n          r[1] = +pa[1] + y;\n          break;\n        case 'H':\n          r[1] = +pa[1] + x;\n          break;\n        case 'M':\n          mx = +pa[1] + x;\n          my = +pa[2] + y;\n          r[1] = mx;\n          r[2] = my;\n          break;\n        // for lint\n        default:\n          for (var j = 1, jj = pa.length; j < jj; j++) {\n            r[j] = +pa[j] + (j % 2 ? x : y);\n          }\n      }\n    } else {\n      // 如果本来已经大写，则不处理\n      r = pathArray[i];\n    }\n    // 需要在外面统一做，同时处理 V,H,S,T 等特殊指令\n    switch (upCmd) {\n      case 'Z':\n        x = +mx;\n        y = +my;\n        break;\n      case 'H':\n        x = r[1];\n        r = ['L', x, y];\n        break;\n      case 'V':\n        y = r[1];\n        r = ['L', x, y];\n        break;\n      case 'T':\n        x = r[1];\n        y = r[2];\n        // 以 x, y 为中心的，上一个控制点的对称点\n        // 需要假设上一个节点的命令为 Q\n        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);\n        r = ['Q', symetricT[0], symetricT[1], x, y];\n        break;\n      case 'S':\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n        // 以 x,y 为中心，取上一个控制点，\n        // 需要假设上一个线段为 C 或者 S\n        var length_1 = preParams.length;\n        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);\n        r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];\n        break;\n      case 'M':\n        mx = r[r.length - 2];\n        my = r[r.length - 1];\n        break;\n      // for lint\n      default:\n        x = r[r.length - 2];\n        y = r[r.length - 1];\n    }\n    res.push(r);\n  }\n  return res;\n}","map":null,"metadata":{},"sourceType":"module"}