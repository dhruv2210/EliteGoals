{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { DODGE_RATIO, MARGIN_RATIO } from '../constant';\nimport Adjust from './adjust';\nvar Dodge = /** @class */function (_super) {\n  __extends(Dodge, _super);\n  function Dodge(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.cacheMap = {};\n    _this.adjustDataArray = [];\n    _this.mergeData = [];\n    var _a = cfg.marginRatio,\n      marginRatio = _a === void 0 ? MARGIN_RATIO : _a,\n      _b = cfg.dodgeRatio,\n      dodgeRatio = _b === void 0 ? DODGE_RATIO : _b,\n      dodgeBy = cfg.dodgeBy,\n      intervalPadding = cfg.intervalPadding,\n      dodgePadding = cfg.dodgePadding,\n      xDimensionLength = cfg.xDimensionLength,\n      groupNum = cfg.groupNum,\n      defaultSize = cfg.defaultSize,\n      maxColumnWidth = cfg.maxColumnWidth,\n      minColumnWidth = cfg.minColumnWidth,\n      columnWidthRatio = cfg.columnWidthRatio,\n      customOffset = cfg.customOffset;\n    _this.marginRatio = marginRatio;\n    _this.dodgeRatio = dodgeRatio;\n    _this.dodgeBy = dodgeBy;\n    _this.intervalPadding = intervalPadding;\n    _this.dodgePadding = dodgePadding;\n    _this.xDimensionLegenth = xDimensionLength;\n    _this.groupNum = groupNum;\n    _this.defaultSize = defaultSize;\n    _this.maxColumnWidth = maxColumnWidth;\n    _this.minColumnWidth = minColumnWidth;\n    _this.columnWidthRatio = columnWidthRatio;\n    _this.customOffset = customOffset;\n    return _this;\n  }\n  Dodge.prototype.process = function (groupDataArray) {\n    var groupedDataArray = _.clone(groupDataArray);\n    // 将数据数组展开一层\n    var mergeData = _.flatten(groupedDataArray);\n    var dodgeBy = this.dodgeBy;\n    // 如果指定了分组 dim 的字段\n    var adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;\n    this.cacheMap = {};\n    this.adjustDataArray = adjustDataArray;\n    this.mergeData = mergeData;\n    this.adjustData(adjustDataArray, mergeData);\n    this.adjustDataArray = [];\n    this.mergeData = [];\n    return groupedDataArray;\n  };\n  Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {\n    var _this = this;\n    var customOffset = this.customOffset;\n    var map = this.getDistribution(dim);\n    var groupData = this.groupData(data, dim); // 根据值分组\n    _.each(groupData, function (group, key) {\n      var range;\n      // xField 中只有一个值，不需要做 dodge\n      if (values.length === 1) {\n        range = {\n          pre: values[0] - 1,\n          next: values[0] + 1\n        };\n      } else {\n        // 如果有多个，则需要获取调整的范围\n        range = _this.getAdjustRange(dim, parseFloat(key), values);\n      }\n      _.each(group, function (d) {\n        var value = d[dim];\n        var valueArr = map[value];\n        var valIndex = valueArr.indexOf(frameIndex);\n        if (!_.isNil(customOffset)) {\n          var pre = range.pre,\n            next = range.next;\n          d[dim] = _.isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;\n        } else {\n          d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);\n        }\n      });\n    });\n    return [];\n  };\n  Dodge.prototype.getDodgeOffset = function (range, idx, len) {\n    var _a = this,\n      dodgeRatio = _a.dodgeRatio,\n      marginRatio = _a.marginRatio,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding;\n    var pre = range.pre,\n      next = range.next;\n    var tickLength = next - pre;\n    var position;\n    // 分多种输入情况\n    if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {\n      // 仅配置intervalPadding\n      var offset = this.getIntervalOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {\n      // 仅配置dodgePadding\n      var offset = this.getDodgeOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(intervalPadding) && !_.isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {\n      // 同时配置intervalPadding和dodgePadding\n      var offset = this.getIntervalAndDodgeOffset(len, idx);\n      position = pre + offset;\n    } else {\n      // 默认情况\n      var width = tickLength * dodgeRatio / len;\n      var margin = marginRatio * width;\n      var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;\n      position = (pre + next) / 2 + offset;\n    }\n    return position;\n  };\n  Dodge.prototype.getIntervalOnlyOffset = function (len, idx) {\n    var _a = this,\n      defaultSize = _a.defaultSize,\n      intervalPadding = _a.intervalPadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum,\n      dodgeRatio = _a.dodgeRatio,\n      maxColumnWidth = _a.maxColumnWidth,\n      minColumnWidth = _a.minColumnWidth,\n      columnWidthRatio = _a.columnWidthRatio;\n    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = !_.isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;\n    // 调整组内间隔\n    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getDodgeOnlyOffset = function (len, idx) {\n    var _a = this,\n      defaultSize = _a.defaultSize,\n      dodgePadding = _a.dodgePadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum,\n      marginRatio = _a.marginRatio,\n      maxColumnWidth = _a.maxColumnWidth,\n      minColumnWidth = _a.minColumnWidth,\n      columnWidthRatio = _a.columnWidthRatio;\n    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;\n    // 调整组间距\n    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getIntervalAndDodgeOffset = function (len, idx) {\n    var _a = this,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum;\n    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getDistribution = function (dim) {\n    var groupedDataArray = this.adjustDataArray;\n    var cacheMap = this.cacheMap;\n    var map = cacheMap[dim];\n    if (!map) {\n      map = {};\n      _.each(groupedDataArray, function (data, index) {\n        var values = _.valuesOfKey(data, dim);\n        if (!values.length) {\n          values.push(0);\n        }\n        _.each(values, function (val) {\n          if (!map[val]) {\n            map[val] = [];\n          }\n          map[val].push(index);\n        });\n      });\n      cacheMap[dim] = map;\n    }\n    return map;\n  };\n  return Dodge;\n}(Adjust);\nexport default Dodge;","map":null,"metadata":{},"sourceType":"module"}