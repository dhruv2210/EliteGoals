{"ast":null,"code":"var onmessage = function onmessage(e) {\n  // Copy from src/util/collision-detect.ts\n  function generateUtils() {\n    function dot(a, b) {\n      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);\n    }\n    /**\n     * 1. 获取投影轴\n     */\n    function getAxes(points /** 多边形的关键点 */) {\n      // 目前先处理 平行矩形 的场景, 其他多边形不处理\n      if (points.length > 4) {\n        return [];\n      }\n      // 获取向量\n      var vector = function vector(start, end) {\n        return [end.x - start.x, end.y - start.y];\n      };\n      // 由于 矩形的平行原理，所以只有 2 条投影轴: A -> B, B -> C\n      var AB = vector(points[0], points[1]);\n      var BC = vector(points[1], points[2]);\n      return [AB, BC];\n    }\n    /**\n     * 绕指定点顺时针旋转后的点坐标\n     * 默认绕原点旋转\n     */\n    function rotateAtPoint(point, deg, origin) {\n      if (deg === void 0) {\n        deg = 0;\n      }\n      if (origin === void 0) {\n        origin = {\n          x: 0,\n          y: 0\n        };\n      }\n      var x = point.x,\n        y = point.y;\n      return {\n        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,\n        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y\n      };\n    }\n    /**\n     * @private\n     * 转化为顶点坐标数组\n     *\n     * @param {Object} box\n     */\n    function getRectPoints(box) {\n      var points = [{\n        x: box.x,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y\n      }, {\n        x: box.x + box.width,\n        y: box.y + box.height\n      }, {\n        x: box.x,\n        y: box.y + box.height\n      }];\n      var rotation = box.rotation;\n      if (rotation) {\n        return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];\n      }\n      return points;\n    }\n    /**\n     * 2. 获取多边形在投影轴上的投影\n     *\n     * 向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。\n     * 由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2\n     */\n    function getProjection(points /** 多边形的关键点 */, axis) {\n      // 目前先处理矩形的场景\n      if (points.length > 4) {\n        return {\n          min: 0,\n          max: 0\n        };\n      }\n      var scalars = [];\n      points.forEach(function (point) {\n        scalars.push(dot([point.x, point.y], axis));\n      });\n      return {\n        min: Math.min.apply(null, scalars),\n        max: Math.max.apply(null, scalars)\n      };\n    }\n    function isProjectionOverlap(projection1, projection2) {\n      return projection1.max > projection2.min && projection1.min < projection2.max;\n    }\n    function isValidNumber(d) {\n      return typeof d === 'number' && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;\n    }\n    function isValidBox(box) {\n      return ['x', 'y', 'width', 'height'].every(function (attr) {\n        return isValidNumber(box[attr]);\n      });\n    }\n    function isIntersectRect(box1, box2, margin) {\n      if (margin === void 0) {\n        margin = 0;\n      }\n      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);\n    }\n    function intersect(box1, box2, margin) {\n      if (margin === void 0) {\n        margin = 0;\n      }\n      if (!isValidBox(box1) || !isValidBox(box2)) return false;\n      // Quick detect, if rotation is null or zero.\n      if (!box1.rotation && !box2.rotation) {\n        return isIntersectRect(box1, box2, margin);\n      }\n      // 分别获取 4 个关键点\n      var rect1Points = getRectPoints(box1);\n      var rect2Points = getRectPoints(box2);\n      // 获取所有投影轴\n      var axes = getAxes(rect1Points).concat(getAxes(rect2Points));\n      for (var i = 0; i < axes.length; i++) {\n        var axis = axes[i];\n        var projection1 = getProjection(rect1Points, axis);\n        var projection2 = getProjection(rect2Points, axis);\n        if (!isProjectionOverlap(projection1, projection2)) return false;\n      }\n      return true;\n    }\n    return {\n      intersect: intersect\n    };\n  }\n  var intersect = generateUtils().intersect;\n  // Label layouts.\n  function hideOverlap(items) {\n    var boxes = items.slice();\n    for (var i = 0; i < boxes.length; i++) {\n      var box1 = boxes[i];\n      if (box1.visible) {\n        for (var j = i + 1; j < boxes.length; j++) {\n          var box2 = boxes[j];\n          if (box1 !== box2 && box2.visible) {\n            if (intersect(box1, box2)) {\n              box2.visible = false;\n            }\n          }\n        }\n      }\n    }\n    return boxes;\n  }\n  var methods = {\n    'hide-overlap': hideOverlap\n  };\n  // Main\n  try {\n    var eventData = JSON.parse(e.data);\n    if (!eventData || !eventData.type || !methods[eventData.type]) return;\n    var type = eventData.type,\n      items = eventData.items;\n    var result = methods[type](items);\n    self.postMessage(result);\n  } catch (e) {\n    throw e;\n  }\n};\nvar code = \"\\n   self.onmessage = \".concat(onmessage.toString(), \"\\n\");\nexport { code };","map":null,"metadata":{},"sourceType":"module"}