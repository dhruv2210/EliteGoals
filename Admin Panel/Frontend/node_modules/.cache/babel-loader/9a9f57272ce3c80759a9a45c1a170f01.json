{"ast":null,"code":"'use strict';\n\nvar DEFAULT_SIZE = 50;\nvar DEFAULT_WIDTH = 2;\nvar LN_2 = Math.log(2);\nvar self = module.exports;\nvar helper = require('./helper');\n\n// Triangle\nfunction kernel(x) {\n  return 1 - Math.abs(x);\n}\n\n/**\n * Get min and max value for the pdf, covering all arr data range while respecting options' data\n * @param arr\n * @param options\n * @returns {*}\n */\nmodule.exports.getUnifiedMinMax = function (arr, options) {\n  return self.getUnifiedMinMaxMulti([arr], options);\n};\nmodule.exports.getUnifiedMinMaxMulti = function (arrMulti, options) {\n  options = options || {};\n  var relaxMin = false;\n  var relaxMax = false;\n  var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;\n  var size = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;\n  var min = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));\n  var max = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));\n  var range = max - min;\n  var step = range / (size - 1);\n\n  // Relax?\n  if (relaxMin) {\n    min = min - 2 * width * step;\n  }\n  if (relaxMax) {\n    max = max + 2 * width * step;\n  }\n  return {\n    min: min,\n    max: max\n  };\n};\nmodule.exports.create = function (arr, options) {\n  options = options || {};\n  if (!arr || arr.length === 0) {\n    return [];\n  }\n  var size = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;\n  var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;\n  var normalizedMinMax = self.getUnifiedMinMax(arr, {\n    size: size,\n    width: width,\n    min: options.min,\n    max: options.max\n  });\n  var min = normalizedMinMax.min;\n  var max = normalizedMinMax.max;\n  var range = max - min;\n  var step = range / (size - 1);\n  if (range === 0) {\n    // Special case...\n    return [{\n      x: min,\n      y: 1\n    }];\n  }\n\n  // Good to go\n\n  var buckets = [];\n  for (var i = 0; i < size; i++) {\n    buckets.push({\n      x: min + i * step,\n      y: 0\n    });\n  }\n  var xToBucket = function xToBucket(x) {\n    return Math.floor((x - min) / step);\n  };\n  var partialArea = generatePartialAreas(kernel, width);\n  var fullArea = partialArea[width];\n  var c = partialArea[width - 1] - partialArea[width - 2];\n  var initalValue = 0;\n  arr.forEach(function (x) {\n    var bucket = xToBucket(x);\n\n    // Totally outside?\n    if (bucket + width < 0 || bucket - width >= buckets.length) {\n      return;\n    }\n    var start = Math.max(bucket - width, 0);\n    var mid = bucket;\n    var end = Math.min(bucket + width, buckets.length - 1);\n    var leftBlockCount = start - (bucket - width);\n    var rightBlockCount = bucket + width - end;\n    var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;\n    var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;\n    var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);\n    if (leftBlockCount > 0) {\n      initalValue += weight * (leftBlockCount - 1) * c;\n    }\n\n    // Add grads\n    var startGradPos = Math.max(0, bucket - width + 1);\n    if (helper.inside(0, buckets.length - 1, startGradPos)) {\n      buckets[startGradPos].y += weight * 1 * c;\n    }\n    if (helper.inside(0, buckets.length - 1, mid + 1)) {\n      buckets[mid + 1].y -= weight * 2 * c;\n    }\n    if (helper.inside(0, buckets.length - 1, end + 1)) {\n      buckets[end + 1].y += weight * 1 * c;\n    }\n  });\n  var accumulator = initalValue;\n  var gradAccumulator = 0;\n  var area = 0;\n  buckets.forEach(function (bucket) {\n    gradAccumulator += bucket.y;\n    accumulator += gradAccumulator;\n    bucket.y = accumulator;\n    area += accumulator;\n  });\n\n  // Normalize\n  if (area > 0) {\n    buckets.forEach(function (bucket) {\n      bucket.y /= area;\n    });\n  }\n  return buckets;\n};\nfunction generatePartialAreas(kernel, width) {\n  var partialAreas = {};\n  var accumulator = 0;\n  for (var i = -width; i <= width; i++) {\n    accumulator += kernel(i / width);\n    partialAreas[i] = accumulator;\n  }\n  return partialAreas;\n}\nmodule.exports.getExpectedValueFromPdf = function (pdf) {\n  if (!pdf || pdf.length === 0) {\n    return undefined;\n  }\n  var expected = 0;\n  pdf.forEach(function (obj) {\n    expected += obj.x * obj.y;\n  });\n  return expected;\n};\nmodule.exports.getXWithLeftTailArea = function (pdf, area) {\n  if (!pdf || pdf.length === 0) {\n    return undefined;\n  }\n  var accumulator = 0;\n  var last = 0;\n  for (var i = 0; i < pdf.length; i++) {\n    last = i;\n    accumulator += pdf[i].y;\n    if (accumulator >= area) {\n      break;\n    }\n  }\n  return pdf[last].x;\n};\nmodule.exports.getPerplexity = function (pdf) {\n  if (!pdf || pdf.length === 0) {\n    return undefined;\n  }\n  var entropy = 0;\n  pdf.forEach(function (obj) {\n    var ln = Math.log(obj.y);\n    if (isFinite(ln)) {\n      entropy += obj.y * ln;\n    }\n  });\n  entropy = -entropy / LN_2;\n  return Math.pow(2, entropy);\n};","map":null,"metadata":{},"sourceType":"script"}