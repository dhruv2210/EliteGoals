{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { groupBy, keys, map } from '@antv/util';\nimport { findLabelTextShape } from '../../util';\n/**\n * 对同一组(相同 xField )的 Label 进行排序：第一个、最后一个、其他...\n * @param geometry\n * @param labels\n */\nfunction sortLabels(geometry, labels) {\n  var yField = geometry.getXYFields()[1];\n  var result = [];\n  var sortedLabels = labels.sort(function (left, right) {\n    return left.get('data')[yField] - left.get('data')[yField];\n  });\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.shift());\n  }\n  if (sortedLabels.length > 0) {\n    result.push(sortedLabels.pop());\n  }\n  result.push.apply(result, __spreadArray([], __read(sortedLabels), false));\n  return result;\n}\nfunction hasSome(dones, current, compare) {\n  return dones.some(function (done) {\n    return compare(done, current);\n  });\n}\n/**\n * 计算两个矩形之间的堆叠区域面积\n */\nfunction getOverlapArea(a, b, margin) {\n  if (margin === void 0) {\n    margin = 0;\n  }\n  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));\n  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));\n  return xOverlap * yOverlap;\n}\n/**\n * 判断新添加的 Label 是否和已存在的发生重叠\n * @param dones\n * @param current\n */\nfunction checkShapeOverlap(dones, current) {\n  return hasSome(dones, current, function (left, right) {\n    var leftText = findLabelTextShape(left);\n    var rightText = findLabelTextShape(right);\n    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;\n  });\n}\n/**\n * 适用于 point geometry 的数据标签位置自动调整布局方法\n * @param items\n * @param labels\n * @param shapes\n * @param region\n * @param cfg\n */\nexport function pointAdjustPosition(items, labels, shapes, region, cfg) {\n  var _a, _b;\n  if (shapes.length === 0) {\n    return;\n  }\n  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');\n  var geometry = element === null || element === void 0 ? void 0 : element.geometry;\n  if (!geometry || geometry.type !== 'point') {\n    return;\n  }\n  var _c = __read(geometry.getXYFields(), 2),\n    xField = _c[0],\n    yField = _c[1];\n  var groupedLabels = groupBy(labels, function (label) {\n    return label.get('data')[xField];\n  });\n  var dones = [];\n  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;\n  map(keys(groupedLabels).reverse(), function (xValue) {\n    var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);\n    while (sortedCollections.length) {\n      var current = sortedCollections.shift();\n      var textShape = findLabelTextShape(current);\n      if (hasSome(dones, current, function (left, right) {\n        return left.get('data')[xField] === right.get('data')[xField] && left.get('data')[yField] === right.get('data')[yField];\n      })) {\n        // 重复位置，直接隐藏\n        textShape.set('visible', false);\n        continue;\n      }\n      var upFail = checkShapeOverlap(dones, current);\n      var downFail = false;\n      if (upFail) {\n        textShape.attr('y', textShape.attr('y') + 2 * offset);\n        downFail = checkShapeOverlap(dones, current);\n      }\n      if (downFail) {\n        textShape.set('visible', false);\n        continue;\n      }\n      dones.push(current);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"module"}