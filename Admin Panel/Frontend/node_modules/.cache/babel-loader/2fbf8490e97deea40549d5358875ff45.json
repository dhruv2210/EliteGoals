{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { deepMix, each, get, isArray, isEmpty, isEqual, isFunction, isString } from '@antv/util';\n// 暂未发包\n// @ts-ignore\nimport { propagationDelegate } from '@antv/component';\nimport { doAnimate } from '../../animate';\nimport Base from '../../base';\nimport { getReplaceAttrs } from '../../util/graphics';\nimport { GEOMETRY_LIFE_CIRCLE } from '../../constant';\nimport { BACKGROUND_SHAPE } from '../shape/constant';\n/**\n * Element 图形元素。\n * 定义：在 G2 中，我们会将数据通过图形语法映射成不同的图形，比如点图，数据集中的每条数据会对应一个点，柱状图每条数据对应一个柱子，线图则是一组数据对应一条折线，Element 即一条/一组数据对应的图形元素，它代表一条数据或者一个数据集，在图形层面，它可以是单个 Shape 也可以是多个 Shape，我们称之为图形元素。\n */\nvar Element = /** @class */function (_super) {\n  __extends(Element, _super);\n  function Element(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /** 保存 shape 对应的 label */\n    _this.labelShape = [];\n    // 存储当前开启的状态\n    _this.states = [];\n    var shapeFactory = cfg.shapeFactory,\n      container = cfg.container,\n      offscreenGroup = cfg.offscreenGroup,\n      elementIndex = cfg.elementIndex,\n      _a = cfg.visible,\n      visible = _a === void 0 ? true : _a;\n    _this.shapeFactory = shapeFactory;\n    _this.container = container;\n    _this.offscreenGroup = offscreenGroup;\n    _this.visible = visible;\n    _this.elementIndex = elementIndex;\n    return _this;\n  }\n  /**\n   * 绘制图形。\n   * @param model 绘制数据。\n   * @param isUpdate 可选，是否是更新发生后的绘制。\n   */\n  Element.prototype.draw = function (model, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    this.model = model;\n    this.data = model.data; // 存储原始数据\n    this.shapeType = this.getShapeType(model);\n    // 绘制图形\n    this.drawShape(model, isUpdate);\n    if (this.visible === false) {\n      // 用户在初始化的时候声明 visible: false\n      this.changeVisible(false);\n    }\n  };\n  /**\n   * 更新图形。\n   * @param model 更新的绘制数据。\n   */\n  Element.prototype.update = function (model) {\n    var _a = this,\n      shapeFactory = _a.shapeFactory,\n      shape = _a.shape;\n    if (!shape) {\n      return;\n    }\n    // 更新数据\n    this.model = model;\n    this.data = model.data;\n    this.shapeType = this.getShapeType(model);\n    // step 1: 更新 shape 携带的信息\n    this.setShapeInfo(shape, model);\n    // step 2: 使用虚拟 Group 重新绘制 shape，然后更新当前 shape\n    var offscreenGroup = this.getOffscreenGroup();\n    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);\n    // @ts-ignore\n    newShape.cfg.data = this.data;\n    // @ts-ignore\n    newShape.cfg.origin = model;\n    // label 需要使用\n    newShape.cfg.element = this;\n    // step 3: 同步 shape 样式\n    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));\n  };\n  /**\n   * 销毁 element 实例。\n   */\n  Element.prototype.destroy = function () {\n    var _a = this,\n      shapeFactory = _a.shapeFactory,\n      shape = _a.shape;\n    if (shape) {\n      var animateCfg = this.getAnimateCfg('leave');\n      if (animateCfg) {\n        // 指定了动画配置则执行销毁动画\n        doAnimate(shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: __assign({}, shape.attr())\n        });\n      } else {\n        // 否则直接销毁\n        shape.remove(true);\n      }\n    }\n    // reset\n    this.states = [];\n    this.shapeFactory = undefined;\n    this.container = undefined;\n    this.shape = undefined;\n    this.animate = undefined;\n    this.geometry = undefined;\n    this.labelShape = [];\n    this.model = undefined;\n    this.data = undefined;\n    this.offscreenGroup = undefined;\n    this.statesStyle = undefined;\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 显示或者隐藏 element。\n   * @param visible 是否可见。\n   */\n  Element.prototype.changeVisible = function (visible) {\n    _super.prototype.changeVisible.call(this, visible);\n    if (visible) {\n      if (this.shape) {\n        this.shape.show();\n      }\n      if (this.labelShape) {\n        this.labelShape.forEach(function (label) {\n          label.show();\n        });\n      }\n    } else {\n      if (this.shape) {\n        this.shape.hide();\n      }\n      if (this.labelShape) {\n        this.labelShape.forEach(function (label) {\n          label.hide();\n        });\n      }\n    }\n  };\n  /**\n   * 设置 Element 的状态。\n   *\n   * 目前 Element 开放三种状态：\n   * 1. active\n   * 2. selected\n   * 3. inactive\n   *\n   * 这三种状态相互独立，可以进行叠加。\n   *\n   * 这三种状态的样式可在 [[Theme]] 主题中或者通过 `geometry.state()` 接口进行配置。\n   *\n   * ```ts\n   * // 激活 active 状态\n   * setState('active', true);\n   * ```\n   *\n   * @param stateName 状态名\n   * @param stateStatus 是否开启状态\n   */\n  Element.prototype.setState = function (stateName, stateStatus) {\n    var _a = this,\n      states = _a.states,\n      shapeFactory = _a.shapeFactory,\n      model = _a.model,\n      shape = _a.shape,\n      shapeType = _a.shapeType;\n    var index = states.indexOf(stateName);\n    if (stateStatus) {\n      // 开启状态\n      if (index > -1) {\n        // 该状态已经开启，则返回\n        return;\n      }\n      states.push(stateName);\n      if (stateName === 'active' || stateName === 'selected') {\n        shape === null || shape === void 0 ? void 0 : shape.toFront();\n      }\n    } else {\n      if (index === -1) {\n        // 关闭状态，但是状态未设置过\n        return;\n      }\n      states.splice(index, 1);\n      if (stateName === 'active' || stateName === 'selected') {\n        var _b = this.geometry,\n          sortZIndex = _b.sortZIndex,\n          zIndexReversed = _b.zIndexReversed;\n        var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;\n        sortZIndex ? shape.setZIndex(idx) : shape.set('zIndex', idx);\n      }\n    }\n    // 使用虚拟 group 重新绘制 shape，然后对这个 shape 应用状态样式后，更新当前 shape。\n    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());\n    if (states.length) {\n      // 应用当前状态\n      this.syncShapeStyle(shape, offscreenShape, states, null);\n    } else {\n      // 如果没有状态，则需要恢复至原始状态\n      this.syncShapeStyle(shape, offscreenShape, ['reset'], null);\n    }\n    offscreenShape.remove(true); // 销毁，减少内存占用\n    var eventObject = {\n      state: stateName,\n      stateStatus: stateStatus,\n      element: this,\n      target: this.container\n    };\n    this.container.emit('statechange', eventObject);\n    // @ts-ignore\n    propagationDelegate(this.shape, 'statechange', eventObject);\n  };\n  /**\n   * 清空状量态，恢复至初始状态。\n   */\n  Element.prototype.clearStates = function () {\n    var _this = this;\n    var states = this.states;\n    each(states, function (state) {\n      _this.setState(state, false);\n    });\n    this.states = [];\n  };\n  /**\n   * 查询当前 Element 上是否已设置 `stateName` 对应的状态。\n   * @param stateName 状态名称。\n   * @returns true 表示存在，false 表示不存在。\n   */\n  Element.prototype.hasState = function (stateName) {\n    return this.states.includes(stateName);\n  };\n  /**\n   * 获取当前 Element 上所有的状态。\n   * @returns 当前 Element 上所有的状态数组。\n   */\n  Element.prototype.getStates = function () {\n    return this.states;\n  };\n  /**\n   * 获取 Element 对应的原始数据。\n   * @returns 原始数据。\n   */\n  Element.prototype.getData = function () {\n    return this.data;\n  };\n  /**\n   * 获取 Element 对应的图形绘制数据。\n   * @returns 图形绘制数据。\n   */\n  Element.prototype.getModel = function () {\n    return this.model;\n  };\n  /**\n   * 返回 Element 元素整体的 bbox，包含文本及文本连线（有的话）。\n   * @returns 整体包围盒。\n   */\n  Element.prototype.getBBox = function () {\n    var _a = this,\n      shape = _a.shape,\n      labelShape = _a.labelShape;\n    var bbox = {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0\n    };\n    if (shape) {\n      bbox = shape.getCanvasBBox();\n    }\n    if (labelShape) {\n      labelShape.forEach(function (label) {\n        var labelBBox = label.getCanvasBBox();\n        bbox.x = Math.min(labelBBox.x, bbox.x);\n        bbox.y = Math.min(labelBBox.y, bbox.y);\n        bbox.minX = Math.min(labelBBox.minX, bbox.minX);\n        bbox.minY = Math.min(labelBBox.minY, bbox.minY);\n        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);\n        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);\n      });\n    }\n    bbox.width = bbox.maxX - bbox.minX;\n    bbox.height = bbox.maxY - bbox.minY;\n    return bbox;\n  };\n  Element.prototype.getStatesStyle = function () {\n    if (!this.statesStyle) {\n      var _a = this,\n        shapeType = _a.shapeType,\n        geometry = _a.geometry,\n        shapeFactory = _a.shapeFactory;\n      var stateOption = geometry.stateOption;\n      var defaultShapeType = shapeFactory.defaultShapeType;\n      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];\n      this.statesStyle = deepMix({}, stateTheme, stateOption);\n    }\n    return this.statesStyle;\n  };\n  // 从主题中获取对应状态量的样式\n  Element.prototype.getStateStyle = function (stateName, shapeKey) {\n    var statesStyle = this.getStatesStyle();\n    var stateCfg = get(statesStyle, [stateName, 'style'], {});\n    var shapeStyle = stateCfg[shapeKey] || stateCfg;\n    if (isFunction(shapeStyle)) {\n      return shapeStyle(this);\n    }\n    return shapeStyle;\n  };\n  // 获取动画配置\n  Element.prototype.getAnimateCfg = function (animateType) {\n    var _this = this;\n    var animate = this.animate;\n    if (animate) {\n      var cfg_1 = animate[animateType];\n      if (cfg_1) {\n        // 增加动画的回调函数，如果外部传入了，则先执行外部，然后发射 geometry 的 animate 事件\n        return __assign(__assign({}, cfg_1), {\n          callback: function callback() {\n            var _a;\n            isFunction(cfg_1.callback) && cfg_1.callback();\n            (_a = _this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);\n          }\n        });\n      }\n      return cfg_1;\n    }\n    return null;\n  };\n  // 绘制图形\n  Element.prototype.drawShape = function (model, isUpdate) {\n    var _a;\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    var _b = this,\n      shapeFactory = _b.shapeFactory,\n      container = _b.container,\n      shapeType = _b.shapeType;\n    // 自定义 shape 有可能返回空 shape\n    this.shape = shapeFactory.drawShape(shapeType, model, container);\n    if (this.shape) {\n      this.setShapeInfo(this.shape, model); // 存储绘图数据\n      // @ts-ignore\n      var name_1 = this.shape.cfg.name;\n      // 附加 element 的 name, name 现在支持数组了，很好用了\n      if (!name_1) {\n        // 这个地方如果用户添加了 name, 则附加 name ，否则就添加自己的 name\n        // @ts-ignore\n        this.shape.cfg.name = ['element', this.shapeFactory.geometryType];\n      } else if (isString(name_1)) {\n        // @ts-ignore\n        this.shape.cfg.name = ['element', name_1];\n      }\n      // 执行入场动画\n      var animateType = isUpdate ? 'enter' : 'appear';\n      var animateCfg = this.getAnimateCfg(animateType);\n      if (animateCfg) {\n        // 开始执行动画的生命周期\n        (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n        doAnimate(this.shape, animateCfg, {\n          coordinate: shapeFactory.coordinate,\n          toAttrs: __assign({}, this.shape.attr())\n        });\n      }\n    }\n  };\n  // 获取虚拟 Group\n  Element.prototype.getOffscreenGroup = function () {\n    if (!this.offscreenGroup) {\n      var GroupCtor = this.container.getGroupBase(); // 获取分组的构造函数\n      this.offscreenGroup = new GroupCtor({});\n    }\n    return this.offscreenGroup;\n  };\n  // 设置 shape 上需要携带的信息\n  Element.prototype.setShapeInfo = function (shape, data) {\n    var _this = this;\n    // @ts-ignore\n    shape.cfg.origin = data;\n    // @ts-ignore\n    shape.cfg.element = this;\n    if (shape.isGroup()) {\n      var children = shape.get('children');\n      children.forEach(function (child) {\n        _this.setShapeInfo(child, data);\n      });\n    }\n  };\n  // 更新当前 shape 的样式\n  Element.prototype.syncShapeStyle = function (sourceShape, targetShape, states, animateCfg, index) {\n    var _this = this;\n    var _a;\n    if (states === void 0) {\n      states = [];\n    }\n    if (index === void 0) {\n      index = 0;\n    }\n    if (!sourceShape || !targetShape) {\n      return;\n    }\n    // 所有的 shape 都需要同步 clip\n    var clip = sourceShape.get('clipShape');\n    var newClip = targetShape.get('clipShape');\n    this.syncShapeStyle(clip, newClip, states, animateCfg);\n    if (sourceShape.isGroup()) {\n      var children = sourceShape.get('children');\n      var newChildren = targetShape.get('children');\n      for (var i = 0; i < children.length; i++) {\n        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);\n      }\n    } else {\n      if (!isEmpty(states) && !isEqual(states, ['reset'])) {\n        var name_2 = sourceShape.get('name');\n        if (isArray(name_2)) {\n          // 会附加 element 的 name\n          name_2 = name_2[1];\n        }\n        each(states, function (state) {\n          // background shape 不进行状态样式设置\n          if (targetShape.get('name') !== BACKGROUND_SHAPE) {\n            var style = _this.getStateStyle(state, name_2 || index); // 如果用户没有设置 name，则默认根据索引值\n            targetShape.attr(style);\n          }\n        });\n      }\n      var newAttrs = getReplaceAttrs(sourceShape, targetShape);\n      if (this.animate) {\n        if (animateCfg) {\n          (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);\n          // 需要进行动画\n          doAnimate(sourceShape, animateCfg, {\n            coordinate: this.shapeFactory.coordinate,\n            toAttrs: newAttrs,\n            shapeModel: this.model\n          });\n        } else if (!isEmpty(states)) {\n          sourceShape.stopAnimate();\n          sourceShape.animate(newAttrs, {\n            duration: 300\n          });\n        } else {\n          sourceShape.attr(newAttrs);\n        }\n      } else {\n        sourceShape.attr(newAttrs);\n      }\n    }\n  };\n  Element.prototype.getShapeType = function (model) {\n    var shape = get(model, 'shape');\n    return isArray(shape) ? shape[0] : shape;\n  };\n  return Element;\n}(Base);\nexport default Element;","map":null,"metadata":{},"sourceType":"module"}