{"ast":null,"code":"import { isAllowCapture, multiplyVec2, invert } from '@antv/g-base';\nfunction invertFromMatrix(v, matrix) {\n  if (matrix) {\n    var invertMatrix = invert(matrix);\n    return multiplyVec2(invertMatrix, v);\n  }\n  return v;\n}\nfunction getRefXY(element, x, y) {\n  // @ts-ignore\n  var totalMatrix = element.getTotalMatrix();\n  if (totalMatrix) {\n    var _a = invertFromMatrix([x, y, 1], totalMatrix),\n      refX = _a[0],\n      refY = _a[1];\n    return [refX, refY];\n  }\n  return [x, y];\n}\n// 拾取前的检测，只有通过检测才能继续拾取\nfunction preTest(element, x, y) {\n  // @ts-ignore\n  if (element.isCanvas && element.isCanvas()) {\n    return true;\n  }\n  // 不允许被拾取，则返回 null\n  // @ts-ignore\n  if (!isAllowCapture(element) || element.cfg.isInView === false) {\n    return false;\n  }\n  if (element.cfg.clipShape) {\n    // 如果存在 clip\n    var _a = getRefXY(element, x, y),\n      refX = _a[0],\n      refY = _a[1];\n    if (element.isClipped(refX, refY)) {\n      return false;\n    }\n  }\n  // @ts-ignore ，这个地方调用过于频繁\n  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();\n  // 如果没有缓存 bbox，则说明不可见\n  // 注释掉的这段可能会加速拾取，上面的语句改写成 const bbox = element.cfg.cacheCanvasBBox;\n  // 这时候的拾取假设图形/分组在上一次绘制都在视窗内，但是上面已经判定了 isInView 所以意义不大\n  // 现在还调用 element.getCanvasBBox(); 一个很大的原因是便于单元测试\n  // if (!bbox) {\n  //   return false;\n  // }\n  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {\n    return false;\n  }\n  return true;\n}\n// 这个方法复写了 g-base 的 getShape\nexport function getShape(container, x, y) {\n  // 没有通过检测，则返回 null\n  if (!preTest(container, x, y)) {\n    return null;\n  }\n  var shape = null;\n  var children = container.getChildren();\n  var count = children.length;\n  for (var i = count - 1; i >= 0; i--) {\n    var child = children[i];\n    if (child.isGroup()) {\n      shape = getShape(child, x, y);\n    } else if (preTest(child, x, y)) {\n      var curShape = child;\n      var _a = getRefXY(child, x, y),\n        refX = _a[0],\n        refY = _a[1];\n      // @ts-ignore\n      if (curShape.isInShape(refX, refY)) {\n        shape = child;\n      }\n    }\n    if (shape) {\n      break;\n    }\n  }\n  return shape;\n}","map":null,"metadata":{},"sourceType":"module"}