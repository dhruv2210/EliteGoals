{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { Cubic as CubicUtil } from '@antv/g-math';\nimport { each, isNil } from '@antv/util';\nimport ShapeBase from './base';\nimport { path2Absolute, path2Segments } from '@antv/path-util';\nimport { drawPath } from '../util/draw';\nimport isPointInPath from '../util/in-path/point-in-path';\nimport isInPolygon from '../util/in-path/polygon';\nimport PathUtil from '../util/path';\nimport * as ArrowUtil from '../util/arrow';\n// 是否在多个多边形内部\nfunction isInPolygons(polygons, x, y) {\n  var isHit = false;\n  for (var i = 0; i < polygons.length; i++) {\n    var points = polygons[i];\n    isHit = isInPolygon(points, x, y);\n    if (isHit) {\n      break;\n    }\n  }\n  return isHit;\n}\nvar Path = /** @class */function (_super) {\n  __extends(Path, _super);\n  function Path() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Path.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    return __assign(__assign({}, attrs), {\n      startArrow: false,\n      endArrow: false\n    });\n  };\n  Path.prototype.initAttrs = function (attrs) {\n    this._setPathArr(attrs.path);\n    this.setArrow();\n  };\n  // 更新属性时，检测是否更改了 path\n  Path.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (name === 'path') {\n      this._setPathArr(value);\n    }\n    // 由于箭头的绘制依赖于 line 的诸多 attrs，因此这里不再对每个 attr 进行判断，attr 每次变化都会影响箭头的更新\n    this.setArrow();\n  };\n  // 将 path 转换成绝对路径\n  Path.prototype._setPathArr = function (path) {\n    // 转换 path 的格式\n    this.attrs.path = path2Absolute(path);\n    var hasArc = PathUtil.hasArc(path);\n    // 为了加速 path 的绘制、拾取和计算，这个地方可以缓存很多东西\n    // 这些缓存都是第一次需要时计算和存储，虽然增加了复杂度，但是频繁调用的方法，性能有很大提升\n    this.set('hasArc', hasArc);\n    this.set('paramsCache', {}); // 清理缓存\n    this.set('segments', null); // 延迟生成 path，在动画场景下可能不会有拾取\n    this.set('curve', null);\n    this.set('tCache', null);\n    this.set('totalLength', null);\n  };\n  Path.prototype.getSegments = function () {\n    var segments = this.get('segements');\n    if (!segments) {\n      segments = path2Segments(this.attr('path'));\n      this.set('segments', segments);\n    }\n    return segments;\n  };\n  Path.prototype.setArrow = function () {\n    var attrs = this.attr();\n    var startArrow = attrs.startArrow,\n      endArrow = attrs.endArrow;\n    if (startArrow) {\n      var tangent = this.getStartTangent();\n      ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n    if (endArrow) {\n      var tangent = this.getEndTangent();\n      ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);\n    }\n  };\n  Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var segments = this.getSegments();\n    var hasArc = this.get('hasArc');\n    var isHit = false;\n    if (isStroke) {\n      var length_1 = this.getTotalLength();\n      isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);\n    }\n    if (!isHit && isFill) {\n      if (hasArc) {\n        // 存在曲线时，暂时使用 canvas 的 api 计算，后续可以进行多边形切割\n        isHit = isPointInPath(this, x, y);\n      } else {\n        var path = this.attr('path');\n        var extractResutl = PathUtil.extractPolygons(path);\n        // 提取出来的多边形包含闭合的和非闭合的，在这里统一按照多边形处理\n        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);\n      }\n    }\n    return isHit;\n  };\n  Path.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var paramsCache = this.get('paramsCache'); // 由于计算圆弧的参数成本很大，所以要缓存\n    drawPath(this, context, attrs, paramsCache);\n  };\n  Path.prototype.afterDrawPath = function (context) {\n    var startArrowShape = this.get('startArrowShape');\n    var endArrowShape = this.get('endArrowShape');\n    if (startArrowShape) {\n      startArrowShape.draw(context);\n    }\n    if (endArrowShape) {\n      endArrowShape.draw(context);\n    }\n  };\n  /**\n   * Get total length of path\n   * @return {number} length\n   */\n  Path.prototype.getTotalLength = function () {\n    var totalLength = this.get('totalLength');\n    if (!isNil(totalLength)) {\n      return totalLength;\n    }\n    this._calculateCurve();\n    this._setTcache();\n    return this.get('totalLength');\n  };\n  /**\n   * Get point according to ratio\n   * @param {number} ratio\n   * @return {Point} point\n   */\n  Path.prototype.getPoint = function (ratio) {\n    var tCache = this.get('tCache');\n    if (!tCache) {\n      this._calculateCurve();\n      this._setTcache();\n      tCache = this.get('tCache');\n    }\n    var subt;\n    var index;\n    var curve = this.get('curve');\n    if (!tCache || tCache.length === 0) {\n      if (curve) {\n        return {\n          x: curve[0][1],\n          y: curve[0][2]\n        };\n      }\n      return null;\n    }\n    each(tCache, function (v, i) {\n      if (ratio >= v[0] && ratio <= v[1]) {\n        subt = (ratio - v[0]) / (v[1] - v[0]);\n        index = i;\n      }\n    });\n    var seg = curve[index];\n    if (isNil(seg) || isNil(index)) {\n      return null;\n    }\n    var l = seg.length;\n    var nextSeg = curve[index + 1];\n    return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);\n  };\n  Path.prototype._calculateCurve = function () {\n    var path = this.attr().path;\n    this.set('curve', PathUtil.pathToCurve(path));\n  };\n  Path.prototype._setTcache = function () {\n    var totalLength = 0;\n    var tempLength = 0;\n    // 每段 curve 对应起止点的长度比例列表，形如: [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]\n    var tCache = [];\n    var segmentT;\n    var segmentL;\n    var segmentN;\n    var l;\n    var curve = this.get('curve');\n    if (!curve) {\n      return;\n    }\n    each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n      if (segmentN) {\n        totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;\n      }\n    });\n    this.set('totalLength', totalLength);\n    if (totalLength === 0) {\n      this.set('tCache', []);\n      return;\n    }\n    each(curve, function (segment, i) {\n      segmentN = curve[i + 1];\n      l = segment.length;\n      if (segmentN) {\n        segmentT = [];\n        segmentT[0] = tempLength / totalLength;\n        segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);\n        // 当 path 不连续时，segmentL 可能为空，为空时需要作为 0 处理\n        tempLength += segmentL || 0;\n        segmentT[1] = tempLength / totalLength;\n        tCache.push(segmentT);\n      }\n    });\n    this.set('tCache', tCache);\n  };\n  /**\n   * Get start tangent vector\n   * @return {Array}\n   */\n  Path.prototype.getStartTangent = function () {\n    var segments = this.getSegments();\n    var result;\n    if (segments.length > 1) {\n      var startPoint = segments[0].currentPoint;\n      var endPoint = segments[1].currentPoint;\n      var tangent = segments[1].startTangent;\n      result = [];\n      if (tangent) {\n        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      } else {\n        result.push([endPoint[0], endPoint[1]]);\n        result.push([startPoint[0], startPoint[1]]);\n      }\n    }\n    return result;\n  };\n  /**\n   * Get end tangent vector\n   * @return {Array}\n   */\n  Path.prototype.getEndTangent = function () {\n    var segments = this.getSegments();\n    var length = segments.length;\n    var result;\n    if (length > 1) {\n      var startPoint = segments[length - 2].currentPoint;\n      var endPoint = segments[length - 1].currentPoint;\n      var tangent = segments[length - 1].endTangent;\n      result = [];\n      if (tangent) {\n        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      } else {\n        result.push([startPoint[0], startPoint[1]]);\n        result.push([endPoint[0], endPoint[1]]);\n      }\n    }\n    return result;\n  };\n  return Path;\n}(ShapeBase);\nexport default Path;","map":null,"metadata":{},"sourceType":"module"}