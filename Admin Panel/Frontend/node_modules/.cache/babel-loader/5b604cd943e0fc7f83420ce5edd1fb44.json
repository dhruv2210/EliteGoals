{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport { clone, isFunction, mix, upperFirst } from '@antv/util';\nimport Theme from '../util/theme';\nimport { getValueByPercent } from '../util/util';\nimport LegendBase from './base';\nvar HANDLER_HEIGHT_RATIO = 1.4;\nvar HANDLER_TRIANGLE_RATIO = 0.4;\nvar ContinueLegend = /** @class */function (_super) {\n  __extends(ContinueLegend, _super);\n  function ContinueLegend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  ContinueLegend.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'continue',\n      min: 0,\n      max: 100,\n      value: null,\n      colors: [],\n      track: {},\n      rail: {},\n      label: {},\n      handler: {},\n      slidable: true,\n      tip: null,\n      step: null,\n      maxWidth: null,\n      maxHeight: null,\n      defaultCfg: {\n        label: {\n          align: 'rail',\n          spacing: 5,\n          formatter: null,\n          style: {\n            fontSize: 12,\n            fill: Theme.textColor,\n            textBaseline: 'middle',\n            fontFamily: Theme.fontFamily\n          }\n        },\n        handler: {\n          size: 10,\n          style: {\n            fill: '#fff',\n            stroke: '#333'\n          }\n        },\n        track: {},\n        rail: {\n          type: 'color',\n          size: 20,\n          defaultLength: 100,\n          style: {\n            fill: '#DCDEE2'\n          }\n        },\n        title: {\n          spacing: 5,\n          style: {\n            fill: Theme.textColor,\n            fontSize: 12,\n            textAlign: 'start',\n            textBaseline: 'top'\n          }\n        }\n      }\n    });\n  };\n  ContinueLegend.prototype.isSlider = function () {\n    return true;\n  };\n  // 实现 IList 接口\n  ContinueLegend.prototype.getValue = function () {\n    return this.getCurrentValue();\n  };\n  ContinueLegend.prototype.getRange = function () {\n    return {\n      min: this.get('min'),\n      max: this.get('max')\n    };\n  };\n  // 改变 range\n  ContinueLegend.prototype.setRange = function (min, max) {\n    this.update({\n      min: min,\n      max: max\n    });\n  };\n  ContinueLegend.prototype.setValue = function (value) {\n    var originValue = this.getValue();\n    this.set('value', value);\n    var group = this.get('group');\n    this.resetTrackClip();\n    if (this.get('slidable')) {\n      this.resetHandlers(group);\n    }\n    this.delegateEmit('valuechanged', {\n      originValue: originValue,\n      value: value\n    });\n  };\n  ContinueLegend.prototype.initEvent = function () {\n    var group = this.get('group');\n    this.bindSliderEvent(group);\n    this.bindRailEvent(group);\n    this.bindTrackEvent(group);\n  };\n  ContinueLegend.prototype.drawLegendContent = function (group) {\n    this.drawRail(group);\n    this.drawLabels(group);\n    this.fixedElements(group); // 调整各个图形位置，适应宽高的限制\n    this.resetTrack(group);\n    this.resetTrackClip(group);\n    if (this.get('slidable')) {\n      this.resetHandlers(group);\n    }\n  };\n  ContinueLegend.prototype.bindSliderEvent = function (group) {\n    this.bindHandlersEvent(group);\n  };\n  ContinueLegend.prototype.bindHandlersEvent = function (group) {\n    var _this = this;\n    group.on('legend-handler-min:drag', function (ev) {\n      var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);\n      var currentValue = _this.getCurrentValue();\n      var maxValue = currentValue[1];\n      if (maxValue < minValue) {\n        // 如果小于最小值，则调整最小值\n        maxValue = minValue;\n      }\n      _this.setValue([minValue, maxValue]);\n    });\n    group.on('legend-handler-max:drag', function (ev) {\n      var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);\n      var currentValue = _this.getCurrentValue();\n      var minValue = currentValue[0];\n      if (minValue > maxValue) {\n        // 如果小于最小值，则调整最小值\n        minValue = maxValue;\n      }\n      _this.setValue([minValue, maxValue]);\n    });\n  };\n  ContinueLegend.prototype.bindRailEvent = function (group) {};\n  ContinueLegend.prototype.bindTrackEvent = function (group) {\n    var _this = this;\n    var prePoint = null;\n    group.on('legend-track:dragstart', function (ev) {\n      prePoint = {\n        x: ev.x,\n        y: ev.y\n      };\n    });\n    group.on('legend-track:drag', function (ev) {\n      if (!prePoint) {\n        return;\n      }\n      var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);\n      var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);\n      var currentValue = _this.getCurrentValue();\n      var curDiff = currentValue[1] - currentValue[0];\n      var range = _this.getRange();\n      var dValue = curValue - preValue;\n      if (dValue < 0) {\n        // 减小, 同时未出边界\n        if (currentValue[0] + dValue > range.min) {\n          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);\n        } else {\n          _this.setValue([range.min, range.min + curDiff]);\n        }\n        //  && ||\n      } else if (dValue > 0) {\n        if (dValue > 0 && currentValue[1] + dValue < range.max) {\n          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);\n        } else {\n          _this.setValue([range.max - curDiff, range.max]);\n        }\n      }\n      prePoint = {\n        x: ev.x,\n        y: ev.y\n      };\n    });\n    group.on('legend-track:dragend', function (ev) {\n      prePoint = null;\n    });\n  };\n  ContinueLegend.prototype.drawLabels = function (group) {\n    this.drawLabel('min', group);\n    this.drawLabel('max', group);\n  };\n  ContinueLegend.prototype.drawLabel = function (name, group) {\n    var labelCfg = this.get('label');\n    var style = labelCfg.style;\n    var labelAlign = labelCfg.align;\n    var labelFormatter = labelCfg.formatter;\n    var value = this.get(name);\n    var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);\n    var localId = \"label-\" + name;\n    this.addShape(group, {\n      type: 'text',\n      id: this.getElementId(localId),\n      name: \"legend-label-\" + name,\n      attrs: __assign(__assign({\n        x: 0,\n        y: 0,\n        text: isFunction(labelFormatter) ? labelFormatter(value) : value\n      }, style), alignAttrs)\n    });\n  };\n  // 获取文本的对齐方式，为了自适应真实操碎了心\n  ContinueLegend.prototype.getLabelAlignAttrs = function (name, align) {\n    var isVertical = this.isVertical();\n    var textAlign = 'center';\n    var textBaseline = 'middle';\n    if (isVertical) {\n      // 垂直布局的所有的文本都左对齐\n      textAlign = 'start';\n      if (align !== 'rail') {\n        if (name === 'min') {\n          textBaseline = 'top';\n        } else {\n          textBaseline = 'bottom';\n        }\n      } else {\n        textBaseline = 'top';\n      }\n    } else {\n      if (align !== 'rail') {\n        textBaseline = 'top';\n        if (name === 'min') {\n          textAlign = 'start';\n        } else {\n          textAlign = 'end';\n        }\n      } else {\n        textAlign = 'start';\n        textBaseline = 'middle';\n      }\n    }\n    return {\n      textAlign: textAlign,\n      textBaseline: textBaseline\n    };\n  };\n  ContinueLegend.prototype.getRailPath = function (x, y, w, h) {\n    var railCfg = this.get('rail');\n    var size = railCfg.size,\n      defaultLength = railCfg.defaultLength,\n      type = railCfg.type;\n    var isVertical = this.isVertical();\n    var length = defaultLength;\n    var width = w;\n    var height = h;\n    if (!width) {\n      width = isVertical ? size : length;\n    }\n    if (!height) {\n      height = isVertical ? length : size;\n    }\n    var path = [];\n    if (type === 'color') {\n      path.push(['M', x, y]);\n      path.push(['L', x + width, y]);\n      path.push(['L', x + width, y + height]);\n      path.push(['L', x, y + height]);\n      path.push(['Z']);\n    } else {\n      path.push(['M', x + width, y]);\n      path.push(['L', x + width, y + height]);\n      path.push(['L', x, y + height]);\n      path.push(['Z']);\n    }\n    return path;\n  };\n  ContinueLegend.prototype.drawRail = function (group) {\n    var railCfg = this.get('rail');\n    var style = railCfg.style;\n    this.addShape(group, {\n      type: 'path',\n      id: this.getElementId('rail'),\n      name: 'legend-rail',\n      attrs: __assign({\n        path: this.getRailPath(0, 0)\n      }, style)\n    });\n  };\n  // 将传入的颜色转换成渐变色\n  ContinueLegend.prototype.getTrackColor = function (colors) {\n    var count = colors.length;\n    if (!count) {\n      return null;\n    }\n    if (count === 1) {\n      return colors[0];\n    }\n    var color; // 最终形态 l(0) 0:colors[0] 0.5:colors[1] 1:colors[2];\n    if (this.isVertical()) {\n      // 根据方向设置渐变方向\n      color = 'l(90)';\n    } else {\n      color = 'l(0)';\n    }\n    for (var i = 0; i < count; i++) {\n      var percent = i / (count - 1);\n      color += \" \" + percent + \":\" + colors[i];\n    }\n    return color;\n  };\n  ContinueLegend.prototype.getTrackPath = function (group) {\n    var railShape = this.getRailShape(group);\n    var path = railShape.attr('path');\n    return clone(path);\n  };\n  ContinueLegend.prototype.getClipTrackAttrs = function (group) {\n    var value = this.getCurrentValue();\n    var min = value[0],\n      max = value[1];\n    var railBBox = this.getRailBBox(group);\n    var startPoint = this.getPointByValue(min, group);\n    var endPoint = this.getPointByValue(max, group);\n    var isVertical = this.isVertical();\n    var x;\n    var y;\n    var width;\n    var height;\n    if (isVertical) {\n      x = railBBox.minX;\n      y = startPoint.y;\n      width = railBBox.width;\n      height = endPoint.y - startPoint.y;\n    } else {\n      x = startPoint.x;\n      y = railBBox.minY;\n      width = endPoint.x - startPoint.x;\n      height = railBBox.height;\n    }\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n  // 获取 track 的属性，由 path 和 颜色构成\n  ContinueLegend.prototype.getTrackAttrs = function (group) {\n    var trackCfg = this.get('track');\n    var colors = this.get('colors');\n    var path = this.getTrackPath(group);\n    return mix({\n      path: path,\n      fill: this.getTrackColor(colors)\n    }, trackCfg.style);\n  };\n  ContinueLegend.prototype.resetTrackClip = function (group) {\n    var container = group || this.get('group');\n    var trackId = this.getElementId('track');\n    var trackShape = container.findById(trackId);\n    var clipShape = trackShape.getClip();\n    var attrs = this.getClipTrackAttrs(group);\n    if (!clipShape) {\n      trackShape.setClip({\n        type: 'rect',\n        attrs: attrs\n      });\n    } else {\n      clipShape.attr(attrs);\n    }\n  };\n  ContinueLegend.prototype.resetTrack = function (group) {\n    var trackId = this.getElementId('track');\n    var trackShape = group.findById(trackId);\n    var trackAttrs = this.getTrackAttrs(group);\n    if (trackShape) {\n      trackShape.attr(trackAttrs);\n    } else {\n      this.addShape(group, {\n        type: 'path',\n        id: trackId,\n        draggable: this.get('slidable'),\n        name: 'legend-track',\n        attrs: trackAttrs\n      });\n    }\n  };\n  ContinueLegend.prototype.getPointByValue = function (value, group) {\n    var _a = this.getRange(),\n      min = _a.min,\n      max = _a.max;\n    var percent = (value - min) / (max - min);\n    var bbox = this.getRailBBox(group);\n    var isVertcal = this.isVertical();\n    var point = {\n      x: 0,\n      y: 0\n    };\n    if (isVertcal) {\n      point.x = bbox.minX + bbox.width / 2;\n      point.y = getValueByPercent(bbox.minY, bbox.maxY, percent);\n    } else {\n      point.x = getValueByPercent(bbox.minX, bbox.maxX, percent);\n      point.y = bbox.minY + bbox.height / 2;\n    }\n    return point;\n  };\n  ContinueLegend.prototype.getRailShape = function (group) {\n    var container = group || this.get('group');\n    return container.findById(this.getElementId('rail'));\n  };\n  // 获取滑轨的宽高信息\n  ContinueLegend.prototype.getRailBBox = function (group) {\n    var railShape = this.getRailShape(group);\n    var bbox = railShape.getBBox();\n    return bbox;\n  };\n  ContinueLegend.prototype.getRailCanvasBBox = function () {\n    var container = this.get('group');\n    var railShape = container.findById(this.getElementId('rail'));\n    var bbox = railShape.getCanvasBBox();\n    return bbox;\n  };\n  // 是否垂直\n  ContinueLegend.prototype.isVertical = function () {\n    return this.get('layout') === 'vertical';\n  };\n  // 用于交互时\n  ContinueLegend.prototype.getValueByCanvasPoint = function (x, y) {\n    var _a = this.getRange(),\n      min = _a.min,\n      max = _a.max;\n    var bbox = this.getRailCanvasBBox(); // 因为 x, y 是画布坐标\n    var isVertcal = this.isVertical();\n    var step = this.get('step');\n    var percent;\n    if (isVertcal) {\n      // 垂直时计算 y\n      percent = (y - bbox.minY) / bbox.height;\n    } else {\n      // 水平时计算 x\n      percent = (x - bbox.minX) / bbox.width;\n    }\n    var value = getValueByPercent(min, max, percent);\n    if (step) {\n      var count = Math.round((value - min) / step);\n      value = min + count * step; // 移动到最近的\n    }\n\n    if (value > max) {\n      value = max;\n    }\n    if (value < min) {\n      value = min;\n    }\n    return value;\n  };\n  // 当前选中的范围\n  ContinueLegend.prototype.getCurrentValue = function () {\n    var value = this.get('value');\n    if (!value) {\n      var values = this.get('values');\n      if (!values) {\n        return [this.get('min'), this.get('max')];\n      }\n      // 如果没有定义，取最大范围  最小值 为 values 中的最小值， 如果最小值 超过了 定义的最大值 则 做限制  最大值 反之\n      return [Math.max(Math.min.apply(Math, __spreadArrays(values, [this.get('max')])), this.get('min')), Math.min(Math.max.apply(Math, __spreadArrays(values, [this.get('min')])), this.get('max'))];\n    }\n    return value;\n  };\n  // 重置滑块 handler\n  ContinueLegend.prototype.resetHandlers = function (group) {\n    var currentValue = this.getCurrentValue();\n    var min = currentValue[0],\n      max = currentValue[1];\n    this.resetHandler(group, 'min', min);\n    this.resetHandler(group, 'max', max);\n  };\n  // 获取滑块的 path\n  ContinueLegend.prototype.getHandlerPath = function (handlerCfg, point) {\n    var isVertical = this.isVertical();\n    var path = [];\n    var width = handlerCfg.size;\n    var x = point.x,\n      y = point.y;\n    var height = width * HANDLER_HEIGHT_RATIO;\n    var halfWidth = width / 2;\n    var oneSixthWidth = width / 6;\n    if (isVertical) {\n      /**\n       * 竖直情况下的滑块 handler，左侧顶点是 x,y\n       *  /----|\n       *    -- |\n       *    -- |\n       *  \\----|\n       */\n      var triangleX = x + height * HANDLER_TRIANGLE_RATIO;\n      path.push(['M', x, y]);\n      path.push(['L', triangleX, y + halfWidth]);\n      path.push(['L', x + height, y + halfWidth]);\n      path.push(['L', x + height, y - halfWidth]);\n      path.push(['L', triangleX, y - halfWidth]);\n      path.push(['Z']);\n      // 绘制两条横线\n      path.push(['M', triangleX, y + oneSixthWidth]);\n      path.push(['L', x + height - 2, y + oneSixthWidth]);\n      path.push(['M', triangleX, y - oneSixthWidth]);\n      path.push(['L', x + height - 2, y - oneSixthWidth]);\n    } else {\n      /**\n       * 水平情况下的滑块，上面顶点处是 x,y\n       *  /   \\\n       * | | | |\n       * | | | |\n       *  -----\n       */\n      var triangleY = y + height * HANDLER_TRIANGLE_RATIO;\n      path.push(['M', x, y]);\n      path.push(['L', x - halfWidth, triangleY]);\n      path.push(['L', x - halfWidth, y + height]);\n      path.push(['L', x + halfWidth, y + height]);\n      path.push(['L', x + halfWidth, triangleY]);\n      path.push(['Z']);\n      // 绘制两条竖线\n      path.push(['M', x - oneSixthWidth, triangleY]);\n      path.push(['L', x - oneSixthWidth, y + height - 2]);\n      path.push(['M', x + oneSixthWidth, triangleY]);\n      path.push(['L', x + oneSixthWidth, y + height - 2]);\n    }\n    return path;\n  };\n  // 调整 handler 的位置，如果未存在则绘制\n  ContinueLegend.prototype.resetHandler = function (group, name, value) {\n    var point = this.getPointByValue(value, group);\n    var handlerCfg = this.get('handler');\n    var path = this.getHandlerPath(handlerCfg, point);\n    var id = this.getElementId(\"handler-\" + name);\n    var handlerShape = group.findById(id);\n    var isVertical = this.isVertical();\n    if (handlerShape) {\n      handlerShape.attr('path', path);\n    } else {\n      this.addShape(group, {\n        type: 'path',\n        name: \"legend-handler-\" + name,\n        draggable: true,\n        id: id,\n        attrs: __assign(__assign({\n          path: path\n        }, handlerCfg.style), {\n          cursor: isVertical ? 'ns-resize' : 'ew-resize'\n        })\n      });\n    }\n  };\n  // 当设置了 maxWidth, maxHeight 时调整 rail 的宽度，\n  // 文本的位置\n  ContinueLegend.prototype.fixedElements = function (group) {\n    var railShape = group.findById(this.getElementId('rail'));\n    var minLabel = group.findById(this.getElementId('label-min'));\n    var maxLabel = group.findById(this.getElementId('label-max'));\n    var startPoint = this.getDrawPoint();\n    if (this.isVertical()) {\n      // 横向布局\n      this.fixedVertail(minLabel, maxLabel, railShape, startPoint);\n    } else {\n      // 水平布局\n      this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);\n    }\n  };\n  ContinueLegend.prototype.fitRailLength = function (minLabelBBox, maxLabelBBox, railBBox, railShape) {\n    var isVertical = this.isVertical();\n    var lengthField = isVertical ? 'height' : 'width';\n    var labelCfg = this.get('label');\n    var labelAlign = labelCfg.align;\n    var spacing = labelCfg.spacing;\n    var maxLength = this.get(\"max\" + upperFirst(lengthField)); // get('maxWidth')\n    if (maxLength) {\n      var elementsLength = labelAlign === 'rail' ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];\n      var diff = elementsLength - maxLength;\n      if (diff > 0) {\n        // 大于限制的长度\n        this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff);\n      }\n    }\n  };\n  ContinueLegend.prototype.changeRailLength = function (railShape, lengthField, length) {\n    var bbox = railShape.getBBox();\n    var path;\n    if (lengthField === 'height') {\n      path = this.getRailPath(bbox.x, bbox.y, bbox.width, length);\n    } else {\n      path = this.getRailPath(bbox.x, bbox.y, length, bbox.height);\n    }\n    railShape.attr('path', path);\n  };\n  ContinueLegend.prototype.changeRailPosition = function (railShape, x, y) {\n    var bbox = railShape.getBBox();\n    var path = this.getRailPath(x, y, bbox.width, bbox.height);\n    railShape.attr('path', path);\n  };\n  ContinueLegend.prototype.fixedHorizontal = function (minLabel, maxLabel, railShape, startPoint) {\n    var labelCfg = this.get('label');\n    var labelAlign = labelCfg.align;\n    var spacing = labelCfg.spacing;\n    var railBBox = railShape.getBBox();\n    var minLabelBBox = minLabel.getBBox();\n    var maxLabelBBox = maxLabel.getBBox();\n    var railHeight = railBBox.height; // 取 rail 的高度，作为高度\n    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);\n    railBBox = railShape.getBBox();\n    if (labelAlign === 'rail') {\n      // 沿着 rail 方向\n      minLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y + railHeight / 2\n      });\n      this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);\n      maxLabel.attr({\n        x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,\n        y: startPoint.y + railHeight / 2\n      });\n    } else if (labelAlign === 'top') {\n      minLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y\n      });\n      maxLabel.attr({\n        x: startPoint.x + railBBox.width,\n        y: startPoint.y\n      });\n      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);\n    } else {\n      this.changeRailPosition(railShape, startPoint.x, startPoint.y);\n      minLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y + railBBox.height + spacing\n      });\n      maxLabel.attr({\n        x: startPoint.x + railBBox.width,\n        y: startPoint.y + railBBox.height + spacing\n      });\n    }\n  };\n  ContinueLegend.prototype.fixedVertail = function (minLabel, maxLabel, railShape, startPoint) {\n    var labelCfg = this.get('label');\n    var labelAlign = labelCfg.align;\n    var spacing = labelCfg.spacing;\n    var railBBox = railShape.getBBox();\n    var minLabelBBox = minLabel.getBBox();\n    var maxLabelBBox = maxLabel.getBBox();\n    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);\n    railBBox = railShape.getBBox();\n    if (labelAlign === 'rail') {\n      // 沿着 rail 方向\n      minLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y\n      });\n      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);\n      maxLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2\n      });\n    } else if (labelAlign === 'right') {\n      minLabel.attr({\n        x: startPoint.x + railBBox.width + spacing,\n        y: startPoint.y\n      });\n      this.changeRailPosition(railShape, startPoint.x, startPoint.y);\n      maxLabel.attr({\n        x: startPoint.x + railBBox.width + spacing,\n        y: startPoint.y + railBBox.height\n      });\n    } else {\n      // left\n      var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);\n      minLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y\n      });\n      this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);\n      maxLabel.attr({\n        x: startPoint.x,\n        y: startPoint.y + railBBox.height\n      });\n    }\n  };\n  return ContinueLegend;\n}(LegendBase);\nexport default ContinueLegend;","map":null,"metadata":{},"sourceType":"module"}