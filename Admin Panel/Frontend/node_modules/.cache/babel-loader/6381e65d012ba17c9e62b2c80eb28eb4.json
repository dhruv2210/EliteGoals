{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { each, every, find, findIndex, get, isBoolean, isEqual, isObject } from '@antv/util';\nimport { animation as commonAnimation, annotation as commonAnnotation, interaction as commonInteraction, limitInPlot as commonLimitInPlot, scale, theme as commonTheme } from '../../adaptor/common';\nimport { deepAssign, flow } from '../../utils';\nimport { percent } from '../../utils/transform/percent';\nimport { findViewById } from '../../utils/view';\nimport { LEFT_AXES_VIEW, RIGHT_AXES_VIEW } from './constant';\nimport { AxisType, DualAxesGeometry } from './types';\nimport { drawSingleGeometry } from './util/geometry';\nimport { getViewLegendItems } from './util/legend';\nimport { getGeometryOption, getYAxisWithDefault, isColumn, transformObjectToArray } from './util/option';\nimport { doSliderFilter } from './util/render-sider';\n/**\n * transformOptions，双轴图整体的取参逻辑如下\n * 1. get index getOptions: 对应的是默认的图表参数，如 appendPadding，syncView 等\n * 2. get adpator transformOption: 对应的是双轴图的默认参数，deepAssign 优先级从低到高如下\n *    2.1 defaultoption，如 tooltip，legend\n *    2.2 用户填写 options\n *    2.3 根据用户填写的 options 补充的数组型 options，如 yaxis，GeometryOption，因为 deepAssign 无法 assign 数组\n *\n * @param params\n */\nexport function transformOptions(params) {\n  var _a;\n  var options = params.options;\n  var _b = options.geometryOptions,\n    geometryOptions = _b === void 0 ? [] : _b,\n    xField = options.xField,\n    yField = options.yField;\n  var allLine = every(geometryOptions, function (_a) {\n    var geometry = _a.geometry;\n    return geometry === DualAxesGeometry.Line || geometry === undefined;\n  });\n  return deepAssign({}, {\n    options: {\n      geometryOptions: [],\n      meta: (_a = {}, _a[xField] = {\n        // 默认为 cat 类型\n        type: 'cat',\n        // x 轴一定是同步 scale 的\n        sync: true,\n        // 如果有没有柱子，则\n        range: allLine ? [0, 1] : undefined\n      }, _a),\n      tooltip: {\n        showMarkers: allLine,\n        // 存在柱状图，不显示 crosshairs\n        showCrosshairs: allLine,\n        shared: true,\n        crosshairs: {\n          type: 'x'\n        }\n      },\n      interactions: !allLine ? [{\n        type: 'legend-visible-filter'\n      }, {\n        type: 'active-region'\n      }] : [{\n        type: 'legend-visible-filter'\n      }],\n      legend: {\n        position: 'top-left'\n      }\n    }\n  }, params, {\n    options: {\n      // yAxis\n      yAxis: transformObjectToArray(yField, options.yAxis),\n      // geometryOptions\n      geometryOptions: [getGeometryOption(xField, yField[0], geometryOptions[0]), getGeometryOption(xField, yField[1], geometryOptions[1])],\n      // annotations\n      annotations: transformObjectToArray(yField, options.annotations)\n    }\n  });\n}\n/**\n * 创建 双轴图 中绘制图形的 view，提前创建是因为 theme 适配器的需要\n * @param params\n */\nfunction createViews(params) {\n  var _a, _b;\n  var chart = params.chart,\n    options = params.options;\n  var geometryOptions = options.geometryOptions;\n  var SORT_MAP = {\n    line: 0,\n    column: 1\n  };\n  // 包含配置，id，数据的结构\n  var geometries = [{\n    type: (_a = geometryOptions[0]) === null || _a === void 0 ? void 0 : _a.geometry,\n    id: LEFT_AXES_VIEW\n  }, {\n    type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry,\n    id: RIGHT_AXES_VIEW\n  }];\n  // 将线的 view 放置在更上一层，防止线柱遮挡。先柱后先\n  geometries.sort(function (a, b) {\n    return -SORT_MAP[a.type] + SORT_MAP[b.type];\n  }).forEach(function (g) {\n    return chart.createView({\n      id: g.id\n    });\n  });\n  return params;\n}\n/**\n * 绘制图形\n * @param params\n */\nfunction geometry(params) {\n  var chart = params.chart,\n    options = params.options;\n  var xField = options.xField,\n    yField = options.yField,\n    geometryOptions = options.geometryOptions,\n    data = options.data,\n    tooltip = options.tooltip;\n  // 包含配置，id，数据的结构\n  var geometries = [__assign(__assign({}, geometryOptions[0]), {\n    id: LEFT_AXES_VIEW,\n    data: data[0],\n    yField: yField[0]\n  }), __assign(__assign({}, geometryOptions[1]), {\n    id: RIGHT_AXES_VIEW,\n    data: data[1],\n    yField: yField[1]\n  })];\n  geometries.forEach(function (geometry) {\n    var id = geometry.id,\n      data = geometry.data,\n      yField = geometry.yField;\n    // 百分比柱状图需要额外处理一次数据\n    var isPercent = isColumn(geometry) && geometry.isPercent;\n    var formatData = isPercent ? percent(data, yField, xField, yField) : data;\n    var view = findViewById(chart, id).data(formatData);\n    var tooltipOptions = isPercent ? __assign({\n      formatter: function formatter(datum) {\n        return {\n          name: datum[geometry.seriesField] || yField,\n          value: (Number(datum[yField]) * 100).toFixed(2) + '%'\n        };\n      }\n    }, tooltip) : tooltip;\n    // 绘制图形\n    drawSingleGeometry({\n      chart: view,\n      options: {\n        xField: xField,\n        yField: yField,\n        tooltip: tooltipOptions,\n        geometryOption: geometry\n      }\n    });\n  });\n  return params;\n}\nexport function color(params) {\n  var _a;\n  var chart = params.chart,\n    options = params.options;\n  var geometryOptions = options.geometryOptions;\n  var themeColor = ((_a = chart.getTheme()) === null || _a === void 0 ? void 0 : _a.colors10) || [];\n  var start = 0;\n  /* 为 geometry 添加默认 color。\n   * 1. 若 geometryOptions 存在 color，则在 drawGeometry 时已处理\n   * 2. 若 不存在 color，获取 Geometry group scales个数，在 theme color 10 中提取\n   * 3. 为防止 group 过多导致右色板无值或值很少，右 view 面板在依次提取剩下的 N 个 后再 concat 一次 themeColor\n   * 4. 为简便获取 Geometry group scales个数，在绘制完后再执行 color\n   * 5. 考虑之后将不同 view 使用同一个色板的需求沉淀到 g2\n   */\n  chart.once('beforepaint', function () {\n    each(geometryOptions, function (geometryOption, index) {\n      var view = findViewById(chart, index === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);\n      if (geometryOption.color) return;\n      var groupScale = view.getGroupScales();\n      var count = get(groupScale, [0, 'values', 'length'], 1);\n      var color = themeColor.slice(start, start + count).concat(index === 0 ? [] : themeColor);\n      view.geometries.forEach(function (geometry) {\n        if (geometryOption.seriesField) {\n          geometry.color(geometryOption.seriesField, color);\n        } else {\n          geometry.color(color[0]);\n        }\n      });\n      start += count;\n    });\n    chart.render(true);\n  });\n  return params;\n}\n/**\n * meta 配置\n * @param params\n */\nexport function meta(params) {\n  var _a, _b;\n  var chart = params.chart,\n    options = params.options;\n  var xAxis = options.xAxis,\n    yAxis = options.yAxis,\n    xField = options.xField,\n    yField = options.yField;\n  scale((_a = {}, _a[xField] = xAxis, _a[yField[0]] = yAxis[0], _a))(deepAssign({}, params, {\n    chart: findViewById(chart, LEFT_AXES_VIEW)\n  }));\n  scale((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))(deepAssign({}, params, {\n    chart: findViewById(chart, RIGHT_AXES_VIEW)\n  }));\n  return params;\n}\n/**\n * axis 配置\n * @param params\n */\nexport function axis(params) {\n  var chart = params.chart,\n    options = params.options;\n  var leftView = findViewById(chart, LEFT_AXES_VIEW);\n  var rightView = findViewById(chart, RIGHT_AXES_VIEW);\n  var xField = options.xField,\n    yField = options.yField,\n    xAxis = options.xAxis,\n    yAxis = options.yAxis;\n  chart.axis(xField, false);\n  chart.axis(yField[0], false);\n  chart.axis(yField[1], false);\n  // 左 View\n  leftView.axis(xField, xAxis);\n  leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));\n  // 右 Y 轴\n  rightView.axis(xField, false);\n  rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));\n  return params;\n}\n/**\n * tooltip 配置\n * @param params\n */\nexport function tooltip(params) {\n  var chart = params.chart,\n    options = params.options;\n  var tooltip = options.tooltip;\n  var leftView = findViewById(chart, LEFT_AXES_VIEW);\n  var rightView = findViewById(chart, RIGHT_AXES_VIEW);\n  // tooltip 经过 getDefaultOption 处理后，一定不为 undefined\n  chart.tooltip(tooltip);\n  // 在 view 上添加 tooltip，使得 shared 和 interaction active-region 起作用\n  // view 应该继承 chart 里的 shared，但是从表现看来，继承有点问题\n  leftView.tooltip({\n    shared: true\n  });\n  rightView.tooltip({\n    shared: true\n  });\n  return params;\n}\n/**\n * interaction 配置\n * @param params\n */\nexport function interaction(params) {\n  var chart = params.chart;\n  commonInteraction(deepAssign({}, params, {\n    chart: findViewById(chart, LEFT_AXES_VIEW)\n  }));\n  commonInteraction(deepAssign({}, params, {\n    chart: findViewById(chart, RIGHT_AXES_VIEW)\n  }));\n  return params;\n}\n/**\n * annotation 配置\n * @param params\n */\nexport function annotation(params) {\n  var chart = params.chart,\n    options = params.options;\n  var annotations = options.annotations;\n  var a1 = get(annotations, [0]);\n  var a2 = get(annotations, [1]);\n  commonAnnotation(a1)(deepAssign({}, params, {\n    chart: findViewById(chart, LEFT_AXES_VIEW),\n    options: {\n      annotations: a1\n    }\n  }));\n  commonAnnotation(a2)(deepAssign({}, params, {\n    chart: findViewById(chart, RIGHT_AXES_VIEW),\n    options: {\n      annotations: a2\n    }\n  }));\n  return params;\n}\nexport function theme(params) {\n  var chart = params.chart;\n  /*\n   * 双轴图中，部分组件是绘制在子 view 层（例如 axis，line），部分组件是绘制在 chart （例如 legend)\n   * 为 chart 和 子 view 均注册 theme，使其自行遵循 G2 theme geometry > view > chart 进行渲染。\n   */\n  commonTheme(deepAssign({}, params, {\n    chart: findViewById(chart, LEFT_AXES_VIEW)\n  }));\n  commonTheme(deepAssign({}, params, {\n    chart: findViewById(chart, RIGHT_AXES_VIEW)\n  }));\n  commonTheme(params);\n  return params;\n}\nexport function animation(params) {\n  var chart = params.chart;\n  commonAnimation(deepAssign({}, params, {\n    chart: findViewById(chart, LEFT_AXES_VIEW)\n  }));\n  commonAnimation(deepAssign({}, params, {\n    chart: findViewById(chart, RIGHT_AXES_VIEW)\n  }));\n  return params;\n}\n/**\n * 双轴图 limitInPlot\n * @param params\n */\nexport function limitInPlot(params) {\n  var chart = params.chart,\n    options = params.options;\n  var yAxis = options.yAxis;\n  commonLimitInPlot(deepAssign({}, params, {\n    chart: findViewById(chart, LEFT_AXES_VIEW),\n    options: {\n      yAxis: yAxis[0]\n    }\n  }));\n  commonLimitInPlot(deepAssign({}, params, {\n    chart: findViewById(chart, RIGHT_AXES_VIEW),\n    options: {\n      yAxis: yAxis[1]\n    }\n  }));\n  return params;\n}\n/**\n * legend 配置\n * 使用 custom，便于和类似于分组柱状图-单折线图的逻辑统一\n * @param params\n */\nexport function legend(params) {\n  var chart = params.chart,\n    options = params.options;\n  var legend = options.legend,\n    geometryOptions = options.geometryOptions,\n    yField = options.yField,\n    data = options.data;\n  var leftView = findViewById(chart, LEFT_AXES_VIEW);\n  var rightView = findViewById(chart, RIGHT_AXES_VIEW);\n  if (legend === false) {\n    chart.legend(false);\n  } else if (isObject(legend) && legend.custom === true) {\n    chart.legend(legend);\n  } else {\n    var leftLegend_1 = get(geometryOptions, [0, 'legend'], legend);\n    var rightLegend_1 = get(geometryOptions, [1, 'legend'], legend);\n    // 均使用自定义图例\n    chart.once('beforepaint', function () {\n      var leftItems = data[0].length ? getViewLegendItems({\n        view: leftView,\n        geometryOption: geometryOptions[0],\n        yField: yField[0],\n        legend: leftLegend_1\n      }) : [];\n      var rightItems = data[1].length ? getViewLegendItems({\n        view: rightView,\n        geometryOption: geometryOptions[1],\n        yField: yField[1],\n        legend: rightLegend_1\n      }) : [];\n      chart.legend(deepAssign({}, legend, {\n        custom: true,\n        // todo 修改类型定义\n        // @ts-ignore\n        items: leftItems.concat(rightItems)\n      }));\n    });\n    if (geometryOptions[0].seriesField) {\n      leftView.legend(geometryOptions[0].seriesField, leftLegend_1);\n    }\n    if (geometryOptions[1].seriesField) {\n      rightView.legend(geometryOptions[1].seriesField, rightLegend_1);\n    }\n    // 自定义图例交互\n    chart.on('legend-item:click', function (evt) {\n      var delegateObject = get(evt, 'gEvent.delegateObject', {});\n      if (delegateObject && delegateObject.item) {\n        var _a = delegateObject.item,\n          field_1 = _a.value,\n          isGeometry = _a.isGeometry,\n          viewId = _a.viewId;\n        // geometry 的时候，直接使用 view.changeVisible\n        if (isGeometry) {\n          var idx = findIndex(yField, function (yF) {\n            return yF === field_1;\n          });\n          if (idx > -1) {\n            var geometries = get(findViewById(chart, viewId), 'geometries');\n            each(geometries, function (g) {\n              g.changeVisible(!delegateObject.item.unchecked);\n            });\n          }\n        } else {\n          var legendItem_1 = get(chart.getController('legend'), 'option.items', []);\n          // 分组柱线图\n          each(chart.views, function (view) {\n            // 单折柱图\n            var groupScale = view.getGroupScales();\n            each(groupScale, function (scale) {\n              if (scale.values && scale.values.indexOf(field_1) > -1) {\n                view.filter(scale.field, function (value) {\n                  var curLegendItem = find(legendItem_1, function (item) {\n                    return item.value === value;\n                  });\n                  // 使用 legend 中的 unchecked 来判断，使得支持关闭多个图例\n                  return !curLegendItem.unchecked;\n                });\n              }\n            });\n            chart.render(true);\n          });\n        }\n      }\n    });\n  }\n  return params;\n}\n/**\n * 双轴图 slider 适配器\n * @param params\n */\nexport function slider(params) {\n  var chart = params.chart,\n    options = params.options;\n  var slider = options.slider;\n  var leftView = findViewById(chart, LEFT_AXES_VIEW);\n  var rightView = findViewById(chart, RIGHT_AXES_VIEW);\n  if (slider) {\n    // 左 View\n    leftView.option('slider', slider);\n    // 监听左侧 slider 改变事件， 同步右侧 View 视图\n    leftView.on('slider:valuechanged', function (evt) {\n      var _a = evt.event,\n        value = _a.value,\n        originValue = _a.originValue;\n      if (isEqual(value, originValue)) {\n        return;\n      }\n      doSliderFilter(rightView, value);\n    });\n    chart.once('afterpaint', function () {\n      // 初始化数据，配置默认值时需要同步\n      if (!isBoolean(slider)) {\n        var start = slider.start,\n          end = slider.end;\n        if (start || end) {\n          doSliderFilter(rightView, [start, end]);\n        }\n      }\n    });\n  }\n  return params;\n}\n/**\n * 双折线图适配器\n * @param chart\n * @param options\n */\nexport function adaptor(params) {\n  // transformOptions 一定在最前面处理；color legend 使用了 beforepaint，为便于理解放在最后面\n  return flow(transformOptions, createViews,\n  // 主题靠前设置，作为最低优先级\n  theme, geometry, meta, axis, limitInPlot, tooltip, interaction, annotation, animation, color, legend, slider)(params);\n}","map":null,"metadata":{},"sourceType":"module"}