{"ast":null,"code":"import { __assign, __extends, __read, __rest, __values } from \"tslib\";\nimport { contains, deepMix, each, get, isArray, isFunction, isNil, isString, keys, upperFirst, find, includes } from '@antv/util';\nimport { Annotation as AnnotationComponent } from '../../dependents';\nimport { DEFAULT_ANIMATE_CFG } from '../../animate/';\nimport { COMPONENT_TYPE, DIRECTION, GEOMETRY_LIFE_CIRCLE, LAYER, VIEW_LIFE_CIRCLE } from '../../constant';\nimport { getAngleByPoint, getDistanceToCenter } from '../../util/coordinate';\nimport { omit } from '../../util/helper';\nimport { getNormalizedValue } from '../../util/annotation';\nimport { Controller } from './base';\n/** 需要在图形绘制完成后才渲染的辅助组件类型列表 */\nvar ANNOTATIONS_AFTER_RENDER = ['regionFilter', 'shape'];\n/**\n * Annotation controller, 主要作用:\n * 1. 创建 Annotation: line、text、arc ...\n * 2. 生命周期: init、layout、render、clear、destroy\n */\nvar Annotation = /** @class */function (_super) {\n  __extends(Annotation, _super);\n  function Annotation(view) {\n    var _this = _super.call(this, view) || this;\n    /* 组件更新的 cache，组件配置 object : 组件 */\n    _this.cache = new Map();\n    _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();\n    _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();\n    _this.option = [];\n    return _this;\n  }\n  Object.defineProperty(Annotation.prototype, \"name\", {\n    get: function get() {\n      return 'annotation';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Annotation.prototype.init = function () {};\n  /**\n   * 因为 annotation 需要依赖坐标系信息，所以 render 阶段为空方法，实际的创建逻辑都在 layout 中\n   */\n  Annotation.prototype.layout = function () {\n    this.update();\n  };\n  // 因为 Annotation 不参与布局，但是渲染的位置依赖于坐标系，所以可以将绘制阶段延迟到 layout() 进行\n  Annotation.prototype.render = function () {};\n  /**\n   * 更新\n   */\n  Annotation.prototype.update = function () {\n    var _this = this;\n    // 1. 先处理需要在图形渲染之后的辅助组件 需要在 Geometry 完成之后，拿到图形信息\n    this.onAfterRender(function () {\n      var updated = new Map();\n      // 先看是否有 regionFilter/shape 要更新\n      each(_this.option, function (option) {\n        if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n          var co = _this.updateOrCreate(option);\n          // 存储已经处理过的\n          if (co) {\n            updated.set(_this.getCacheKey(option), co);\n          }\n        }\n      });\n      // 处理完成之后，更新 cache\n      // 处理完成之后，销毁删除的\n      _this.cache = _this.syncCache(updated);\n    });\n    // 2. 处理非 regionFilter\n    var updateCache = new Map();\n    each(this.option, function (option) {\n      if (!includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n        var co = _this.updateOrCreate(option);\n        // 存储已经处理过的\n        if (co) {\n          updateCache.set(_this.getCacheKey(option), co);\n        }\n      }\n    });\n    this.cache = this.syncCache(updateCache);\n  };\n  /**\n   * 清空\n   * @param includeOption 是否清空 option 配置项\n   */\n  Annotation.prototype.clear = function (includeOption) {\n    if (includeOption === void 0) {\n      includeOption = false;\n    }\n    _super.prototype.clear.call(this);\n    this.clearComponents();\n    this.foregroundContainer.clear();\n    this.backgroundContainer.clear();\n    // clear all option\n    if (includeOption) {\n      this.option = [];\n    }\n  };\n  Annotation.prototype.destroy = function () {\n    this.clear(true);\n    this.foregroundContainer.remove(true);\n    this.backgroundContainer.remove(true);\n  };\n  /**\n   * 复写基类的方法\n   */\n  Annotation.prototype.getComponents = function () {\n    var co = [];\n    this.cache.forEach(function (value) {\n      co.push(value);\n    });\n    return co;\n  };\n  /**\n   * 清除当前的组件\n   */\n  Annotation.prototype.clearComponents = function () {\n    this.getComponents().forEach(function (co) {\n      co.component.destroy();\n    });\n    this.cache.clear();\n  };\n  /**\n   * region filter 比较特殊的渲染时机\n   * @param doWhat\n   */\n  Annotation.prototype.onAfterRender = function (doWhat) {\n    var done = false;\n    if (this.view.getOptions().animate) {\n      this.view.geometries.forEach(function (g) {\n        // 如果 geometry 开启，则监听\n        if (g.animateOption) {\n          g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function () {\n            doWhat();\n          });\n          done = true;\n        }\n      });\n    }\n    if (!done) {\n      this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function () {\n        doWhat();\n      });\n    }\n  };\n  Annotation.prototype.createAnnotation = function (option) {\n    var type = option.type;\n    var Ctor = AnnotationComponent[upperFirst(type)];\n    if (Ctor) {\n      var theme = this.getAnnotationTheme(type);\n      var cfg = this.getAnnotationCfg(type, option, theme);\n      // 不创建\n      if (!cfg) {\n        return null;\n      }\n      var annotation = new Ctor(cfg);\n      return {\n        component: annotation,\n        layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,\n        direction: DIRECTION.NONE,\n        type: COMPONENT_TYPE.ANNOTATION,\n        extra: option\n      };\n    }\n  };\n  // APIs for creating annotation component\n  Annotation.prototype.annotation = function (option) {\n    this.option.push(option);\n  };\n  /**\n   * 创建 Arc\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.arc = function (option) {\n    this.annotation(__assign({\n      type: 'arc'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 image\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.image = function (option) {\n    this.annotation(__assign({\n      type: 'image'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 Line\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.line = function (option) {\n    this.annotation(__assign({\n      type: 'line'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 Region\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.region = function (option) {\n    this.annotation(__assign({\n      type: 'region'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 Text\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.text = function (option) {\n    this.annotation(__assign({\n      type: 'text'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 DataMarker\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.dataMarker = function (option) {\n    this.annotation(__assign({\n      type: 'dataMarker'\n    }, option));\n    return this;\n  };\n  /**\n   * 创建 DataRegion\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.dataRegion = function (option) {\n    this.annotation(__assign({\n      type: 'dataRegion'\n    }, option));\n  };\n  /**\n   * 创建 RegionFilter\n   * @param option\n   * @returns AnnotationController\n   */\n  Annotation.prototype.regionFilter = function (option) {\n    this.annotation(__assign({\n      type: 'regionFilter'\n    }, option));\n  };\n  /**\n   * 创建 ShapeAnnotation\n   * @param option\n   */\n  Annotation.prototype.shape = function (option) {\n    this.annotation(__assign({\n      type: 'shape'\n    }, option));\n  };\n  /**\n   * 创建 HtmlAnnotation\n   * @param option\n   */\n  Annotation.prototype.html = function (option) {\n    this.annotation(__assign({\n      type: 'html'\n    }, option));\n  };\n  // end API\n  /**\n   * parse the point position to [x, y]\n   * @param p Position\n   * @returns { x, y }\n   */\n  Annotation.prototype.parsePosition = function (p) {\n    var e_1, _a;\n    var xScale = this.view.getXScale();\n    // 转成 object\n    var yScales = this.view.getScalesByDim('y');\n    var position = isFunction(p) ? p.call(null, xScale, yScales) : p;\n    var x = 0;\n    var y = 0;\n    // 入参是 [24, 24] 这类时\n    if (isArray(position)) {\n      var _b = __read(position, 2),\n        xPos = _b[0],\n        yPos = _b[1];\n      // 如果数据格式是 ['50%', '50%'] 的格式\n      // fix: 原始数据中可能会包含 'xxx5%xxx' 这样的数据，需要判断下 https://github.com/antvis/f2/issues/590\n      // @ts-ignore\n      if (isString(xPos) && xPos.indexOf('%') !== -1 && !isNaN(xPos.slice(0, -1))) {\n        return this.parsePercentPosition(position);\n      }\n      x = getNormalizedValue(xPos, xScale);\n      y = getNormalizedValue(yPos, Object.values(yScales)[0]);\n    } else if (!isNil(position)) {\n      try {\n        // 入参是 object 结构，数据点\n        for (var _c = __values(keys(position)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var key = _d.value;\n          var value = position[key];\n          if (key === xScale.field) {\n            x = getNormalizedValue(value, xScale);\n          }\n          if (yScales[key]) {\n            y = getNormalizedValue(value, yScales[key]);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    if (isNaN(x) || isNaN(y)) {\n      return null;\n    }\n    return this.view.getCoordinate().convert({\n      x: x,\n      y: y\n    });\n  };\n  /**\n   * parse all the points between start and end\n   * @param start\n   * @param end\n   * @return Point[]\n   */\n  Annotation.prototype.getRegionPoints = function (start, end) {\n    var _this = this;\n    var xScale = this.view.getXScale();\n    var yScales = this.view.getScalesByDim('y');\n    var yScale = Object.values(yScales)[0];\n    var xField = xScale.field;\n    var viewData = this.view.getData();\n    var startXValue = isArray(start) ? start[0] : start[xField];\n    var endXValue = isArray(end) ? end[0] : end[xField];\n    var arr = [];\n    var startIndex;\n    each(viewData, function (item, idx) {\n      if (item[xField] === startXValue) {\n        startIndex = idx;\n      }\n      if (idx >= startIndex) {\n        var point = _this.parsePosition([item[xField], item[yScale.field]]);\n        if (point) {\n          arr.push(point);\n        }\n      }\n      if (item[xField] === endXValue) {\n        return false;\n      }\n    });\n    return arr;\n  };\n  /**\n   * parse percent position\n   * @param position\n   */\n  Annotation.prototype.parsePercentPosition = function (position) {\n    var xPercent = parseFloat(position[0]) / 100;\n    var yPercent = parseFloat(position[1]) / 100;\n    var coordinate = this.view.getCoordinate();\n    var start = coordinate.start,\n      end = coordinate.end;\n    var topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y)\n    };\n    var x = coordinate.getWidth() * xPercent + topLeft.x;\n    var y = coordinate.getHeight() * yPercent + topLeft.y;\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * get coordinate bbox\n   */\n  Annotation.prototype.getCoordinateBBox = function () {\n    var coordinate = this.view.getCoordinate();\n    var start = coordinate.start,\n      end = coordinate.end;\n    var width = coordinate.getWidth();\n    var height = coordinate.getHeight();\n    var topLeft = {\n      x: Math.min(start.x, end.x),\n      y: Math.min(start.y, end.y)\n    };\n    return {\n      x: topLeft.x,\n      y: topLeft.y,\n      minX: topLeft.x,\n      minY: topLeft.y,\n      maxX: topLeft.x + width,\n      maxY: topLeft.y + height,\n      width: width,\n      height: height\n    };\n  };\n  /**\n   * get annotation component config by different type\n   * @param type\n   * @param option 用户的配置\n   * @param theme\n   */\n  Annotation.prototype.getAnnotationCfg = function (type, option, theme) {\n    var _this = this;\n    var coordinate = this.view.getCoordinate();\n    var canvas = this.view.getCanvas();\n    var o = {};\n    if (isNil(option)) {\n      return null;\n    }\n    var start = option.start,\n      end = option.end,\n      position = option.position;\n    var sp = this.parsePosition(start);\n    var ep = this.parsePosition(end);\n    var textPoint = this.parsePosition(position);\n    if (['arc', 'image', 'line', 'region', 'regionFilter'].includes(type) && (!sp || !ep)) {\n      return null;\n    } else if (['text', 'dataMarker', 'html'].includes(type) && !textPoint) {\n      return null;\n    }\n    if (type === 'arc') {\n      var _a = option,\n        start_1 = _a.start,\n        end_1 = _a.end,\n        rest = __rest(_a, [\"start\", \"end\"]);\n      var startAngle = getAngleByPoint(coordinate, sp);\n      var endAngle = getAngleByPoint(coordinate, ep);\n      if (startAngle > endAngle) {\n        endAngle = Math.PI * 2 + endAngle;\n      }\n      o = __assign(__assign({}, rest), {\n        center: coordinate.getCenter(),\n        radius: getDistanceToCenter(coordinate, sp),\n        startAngle: startAngle,\n        endAngle: endAngle\n      });\n    } else if (type === 'image') {\n      var _b = option,\n        start_2 = _b.start,\n        end_2 = _b.end,\n        rest = __rest(_b, [\"start\", \"end\"]);\n      o = __assign(__assign({}, rest), {\n        start: sp,\n        end: ep,\n        src: option.src\n      });\n    } else if (type === 'line') {\n      var _c = option,\n        start_3 = _c.start,\n        end_3 = _c.end,\n        rest = __rest(_c, [\"start\", \"end\"]);\n      o = __assign(__assign({}, rest), {\n        start: sp,\n        end: ep,\n        text: get(option, 'text', null)\n      });\n    } else if (type === 'region') {\n      var _d = option,\n        start_4 = _d.start,\n        end_4 = _d.end,\n        rest = __rest(_d, [\"start\", \"end\"]);\n      o = __assign(__assign({}, rest), {\n        start: sp,\n        end: ep\n      });\n    } else if (type === 'text') {\n      var filteredData = this.view.getData();\n      var _e = option,\n        position_1 = _e.position,\n        content = _e.content,\n        rest = __rest(_e, [\"position\", \"content\"]);\n      var textContent = content;\n      if (isFunction(content)) {\n        textContent = content(filteredData);\n      }\n      o = __assign(__assign(__assign({}, textPoint), rest), {\n        content: textContent\n      });\n    } else if (type === 'dataMarker') {\n      var _f = option,\n        position_2 = _f.position,\n        point = _f.point,\n        line = _f.line,\n        text = _f.text,\n        autoAdjust = _f.autoAdjust,\n        direction = _f.direction,\n        rest = __rest(_f, [\"position\", \"point\", \"line\", \"text\", \"autoAdjust\", \"direction\"]);\n      o = __assign(__assign(__assign({}, rest), textPoint), {\n        coordinateBBox: this.getCoordinateBBox(),\n        point: point,\n        line: line,\n        text: text,\n        autoAdjust: autoAdjust,\n        direction: direction\n      });\n    } else if (type === 'dataRegion') {\n      var _g = option,\n        start_5 = _g.start,\n        end_5 = _g.end,\n        region = _g.region,\n        text = _g.text,\n        lineLength = _g.lineLength,\n        rest = __rest(_g, [\"start\", \"end\", \"region\", \"text\", \"lineLength\"]);\n      o = __assign(__assign({}, rest), {\n        points: this.getRegionPoints(start_5, end_5),\n        region: region,\n        text: text,\n        lineLength: lineLength\n      });\n    } else if (type === 'regionFilter') {\n      var _h = option,\n        start_6 = _h.start,\n        end_6 = _h.end,\n        apply_1 = _h.apply,\n        color = _h.color,\n        rest = __rest(_h, [\"start\", \"end\", \"apply\", \"color\"]);\n      var geometries = this.view.geometries;\n      var shapes_1 = [];\n      var addShapes_1 = function addShapes_1(item) {\n        if (!item) {\n          return;\n        }\n        if (item.isGroup()) {\n          item.getChildren().forEach(function (child) {\n            return addShapes_1(child);\n          });\n        } else {\n          shapes_1.push(item);\n        }\n      };\n      each(geometries, function (geom) {\n        if (apply_1) {\n          if (contains(apply_1, geom.type)) {\n            each(geom.elements, function (elem) {\n              addShapes_1(elem.shape);\n            });\n          }\n        } else {\n          each(geom.elements, function (elem) {\n            addShapes_1(elem.shape);\n          });\n        }\n      });\n      o = __assign(__assign({}, rest), {\n        color: color,\n        shapes: shapes_1,\n        start: sp,\n        end: ep\n      });\n    } else if (type === 'shape') {\n      var _j = option,\n        render_1 = _j.render,\n        restOptions = __rest(_j, [\"render\"]);\n      var wrappedRender = function wrappedRender(container) {\n        if (isFunction(option.render)) {\n          return render_1(container, _this.view, {\n            parsePosition: _this.parsePosition.bind(_this)\n          });\n        }\n      };\n      o = __assign(__assign({}, restOptions), {\n        render: wrappedRender\n      });\n    } else if (type === 'html') {\n      var _k = option,\n        html_1 = _k.html,\n        position_3 = _k.position,\n        restOptions = __rest(_k, [\"html\", \"position\"]);\n      var wrappedHtml = function wrappedHtml(container) {\n        if (isFunction(html_1)) {\n          return html_1(container, _this.view);\n        }\n        return html_1;\n      };\n      o = __assign(__assign(__assign({}, restOptions), textPoint), {\n        // html 组件需要指定 parent\n        parent: canvas.get('el').parentNode,\n        html: wrappedHtml\n      });\n    }\n    // 合并主题，用户配置优先级高于默认主题\n    var cfg = deepMix({}, theme, __assign(__assign({}, o), {\n      top: option.top,\n      style: option.style,\n      offsetX: option.offsetX,\n      offsetY: option.offsetY\n    }));\n    if (type !== 'html') {\n      // html 类型不使用 G container\n      cfg.container = this.getComponentContainer(cfg);\n    }\n    cfg.animate = this.view.getOptions().animate && cfg.animate && get(option, 'animate', cfg.animate); // 如果 view 关闭动画，则不执行\n    cfg.animateOption = deepMix({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);\n    return cfg;\n  };\n  /**\n   * is annotation render on top\n   * @param option\n   * @return whethe on top\n   */\n  Annotation.prototype.isTop = function (option) {\n    return get(option, 'top', true);\n  };\n  /**\n   * get the container by option.top\n   * default is on top\n   * @param option\n   * @returns the container\n   */\n  Annotation.prototype.getComponentContainer = function (option) {\n    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;\n  };\n  Annotation.prototype.getAnnotationTheme = function (type) {\n    return get(this.view.getTheme(), ['components', 'annotation', type], {});\n  };\n  /**\n   * 创建或者更新 annotation\n   * @param option\n   */\n  Annotation.prototype.updateOrCreate = function (option) {\n    // 拿到缓存的内容\n    var co = this.cache.get(this.getCacheKey(option));\n    // 存在则更新，不存在在创建\n    if (co) {\n      var type = option.type;\n      var theme = this.getAnnotationTheme(type);\n      var cfg = this.getAnnotationCfg(type, option, theme);\n      // 忽略掉一些配置\n      if (cfg) {\n        omit(cfg, ['container']);\n      }\n      co.component.update(__assign(__assign({}, cfg || {}), {\n        visible: !!cfg\n      }));\n      // 对于 regionFilter/shape，因为生命周期的原因，需要额外 render\n      if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n        co.component.render();\n      }\n    } else {\n      // 不存在，创建\n      co = this.createAnnotation(option);\n      if (co) {\n        co.component.init();\n        // Note：regionFilter/shape 特殊处理，regionFilter/shape 需要取到 Geometry 中的 Shape，需要在 view render 之后处理\n        // 其他组件使用外层的统一 render 逻辑\n        if (includes(ANNOTATIONS_AFTER_RENDER, option.type)) {\n          co.component.render();\n        }\n      }\n    }\n    return co;\n  };\n  /**\n   * 更新缓存，以及销毁组件\n   * @param updated 更新或者创建的组件\n   */\n  Annotation.prototype.syncCache = function (updated) {\n    var _this = this;\n    var newCache = new Map(this.cache); // clone 一份\n    // 将 update 更新到 cache\n    updated.forEach(function (co, key) {\n      newCache.set(key, co);\n    });\n    // 另外和 options 进行对比，删除\n    newCache.forEach(function (co, key) {\n      // option 中已经找不到，那么就是删除的\n      if (!find(_this.option, function (option) {\n        return key === _this.getCacheKey(option);\n      })) {\n        co.component.destroy();\n        newCache.delete(key);\n      }\n    });\n    return newCache;\n  };\n  /**\n   * 获得缓存组件的 key\n   * @param option\n   */\n  Annotation.prototype.getCacheKey = function (option) {\n    // 如果存在 id，则使用 id string，否则直接使用 option 引用作为 key\n    return option;\n    // 后续扩展 id 用\n    // const id = get(option, 'id');\n    // return id ? id : option;\n  };\n\n  return Annotation;\n}(Controller);\nexport default Annotation;","map":null,"metadata":{},"sourceType":"module"}