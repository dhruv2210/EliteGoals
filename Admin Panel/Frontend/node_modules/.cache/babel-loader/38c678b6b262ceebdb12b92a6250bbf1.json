{"ast":null,"code":"import getArcParams from './get-arc-params';\nimport { isSamePoint } from './get-arc-params';\nimport parsePath from './parse-path';\n// 点对称\nfunction toSymmetry(point, center) {\n  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];\n}\nexport default function getSegments(path) {\n  path = parsePath(path);\n  var segments = [];\n  var currentPoint = null; // 当前图形\n  var nextParams = null; // 下一节点的 path 参数\n  var startMovePoint = null; // 开始 M 的点，可能会有多个\n  var lastStartMovePointIndex = 0; // 最近一个开始点 M 的索引\n  var count = path.length;\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    nextParams = path[i + 1];\n    var command = params[0];\n    // 数学定义上的参数，便于后面的计算\n    var segment = {\n      command: command,\n      prePoint: currentPoint,\n      params: params,\n      startTangent: null,\n      endTangent: null\n    };\n    switch (command) {\n      case 'M':\n        startMovePoint = [params[1], params[2]];\n        lastStartMovePointIndex = i;\n        break;\n      case 'A':\n        var arcParams = getArcParams(currentPoint, params);\n        segment['arcParams'] = arcParams;\n        break;\n      default:\n        break;\n    }\n    if (command === 'Z') {\n      // 有了 Z 后，当前节点从开始 M 的点开始\n      currentPoint = startMovePoint;\n      // 如果当前点的命令为 Z，相当于当前点为最近一个 M 点，则下一个点直接指向最近一个 M 点的下一个点\n      nextParams = path[lastStartMovePointIndex + 1];\n    } else {\n      var len = params.length;\n      currentPoint = [params[len - 2], params[len - 1]];\n    }\n    if (nextParams && nextParams[0] === 'Z') {\n      // 如果下一个点的命令为 Z，则下一个点直接指向最近一个 M 点\n      nextParams = path[lastStartMovePointIndex];\n      if (segments[lastStartMovePointIndex]) {\n        // 如果下一个点的命令为 Z，则最近一个 M 点的前一个点为当前点\n        segments[lastStartMovePointIndex].prePoint = currentPoint;\n      }\n    }\n    segment['currentPoint'] = currentPoint;\n    // 如果当前点与最近一个 M 点相同，则最近一个 M 点的前一个点为当前点的前一个点\n    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {\n      segments[lastStartMovePointIndex].prePoint = segment.prePoint;\n    }\n    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;\n    segment['nextPoint'] = nextPoint;\n    // Add startTangent and endTangent\n    var prePoint = segment.prePoint;\n    if (['L', 'H', 'V'].includes(command)) {\n      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n    } else if (command === 'Q') {\n      // 二次贝塞尔曲线只有一个控制点\n      var cp = [params[1], params[2]];\n      // 二次贝塞尔曲线的终点为 currentPoint\n      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n    } else if (command === 'T') {\n      var preSegment = segments[i - 1];\n      var cp = toSymmetry(preSegment.currentPoint, prePoint);\n      if (preSegment.command === 'Q') {\n        segment.command = 'Q';\n        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];\n        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];\n      } else {\n        segment.command = 'TL';\n        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];\n        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];\n      }\n    } else if (command === 'C') {\n      // 三次贝塞尔曲线有两个控制点\n      var cp1 = [params[1], params[2]];\n      var cp2 = [params[3], params[4]];\n      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]\n      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {\n        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];\n      }\n      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {\n        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];\n      }\n    } else if (command === 'S') {\n      var preSegment = segments[i - 1];\n      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);\n      var cp2 = [params[1], params[2]];\n      if (preSegment.command === 'C') {\n        segment.command = 'C'; // 将 S 命令变换为 C 命令\n        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      } else {\n        segment.command = 'SQ'; // 将 S 命令变换为 SQ 命令\n        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];\n        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];\n      }\n    } else if (command === 'A') {\n      var d = 0.001;\n      var _a = segment['arcParams'] || {},\n        _b = _a.cx,\n        cx = _b === void 0 ? 0 : _b,\n        _c = _a.cy,\n        cy = _c === void 0 ? 0 : _c,\n        _d = _a.rx,\n        rx = _d === void 0 ? 0 : _d,\n        _e = _a.ry,\n        ry = _e === void 0 ? 0 : _e,\n        _f = _a.sweepFlag,\n        sweepFlag = _f === void 0 ? 0 : _f,\n        _g = _a.startAngle,\n        startAngle = _g === void 0 ? 0 : _g,\n        _h = _a.endAngle,\n        endAngle = _h === void 0 ? 0 : _h;\n      if (sweepFlag === 0) {\n        d *= -1;\n      }\n      var dx1 = rx * Math.cos(startAngle - d) + cx;\n      var dy1 = ry * Math.sin(startAngle - d) + cy;\n      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];\n      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;\n      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;\n      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];\n    }\n    segments.push(segment);\n  }\n  return segments;\n}","map":null,"metadata":{},"sourceType":"module"}