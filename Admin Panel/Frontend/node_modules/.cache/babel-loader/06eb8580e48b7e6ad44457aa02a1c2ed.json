{"ast":null,"code":"import { __assign, __extends, __read } from \"tslib\";\nimport { deepMix, get, isObject, size, clamp, isNil, noop, throttle, isEmpty, valuesOfKey } from '@antv/util';\nimport { COMPONENT_TYPE, DIRECTION, LAYER, VIEW_LIFE_CIRCLE } from '../../constant';\nimport { Slider as SliderComponent } from '../../dependents';\nimport { BBox } from '../../util/bbox';\nimport { directionToPosition } from '../../util/direction';\nimport { isBetween } from '../../util/helper';\nimport { Controller } from './base';\n/**\n * @ignore\n * slider Controller\n */\nvar Slider = /** @class */function (_super) {\n  __extends(Slider, _super);\n  function Slider(view) {\n    var _this = _super.call(this, view) || this;\n    _this.onChangeFn = noop;\n    /**\n     * 清除测量\n     */\n    _this.resetMeasure = function () {\n      _this.clear();\n    };\n    /**\n     * 滑块滑动的时候出发\n     * @param v\n     */\n    _this.onValueChange = function (v) {\n      var _a = __read(v, 2),\n        min = _a[0],\n        max = _a[1];\n      _this.start = min;\n      _this.end = max;\n      _this.changeViewData(min, max);\n    };\n    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();\n    _this.onChangeFn = throttle(_this.onValueChange, 20, {\n      leading: true\n    });\n    _this.width = 0;\n    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);\n    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);\n    return _this;\n  }\n  Object.defineProperty(Slider.prototype, \"name\", {\n    get: function get() {\n      return 'slider';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Slider.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);\n    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);\n  };\n  /**\n   * 初始化\n   */\n  Slider.prototype.init = function () {};\n  /**\n   * 渲染\n   */\n  Slider.prototype.render = function () {\n    this.option = this.view.getOptions().slider;\n    var _a = this.getSliderCfg(),\n      start = _a.start,\n      end = _a.end;\n    if (isNil(this.start)) {\n      this.start = start;\n      this.end = end;\n    }\n    var viewData = this.view.getOptions().data;\n    if (this.option && !isEmpty(viewData)) {\n      if (this.slider) {\n        // exist, update\n        this.slider = this.updateSlider();\n      } else {\n        // not exist, create\n        this.slider = this.createSlider();\n        // 监听事件，绑定交互\n        this.slider.component.on('sliderchange', this.onChangeFn);\n      }\n    } else {\n      if (this.slider) {\n        // exist, destroy\n        this.slider.component.destroy();\n        this.slider = undefined;\n      } else {\n        // do nothing\n      }\n    }\n  };\n  /**\n   * 布局\n   */\n  Slider.prototype.layout = function () {\n    var _this = this;\n    if (this.option && !this.width) {\n      this.measureSlider();\n      setTimeout(function () {\n        // 初始状态下的 view 数据过滤\n        if (!_this.view.destroyed) {\n          _this.changeViewData(_this.start, _this.end);\n        }\n      }, 0);\n    }\n    if (this.slider) {\n      var width = this.view.coordinateBBox.width;\n      // 获取组件的 layout bbox\n      var padding = this.slider.component.get('padding');\n      var _a = __read(padding, 4),\n        paddingTop = _a[0],\n        paddingRight = _a[1],\n        paddingBottom = _a[2],\n        paddingLeft = _a[3];\n      var bboxObject = this.slider.component.getLayoutBBox();\n      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);\n      var _b = this.getMinMaxText(this.start, this.end),\n        minText = _b.minText,\n        maxText = _b.maxText;\n      var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2),\n        x1 = _c[0],\n        y1 = _c[1];\n      var _d = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2),\n        x2 = _d[0],\n        y2 = _d[1];\n      // 默认放在 bottom\n      this.slider.component.update(__assign(__assign({}, this.getSliderCfg()), {\n        x: x2 + paddingLeft,\n        y: y1 + paddingTop,\n        width: this.width,\n        start: this.start,\n        end: this.end,\n        minText: minText,\n        maxText: maxText\n      }));\n      this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);\n    }\n  };\n  /**\n   * 更新\n   */\n  Slider.prototype.update = function () {\n    // 逻辑和 render 保持一致\n    this.render();\n  };\n  /**\n   * 创建 slider 组件\n   */\n  Slider.prototype.createSlider = function () {\n    var cfg = this.getSliderCfg();\n    // 添加 slider 组件\n    var component = new SliderComponent(__assign({\n      container: this.container\n    }, cfg));\n    component.init();\n    return {\n      component: component,\n      layer: LAYER.FORE,\n      direction: DIRECTION.BOTTOM,\n      type: COMPONENT_TYPE.SLIDER\n    };\n  };\n  /**\n   * 更新配置\n   */\n  Slider.prototype.updateSlider = function () {\n    var cfg = this.getSliderCfg();\n    if (this.width) {\n      var _a = this.getMinMaxText(this.start, this.end),\n        minText = _a.minText,\n        maxText = _a.maxText;\n      cfg = __assign(__assign({}, cfg), {\n        width: this.width,\n        start: this.start,\n        end: this.end,\n        minText: minText,\n        maxText: maxText\n      });\n    }\n    this.slider.component.update(cfg);\n    return this.slider;\n  };\n  /**\n   * 进行测量操作\n   */\n  Slider.prototype.measureSlider = function () {\n    var width = this.getSliderCfg().width;\n    this.width = width;\n  };\n  /**\n   * 生成 slider 配置\n   */\n  Slider.prototype.getSliderCfg = function () {\n    var cfg = {\n      height: 16,\n      start: 0,\n      end: 1,\n      minText: '',\n      maxText: '',\n      x: 0,\n      y: 0,\n      width: this.view.coordinateBBox.width\n    };\n    if (isObject(this.option)) {\n      // 用户配置的数据，优先级更高\n      var trendCfg = __assign({\n        data: this.getData()\n      }, get(this.option, 'trendCfg', {}));\n      // 因为有样式，所以深层覆盖\n      cfg = deepMix({}, cfg, this.getThemeOptions(), this.option);\n      // trendCfg 因为有数据数组，所以使用浅替换\n      cfg = __assign(__assign({}, cfg), {\n        trendCfg: trendCfg\n      });\n    }\n    cfg.start = clamp(Math.min(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);\n    cfg.end = clamp(Math.max(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);\n    return cfg;\n  };\n  /**\n   * 从 view 中获取数据，缩略轴使用全量的数据\n   */\n  Slider.prototype.getData = function () {\n    var data = this.view.getOptions().data;\n    var _a = __read(this.view.getYScales(), 1),\n      yScale = _a[0];\n    var groupScales = this.view.getGroupScales();\n    if (groupScales.length) {\n      var _b = groupScales[0],\n        field_1 = _b.field,\n        ticks_1 = _b.ticks;\n      return data.reduce(function (pre, cur) {\n        if (cur[field_1] === ticks_1[0]) {\n          pre.push(cur[yScale.field]);\n        }\n        return pre;\n      }, []);\n    }\n    return data.map(function (datum) {\n      return datum[yScale.field] || 0;\n    });\n  };\n  /**\n   * 获取 slider 的主题配置\n   */\n  Slider.prototype.getThemeOptions = function () {\n    var theme = this.view.getTheme();\n    return get(theme, ['components', 'slider', 'common'], {});\n  };\n  /**\n   * 根据 start/end 和当前数据计算出当前的 minText/maxText\n   * @param min\n   * @param max\n   */\n  Slider.prototype.getMinMaxText = function (min, max) {\n    var data = this.view.getOptions().data;\n    var xScale = this.view.getXScale();\n    var isHorizontal = true;\n    var values = valuesOfKey(data, xScale.field);\n    // 如果是 xScale 数值类型，则进行排序\n    if (xScale.isLinear) {\n      values = values.sort();\n    }\n    var xValues = isHorizontal ? values : values.reverse();\n    var dataSize = size(data);\n    if (!xScale || !dataSize) {\n      return {}; // fix: 需要兼容，否则调用方直接取值会报错\n    }\n\n    var xTickCount = size(xValues);\n    var minIndex = Math.round(min * (xTickCount - 1));\n    var maxIndex = Math.round(max * (xTickCount - 1));\n    var minText = get(xValues, [minIndex]);\n    var maxText = get(xValues, [maxIndex]);\n    var formatter = this.getSliderCfg().formatter;\n    if (formatter) {\n      minText = formatter(minText, data[minIndex], minIndex);\n      maxText = formatter(maxText, data[maxIndex], maxIndex);\n    }\n    return {\n      minText: minText,\n      maxText: maxText\n    };\n  };\n  /**\n   * 更新 view 过滤数据\n   * @param min\n   * @param max\n   */\n  Slider.prototype.changeViewData = function (min, max) {\n    var data = this.view.getOptions().data;\n    var xScale = this.view.getXScale();\n    var dataSize = size(data);\n    if (!xScale || !dataSize) {\n      return;\n    }\n    var isHorizontal = true;\n    var values = valuesOfKey(data, xScale.field);\n    // 如果是 xScale 数值类型，则进行排序\n    var xScaleValues = this.view.getXScale().isLinear ? values.sort(function (a, b) {\n      return Number(a) - Number(b);\n    }) : values;\n    var xValues = isHorizontal ? xScaleValues : xScaleValues.reverse();\n    var xTickCount = size(xValues);\n    var minIndex = Math.round(min * (xTickCount - 1));\n    var maxIndex = Math.round(max * (xTickCount - 1));\n    // 增加 x 轴的过滤器\n    this.view.filter(xScale.field, function (value, datum) {\n      var idx = xValues.indexOf(value);\n      return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;\n    });\n    this.view.render(true);\n  };\n  /**\n   * 覆写父类方法\n   */\n  Slider.prototype.getComponents = function () {\n    return this.slider ? [this.slider] : [];\n  };\n  /**\n   * 覆盖父类\n   */\n  Slider.prototype.clear = function () {\n    if (this.slider) {\n      this.slider.component.destroy();\n      this.slider = undefined;\n    }\n    this.width = 0;\n    this.start = undefined;\n    this.end = undefined;\n  };\n  return Slider;\n}(Controller);\nexport default Slider;","map":null,"metadata":{},"sourceType":"module"}