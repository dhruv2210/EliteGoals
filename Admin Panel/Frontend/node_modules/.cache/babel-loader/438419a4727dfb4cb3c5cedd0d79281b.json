{"ast":null,"code":"import { assign, isFunction, isNil } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  font: function font() {\n    return 'serif';\n  },\n  padding: 1,\n  size: [500, 500],\n  spiral: 'archimedean',\n  // timeInterval: Infinity // max execute time\n  timeInterval: 3000\n};\n/**\n * 根据对应的数据对象，计算每个\n * 词语在画布中的渲染位置，并返回\n * 计算后的数据对象\n * @param words\n * @param options\n */\nexport function wordCloud(words, options) {\n  // 混入默认配置\n  options = assign({}, DEFAULT_OPTIONS, options);\n  return transform(words, options);\n}\n/**\n * 抛出没有混入默认配置的方法，用于测试。\n * @param words\n * @param options\n */\nexport function transform(words, options) {\n  // 布局对象\n  var layout = tagCloud();\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {\n    if (!isNil(options[key])) {\n      layout[key](options[key]);\n    }\n  });\n  layout.words(words);\n  if (options.imageMask) {\n    layout.createMask(options.imageMask);\n  }\n  var result = layout.start();\n  var tags = result._tags;\n  tags.forEach(function (tag) {\n    tag.x += options.size[0] / 2;\n    tag.y += options.size[1] / 2;\n  });\n  var _a = options.size,\n    w = _a[0],\n    h = _a[1];\n  // 添加两个参照数据，分别表示左上角和右下角。\n  // 不添加的话不会按照真实的坐标渲染，而是以\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\n  // 这样的后果会导致词语之间的重叠。\n  tags.push({\n    text: '',\n    value: 0,\n    x: 0,\n    y: 0,\n    opacity: 0\n  });\n  tags.push({\n    text: '',\n    value: 0,\n    x: w,\n    y: h,\n    opacity: 0\n  });\n  return tags;\n}\nvar cloudRadians = Math.PI / 180,\n  cw = 1 << 11 >> 5,\n  ch = 1 << 11;\nfunction cloudText(d) {\n  return d.text;\n}\nfunction cloudFont() {\n  return 'serif';\n}\nfunction cloudFontNormal() {\n  return 'normal';\n}\nfunction cloudFontSize(d) {\n  return d.value;\n}\nfunction cloudRotate() {\n  return ~~(Math.random() * 2) * 90;\n}\nfunction cloudPadding() {\n  return 1;\n}\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n    ratio = contextAndRatio.ratio;\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n    y = 0,\n    maxh = 0;\n  var n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n    var w = c.measureText(d.text + 'm').width * ratio,\n      h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n        cr = Math.cos(d.rotate * cloudRadians),\n        wcr = w * cr,\n        wsr = w * sr,\n        hcr = h * cr,\n        hsr = h * sr;\n      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = w + 0x1f >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n    sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n      w32 = w >> 5;\n    var h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n      seenRow = -1;\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n          m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n    w = tag.width >> 5,\n    lx = tag.x - (w << 4),\n    sx = lx & 0x7f,\n    msx = 32 - sx,\n    h = tag.y1 - tag.y0;\n  var x = (tag.y + tag.y0) * sw + (lx >> 5),\n    last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n    b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function (t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\nfunction rectangularSpiral(size) {\n  var dy = 4,\n    dx = dy * size[0] / size[1];\n  var x = 0,\n    y = 0;\n  return function (t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {\n      case 0:\n        x += dx;\n        break;\n      case 1:\n        y += dy;\n        break;\n      case 2:\n        x -= dx;\n        break;\n      default:\n        y -= dy;\n        break;\n    }\n    return [x, y];\n  };\n}\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [];\n  var i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\nexport function functor(d) {\n  return isFunction(d) ? d : function () {\n    return d;\n  };\n}\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\nfunction tagCloud() {\n  var size = [256, 256],\n    font = cloudFont,\n    fontSize = cloudFontSize,\n    fontWeight = cloudFontNormal,\n    rotate = cloudRotate,\n    padding = cloudPadding,\n    spiral = archimedeanSpiral,\n    random = Math.random,\n    words = [],\n    timeInterval = Infinity;\n  var text = cloudText;\n  var fontStyle = cloudFontNormal;\n  var canvas = cloudCanvas;\n  var cloud = {};\n  cloud.start = function () {\n    var width = size[0],\n      height = size[1];\n    var contextAndRatio = getContext(canvas()),\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\n      n = words.length,\n      tags = [],\n      data = words.map(function (d, i, data) {\n        d.text = text.call(this, d, i, data);\n        d.font = font.call(this, d, i, data);\n        d.style = fontStyle.call(this, d, i, data);\n        d.weight = fontWeight.call(this, d, i, data);\n        d.rotate = rotate.call(this, d, i, data);\n        d.size = ~~fontSize.call(this, d, i, data);\n        d.padding = padding.call(this, d, i, data);\n        return d;\n      }).sort(function (a, b) {\n        return b.size - a.size;\n      });\n    var i = -1,\n      bounds = !cloud.board ? null : [{\n        x: 0,\n        y: 0\n      }, {\n        x: width,\n        y: height\n      }];\n    step();\n    function step() {\n      var start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n) {\n        var d = data[i];\n        d.x = width * (random() + 0.5) >> 1;\n        d.y = height * (random() + 0.5) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          if (bounds) {\n            if (!cloud.hasImage) {\n              // update bounds if image mask not set\n              cloudBounds(bounds, d);\n            }\n          } else {\n            bounds = [{\n              x: d.x + d.x0,\n              y: d.y + d.y0\n            }, {\n              x: d.x + d.x1,\n              y: d.y + d.y1\n            }];\n          }\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      cloud._tags = tags;\n      cloud._bounds = bounds;\n    }\n    return cloud;\n  };\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n    var context = canvas.getContext('2d');\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n    return {\n      context: context,\n      ratio: ratio\n    };\n  }\n  function place(board, tag, bounds) {\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n    var startX = tag.x,\n      startY = tag.y,\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n      s = spiral(size),\n      dt = random() < 0.5 ? 1 : -1;\n    var dxdy,\n      t = -dt,\n      dx,\n      dy;\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n            w = tag.width >> 5,\n            sw = size[0] >> 5,\n            lx = tag.x - (w << 4),\n            sx = lx & 0x7f,\n            msx = 32 - sx,\n            h = tag.y1 - tag.y0;\n          var last = void 0,\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  cloud.createMask = function (img) {\n    var can = document.createElement('canvas');\n    var width = size[0],\n      height = size[1];\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\n    if (!width || !height) {\n      return;\n    }\n    var w32 = width >> 5;\n    var board = zeroArray((width >> 5) * height);\n    can.width = width;\n    can.height = height;\n    var cxt = can.getContext('2d');\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n    var imageData = cxt.getImageData(0, 0, width, height).data;\n    for (var j = 0; j < height; j++) {\n      for (var i = 0; i < width; i++) {\n        var k = w32 * j + (i >> 5);\n        var tmp = j * width + i << 2;\n        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n        var m = flag ? 1 << 31 - i % 32 : 0;\n        board[k] |= m;\n      }\n    }\n    cloud.board = board;\n    cloud.hasImage = true;\n  };\n  cloud.timeInterval = function (_) {\n    timeInterval = _ == null ? Infinity : _;\n  };\n  cloud.words = function (_) {\n    words = _;\n  };\n  cloud.size = function (_) {\n    size = [+_[0], +_[1]];\n  };\n  cloud.font = function (_) {\n    font = functor(_);\n  };\n  cloud.fontWeight = function (_) {\n    fontWeight = functor(_);\n  };\n  cloud.rotate = function (_) {\n    rotate = functor(_);\n  };\n  cloud.spiral = function (_) {\n    spiral = spirals[_] || _;\n  };\n  cloud.fontSize = function (_) {\n    fontSize = functor(_);\n  };\n  cloud.padding = function (_) {\n    padding = functor(_);\n  };\n  cloud.random = function (_) {\n    random = functor(_);\n  };\n  return cloud;\n}","map":null,"metadata":{},"sourceType":"module"}