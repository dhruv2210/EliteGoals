{"ast":null,"code":"import { __assign, __awaiter, __generator, __rest, __values } from \"tslib\";\nimport { deepMix, each, get, isArray, isNull } from '@antv/util';\nimport { doAnimate } from '../animate';\nimport { getGeometryLabelLayout } from '../geometry/label';\nimport { getLabelBackgroundInfo } from '../geometry/label/util';\nimport { polarToCartesian } from '../util/graphics';\nimport { rotate, translate } from '../util/transform';\nimport { FIELD_ORIGIN } from '../constant';\nimport { updateLabel } from './update-label';\n/**\n * Geometry labels 渲染组件\n */\nvar Labels = /** @class */function () {\n  function Labels(cfg) {\n    /** 存储当前 shape 的映射表，键值为 shape id */\n    this.shapesMap = {};\n    var layout = cfg.layout,\n      container = cfg.container;\n    this.layout = layout;\n    this.container = container;\n  }\n  /**\n   * 渲染文本\n   */\n  Labels.prototype.render = function (items, shapes, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;\n      var e_1, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            shapesMap = {};\n            offscreenGroup = this.createOffscreenGroup();\n            if (!items.length) return [3 /*break*/, 2];\n            try {\n              // 如果 items 空的话就不进行绘制调整操作\n              // step 1: 在虚拟 group 中创建 shapes\n              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n                item = items_1_1.value;\n                if (item) {\n                  shapesMap[item.id] = this.renderLabel(item, offscreenGroup);\n                }\n              }\n            } catch (e_1_1) {\n              e_1 = {\n                error: e_1_1\n              };\n            } finally {\n              try {\n                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n              } finally {\n                if (e_1) throw e_1.error;\n              }\n            }\n            // [todo] Move layout into Worker.\n            // step 2: 根据布局，调整 labels\n            return [4 /*yield*/, this.doLayout(items, shapes, shapesMap)];\n          case 1:\n            // [todo] Move layout into Worker.\n            // step 2: 根据布局，调整 labels\n            _b.sent();\n            // step 3.1: 绘制 labelLine\n            this.renderLabelLine(items, shapesMap);\n            // step 3.2: 绘制 labelBackground\n            this.renderLabelBackground(items, shapesMap);\n            // step 4: 根据用户设置的偏移量调整 label\n            this.adjustLabel(items, shapesMap);\n            _b.label = 2;\n          case 2:\n            lastShapesMap = this.shapesMap;\n            each(shapesMap, function (shape, id) {\n              if (shape.destroyed) {\n                // label 在布局调整环节被删除了（doLayout）\n                delete shapesMap[id];\n              } else {\n                if (lastShapesMap[id]) {\n                  // 图形发生更新\n                  var data = shape.get('data');\n                  var origin_1 = shape.get('origin');\n                  var coordinate = shape.get('coordinate');\n                  var currentAnimateCfg = shape.get('animateCfg');\n                  var currentShape = lastShapesMap[id]; // 已经在渲染树上的 shape\n                  updateLabel(currentShape, shapesMap[id], {\n                    data: data,\n                    origin: origin_1,\n                    animateCfg: currentAnimateCfg,\n                    coordinate: coordinate\n                  });\n                  shapesMap[id] = currentShape; // 保存引用\n                } else {\n                  // 新生成的 shape\n                  // If container has been destroyed, no need to render labels.\n                  if (_this.container.destroyed) return;\n                  _this.container.add(shape);\n                  var animateCfg = get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');\n                  if (animateCfg) {\n                    doAnimate(shape, animateCfg, {\n                      toAttrs: __assign({}, shape.attr()),\n                      coordinate: shape.get('coordinate')\n                    });\n                  }\n                }\n                delete lastShapesMap[id];\n              }\n            });\n            // 移除\n            each(lastShapesMap, function (deleteShape) {\n              var animateCfg = get(deleteShape.get('animateCfg'), 'leave');\n              if (animateCfg) {\n                doAnimate(deleteShape, animateCfg, {\n                  toAttrs: null,\n                  coordinate: deleteShape.get('coordinate')\n                });\n              } else {\n                deleteShape.remove(true); // 移除\n              }\n            });\n\n            this.shapesMap = shapesMap;\n            offscreenGroup.destroy();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /** 清除当前 labels */\n  Labels.prototype.clear = function () {\n    this.container.clear();\n    this.shapesMap = {};\n  };\n  /** 销毁 */\n  Labels.prototype.destroy = function () {\n    this.container.destroy();\n    this.shapesMap = null;\n  };\n  Labels.prototype.renderLabel = function (cfg, container) {\n    var id = cfg.id,\n      elementId = cfg.elementId,\n      data = cfg.data,\n      mappingData = cfg.mappingData,\n      coordinate = cfg.coordinate,\n      animate = cfg.animate,\n      content = cfg.content,\n      capture = cfg.capture;\n    var shapeAppendCfg = {\n      id: id,\n      elementId: elementId,\n      capture: capture,\n      data: data,\n      origin: __assign(__assign({}, mappingData), {\n        data: mappingData[FIELD_ORIGIN]\n      }),\n      coordinate: coordinate\n    };\n    var labelGroup = container.addGroup(__assign({\n      name: 'label',\n      // 如果 this.animate === false 或者 cfg.animate === false/null 则不进行动画，否则进行动画配置的合并\n      animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)\n    }, shapeAppendCfg));\n    var labelShape;\n    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {\n      // 如果 content 是 Group 或者 Shape，根据 textAlign 调整位置后，直接将其加入 labelGroup\n      var _a = content.getCanvasBBox(),\n        width = _a.width,\n        height = _a.height;\n      var textAlign = get(cfg, 'textAlign', 'left');\n      var x = cfg.x;\n      var y = cfg.y - height / 2;\n      if (textAlign === 'center') {\n        x = x - width / 2;\n      } else if (textAlign === 'right' || textAlign === 'end') {\n        x = x - width;\n      }\n      translate(content, x, y); // 将 label 平移至 x, y 指定的位置\n      labelShape = content;\n      labelGroup.add(content);\n    } else {\n      var fill = get(cfg, ['style', 'fill']);\n      labelShape = labelGroup.addShape('text', __assign({\n        attrs: __assign(__assign({\n          x: cfg.x,\n          y: cfg.y,\n          textAlign: cfg.textAlign,\n          textBaseline: get(cfg, 'textBaseline', 'middle'),\n          text: cfg.content\n        }, cfg.style), {\n          fill: isNull(fill) ? cfg.color : fill\n        })\n      }, shapeAppendCfg));\n    }\n    if (cfg.rotate) {\n      rotate(labelShape, cfg.rotate);\n    }\n    return labelGroup;\n  };\n  // 根据type对label布局\n  Labels.prototype.doLayout = function (items, shapes, shapesMap) {\n    return __awaiter(this, void 0, void 0, function () {\n      var layouts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.layout) return [3 /*break*/, 2];\n            layouts = isArray(this.layout) ? this.layout : [this.layout];\n            return [4 /*yield*/, Promise.all(layouts.map(function (layout) {\n              var layoutFn = getGeometryLabelLayout(get(layout, 'type', ''));\n              if (!layoutFn) return;\n              var labelShapes = [];\n              var geometryShapes = [];\n              each(shapesMap, function (labelShape, id) {\n                labelShapes.push(labelShape);\n                geometryShapes.push(shapes[labelShape.get('elementId')]);\n              });\n              // [todo] Refactor more layout into Worker.\n              return layoutFn(items, labelShapes, geometryShapes, _this.region, layout.cfg);\n            }))];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Labels.prototype.renderLabelLine = function (labelItems, shapesMap) {\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n      if (!labelItem || !coordinate) {\n        return;\n      }\n      var center = coordinate.getCenter();\n      var radius = coordinate.getRadius();\n      if (!labelItem.labelLine) {\n        // labelLine: null | false，关闭 label 对应的 labelLine\n        return;\n      }\n      var labelLineCfg = get(labelItem, 'labelLine', {});\n      var id = labelItem.id;\n      var path = labelLineCfg.path;\n      if (!path) {\n        var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);\n        path = [['M', start.x, start.y], ['L', labelItem.x, labelItem.y]];\n      }\n      var labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        labelGroup.addShape('path', {\n          capture: false,\n          attrs: __assign({\n            path: path,\n            stroke: labelItem.color ? labelItem.color : get(labelItem, ['style', 'fill'], '#000'),\n            fill: null\n          }, labelLineCfg.style),\n          id: id,\n          origin: labelItem.mappingData,\n          data: labelItem.data,\n          coordinate: labelItem.coordinate\n        });\n      }\n    });\n  };\n  /**\n   * 绘制标签背景\n   * @param labelItems\n   */\n  Labels.prototype.renderLabelBackground = function (labelItems, shapesMap) {\n    each(labelItems, function (labelItem) {\n      var coordinate = get(labelItem, 'coordinate');\n      var background = get(labelItem, 'background');\n      if (!background || !coordinate) {\n        return;\n      }\n      var id = labelItem.id;\n      var labelGroup = shapesMap[id];\n      if (!labelGroup.destroyed) {\n        var labelContentShape = labelGroup.getChildren()[0];\n        if (labelContentShape) {\n          var _a = getLabelBackgroundInfo(labelGroup, labelItem, background.padding),\n            rotation = _a.rotation,\n            box = __rest(_a, [\"rotation\"]);\n          var backgroundShape = labelGroup.addShape('rect', {\n            attrs: __assign(__assign({}, box), background.style || {}),\n            id: id,\n            origin: labelItem.mappingData,\n            data: labelItem.data,\n            coordinate: labelItem.coordinate\n          });\n          backgroundShape.setZIndex(-1);\n          if (rotation) {\n            var matrix = labelContentShape.getMatrix();\n            backgroundShape.setMatrix(matrix);\n          }\n        }\n      }\n    });\n  };\n  Labels.prototype.createOffscreenGroup = function () {\n    var container = this.container;\n    var GroupClass = container.getGroupBase(); // 获取分组的构造函数\n    var newGroup = new GroupClass({});\n    return newGroup;\n  };\n  Labels.prototype.adjustLabel = function (items, shapesMap) {\n    each(items, function (item) {\n      if (item) {\n        var id = item.id;\n        var labelGroup = shapesMap[id];\n        if (!labelGroup.destroyed) {\n          // fix: 如果说开发者的 label content 是一个 group，此处的偏移无法对 整个 content group 生效；场景类似 饼图 spider label 是一个含 2 个 textShape 的 gorup\n          var labelShapes = labelGroup.findAll(function (ele) {\n            return ele.get('type') !== 'path';\n          });\n          each(labelShapes, function (labelShape) {\n            if (labelShape) {\n              if (item.offsetX) {\n                labelShape.attr('x', labelShape.attr('x') + item.offsetX);\n              }\n              if (item.offsetY) {\n                labelShape.attr('y', labelShape.attr('y') + item.offsetY);\n              }\n            }\n          });\n        }\n      }\n    });\n  };\n  return Labels;\n}();\nexport default Labels;","map":null,"metadata":{},"sourceType":"module"}