{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.fmin = global.fmin || {});\n})(this, function (exports) {\n  'use strict';\n\n  /** finds the zeros of a function, given two starting points (which must\n   * have opposite signs */\n  function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n      tolerance = parameters.tolerance || 1e-10,\n      fA = f(a),\n      fB = f(b),\n      delta = b - a;\n    if (fA * fB > 0) {\n      throw \"Initial bisect points must have opposite signs\";\n    }\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n    for (var i = 0; i < maxIterations; ++i) {\n      delta /= 2;\n      var mid = a + delta,\n        fMid = f(mid);\n      if (fMid * fA >= 0) {\n        a = mid;\n      }\n      if (Math.abs(delta) < tolerance || fMid === 0) {\n        return mid;\n      }\n    }\n    return a + delta;\n  }\n\n  // need some basic operations on vectors, rather than adding a dependency,\n  // just define here\n  function zeros(x) {\n    var r = new Array(x);\n    for (var i = 0; i < x; ++i) {\n      r[i] = 0;\n    }\n    return r;\n  }\n  function zerosM(x, y) {\n    return zeros(x).map(function () {\n      return zeros(y);\n    });\n  }\n  function dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n      ret += a[i] * b[i];\n    }\n    return ret;\n  }\n  function norm2(a) {\n    return Math.sqrt(dot(a, a));\n  }\n  function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n      ret[i] = value[i] * c;\n    }\n  }\n  function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n      ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n  }\n\n  /** minimizes a function using the downhill simplex method */\n  function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n      nonZeroDelta = parameters.nonZeroDelta || 1.05,\n      zeroDelta = parameters.zeroDelta || 0.001,\n      minErrorDelta = parameters.minErrorDelta || 1e-6,\n      minTolerance = parameters.minErrorDelta || 1e-5,\n      rho = parameters.rho !== undefined ? parameters.rho : 1,\n      chi = parameters.chi !== undefined ? parameters.chi : 2,\n      psi = parameters.psi !== undefined ? parameters.psi : -0.5,\n      sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,\n      maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n      simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n      var point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n    function updateSimplex(value) {\n      for (var i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n      simplex[N].fx = value.fx;\n    }\n    var sortOrder = function sortOrder(a, b) {\n      return a.fx - b.fx;\n    };\n    var centroid = x0.slice(),\n      reflected = x0.slice(),\n      contracted = x0.slice(),\n      expanded = x0.slice();\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n      if (parameters.history) {\n        // copy the simplex (since later iterations will mutate) and\n        // sort it to have a consistent order between iterations\n        var sortedSimplex = simplex.map(function (x) {\n          var state = x.slice();\n          state.fx = x.fx;\n          state.id = x.id;\n          return state;\n        });\n        sortedSimplex.sort(function (a, b) {\n          return a.id - b.id;\n        });\n        parameters.history.push({\n          x: simplex[0].slice(),\n          fx: simplex[0].fx,\n          simplex: sortedSimplex\n        });\n      }\n      maxDiff = 0;\n      for (i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      }\n\n      // compute the centroid of all but the worst point in the simplex\n      for (i = 0; i < N; ++i) {\n        centroid[i] = 0;\n        for (var j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n        centroid[i] /= N;\n      }\n\n      // reflect the worst point past the centroid  and compute loss at reflected\n      // point\n      var worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected);\n\n      // if the reflected point is the best seen, then possibly expand\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      }\n\n      // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n        var shouldReduce = false;\n        if (reflected.fx > worst.fx) {\n          // do an inside contraction\n          weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < worst.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        } else {\n          // do an outside contraction\n          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < reflected.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        }\n        if (shouldReduce) {\n          // if we don't contract here, we're done\n          if (sigma >= 1) break;\n\n          // do a reduction\n          for (i = 1; i < simplex.length; ++i) {\n            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n            simplex[i].fx = f(simplex[i]);\n          }\n        }\n      } else {\n        updateSimplex(reflected);\n      }\n    }\n    simplex.sort(sortOrder);\n    return {\n      fx: simplex[0].fx,\n      x: simplex[0]\n    };\n  }\n\n  /// searches along line 'pk' for a point that satifies the wolfe conditions\n  /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n  /// f : objective function\n  /// pk : search direction\n  /// current: object containing current gradient/loss\n  /// next: output: contains next gradient/loss\n  /// returns a: step size taken\n  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx,\n      phiPrime0 = dot(current.fxprime, pk),\n      phi = phi0,\n      phi_old = phi0,\n      phiPrime = phiPrime0,\n      a0 = 0;\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n    function zoom(a_lo, a_high, phi_lo) {\n      for (var iteration = 0; iteration < 16; ++iteration) {\n        a = (a_lo + a_high) / 2;\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n          a_high = a;\n        } else {\n          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n          }\n          if (phiPrime * (a_high - a_lo) >= 0) {\n            a_high = a_lo;\n          }\n          a_lo = a;\n          phi_lo = phi;\n        }\n      }\n      return 0;\n    }\n    for (var iteration = 0; iteration < 10; ++iteration) {\n      weightedSum(next.x, 1.0, current.x, a, pk);\n      phi = next.fx = f(next.x, next.fxprime);\n      phiPrime = dot(next.fxprime, pk);\n      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n        return zoom(a0, a, phi_old);\n      }\n      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n        return a;\n      }\n      if (phiPrime >= 0) {\n        return zoom(a, a0, phi);\n      }\n      phi_old = phi;\n      a0 = a;\n      a *= 2;\n    }\n    return a;\n  }\n  function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      next = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      yk = initial.slice(),\n      pk,\n      temp,\n      a = 1,\n      maxIterations;\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n    for (var i = 0; i < maxIterations; ++i) {\n      a = wolfeLineSearch(f, pk, current, next, a);\n\n      // todo: history in wrong spot?\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          alpha: a\n        });\n      }\n      if (!a) {\n        // faiiled to find point that satifies wolfe conditions.\n        // reset direction for next iteration\n        scale(pk, current.fxprime, -1);\n      } else {\n        // update direction using Polakâ€“Ribiere CG method\n        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n        var delta_k = dot(current.fxprime, current.fxprime),\n          beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n        weightedSum(pk, beta_k, pk, -1, next.fxprime);\n        temp = current;\n        current = next;\n        next = temp;\n      }\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      });\n    }\n    return current;\n  }\n  function gradientDescent(f, initial, params) {\n    params = params || {};\n    var maxIterations = params.maxIterations || initial.length * 100,\n      learnRate = params.learnRate || 0.001,\n      current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      };\n    for (var i = 0; i < maxIterations; ++i) {\n      current.fx = f(current.x, current.fxprime);\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice()\n        });\n      }\n      weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n    return current;\n  }\n  function gradientDescentLineSearch(f, initial, params) {\n    params = params || {};\n    var current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      next = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      maxIterations = params.maxIterations || initial.length * 100,\n      learnRate = params.learnRate || 1,\n      pk = initial.slice(),\n      c1 = params.c1 || 1e-3,\n      c2 = params.c2 || 0.1,\n      temp,\n      functionCalls = [];\n    if (params.history) {\n      // wrap the function call to track linesearch samples\n      var inner = f;\n      f = function f(x, fxprime) {\n        functionCalls.push(x.slice());\n        return inner(x, fxprime);\n      };\n    }\n    current.fx = f(current.x, current.fxprime);\n    for (var i = 0; i < maxIterations; ++i) {\n      scale(pk, current.fxprime, -1);\n      learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          functionCalls: functionCalls,\n          learnRate: learnRate,\n          alpha: learnRate\n        });\n        functionCalls = [];\n      }\n      temp = current;\n      current = next;\n      next = temp;\n      if (learnRate === 0 || norm2(current.fxprime) < 1e-5) break;\n    }\n    return current;\n  }\n  exports.bisect = bisect;\n  exports.nelderMead = nelderMead;\n  exports.conjugateGradient = conjugateGradient;\n  exports.gradientDescent = gradientDescent;\n  exports.gradientDescentLineSearch = gradientDescentLineSearch;\n  exports.zeros = zeros;\n  exports.zerosM = zerosM;\n  exports.norm2 = norm2;\n  exports.weightedSum = weightedSum;\n  exports.scale = scale;\n});","map":null,"metadata":{},"sourceType":"script"}