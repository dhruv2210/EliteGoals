{"ast":null,"code":"// https://github.com/HarryStevens/d3-regression#readme Version 1.3.10. Copyright 2022 Harry Stevens.\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.d3 = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n  }\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  function _iterableToArrayLimit(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n\n  // Adapted from vega-statistics by Jeffrey Heer\n  // License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n  // Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/points.js\n  function points(data, x, y, sort) {\n    data = data.filter(function (d, i) {\n      var u = x(d, i),\n        v = y(d, i);\n      return u != null && isFinite(u) && v != null && isFinite(v);\n    });\n    if (sort) {\n      data.sort(function (a, b) {\n        return x(a) - x(b);\n      });\n    }\n    var n = data.length,\n      X = new Float64Array(n),\n      Y = new Float64Array(n); // extract values, calculate means\n\n    var ux = 0,\n      uy = 0,\n      xv,\n      yv,\n      d;\n    for (var i = 0; i < n;) {\n      d = data[i];\n      X[i] = xv = +x(d, i, data);\n      Y[i] = yv = +y(d, i, data);\n      ++i;\n      ux += (xv - ux) / i;\n      uy += (yv - uy) / i;\n    } // mean center the data\n\n    for (var _i = 0; _i < n; ++_i) {\n      X[_i] -= ux;\n      Y[_i] -= uy;\n    }\n    return [X, Y, ux, uy];\n  }\n  function visitPoints(data, x, y, cb) {\n    var iterations = 0;\n    for (var i = 0, n = data.length; i < n; i++) {\n      var d = data[i],\n        dx = +x(d, i, data),\n        dy = +y(d, i, data);\n      if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {\n        cb(dx, dy, iterations++);\n      }\n    }\n  }\n\n  // return the coefficient of determination, or R squared.\n\n  function determination(data, x, y, uY, predict) {\n    var SSE = 0,\n      SST = 0;\n    visitPoints(data, x, y, function (dx, dy) {\n      var sse = dy - predict(dx),\n        sst = dy - uY;\n      SSE += sse * sse;\n      SST += sst * sst;\n    });\n    return 1 - SSE / SST;\n  }\n\n  // Returns the angle of a line in degrees.\n  function angle(line) {\n    return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * 180 / Math.PI;\n  } // Returns the midpoint of a line.\n\n  function midpoint(line) {\n    return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];\n  }\n\n  // returns a smooth line.\n\n  function interpose(xmin, xmax, predict) {\n    var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;\n    var precision = 1 * Math.pow(10, -l / 2 - 1),\n      maxIter = 1e4;\n    var points = [px(xmin), px(xmax)],\n      iter = 0;\n    while (find(points) && iter < maxIter) {}\n    return points;\n    function px(x) {\n      return [x, predict(x)];\n    }\n    function find(points) {\n      iter++;\n      var n = points.length;\n      var found = false;\n      for (var i = 0; i < n - 1; i++) {\n        var p0 = points[i],\n          p1 = points[i + 1],\n          m = midpoint([p0, p1]),\n          mp = px(m[0]),\n          a0 = angle([p0, m]),\n          a1 = angle([p0, mp]),\n          a = Math.abs(a0 - a1);\n        if (a > precision) {\n          points.splice(i + 1, 0, mp);\n          found = true;\n        }\n      }\n      return found;\n    }\n  }\n\n  // Ordinary Least Squares from vega-statistics by Jeffrey Heer\n  // License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n  // Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/ols.js\n  function ols(uX, uY, uXY, uX2) {\n    var delta = uX2 - uX * uX,\n      slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,\n      intercept = uY - slope * uX;\n    return [intercept, slope];\n  }\n  function exponential() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      domain;\n    function exponential(data) {\n      var n = 0,\n        Y = 0,\n        YL = 0,\n        XY = 0,\n        XYL = 0,\n        X2Y = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n      visitPoints(data, x, y, function (dx, dy) {\n        var ly = Math.log(dy),\n          xy = dx * dy;\n        ++n;\n        Y += (dy - Y) / n;\n        XY += (xy - XY) / n;\n        X2Y += (dx * xy - X2Y) / n;\n        YL += (dy * ly - YL) / n;\n        XYL += (xy * ly - XYL) / n;\n        if (!domain) {\n          if (dx < xmin) xmin = dx;\n          if (dx > xmax) xmax = dx;\n        }\n      });\n      var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y),\n        _ols2 = _slicedToArray(_ols, 2),\n        a = _ols2[0],\n        b = _ols2[1];\n      a = Math.exp(a);\n      var fn = function fn(x) {\n          return a * Math.exp(b * x);\n        },\n        out = interpose(xmin, xmax, fn);\n      out.a = a;\n      out.b = b;\n      out.predict = fn;\n      out.rSquared = determination(data, x, y, Y, fn);\n      return out;\n    }\n    exponential.domain = function (arr) {\n      return arguments.length ? (domain = arr, exponential) : domain;\n    };\n    exponential.x = function (fn) {\n      return arguments.length ? (x = fn, exponential) : x;\n    };\n    exponential.y = function (fn) {\n      return arguments.length ? (y = fn, exponential) : y;\n    };\n    return exponential;\n  }\n  function linear() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      domain;\n    function linear(data) {\n      var n = 0,\n        X = 0,\n        // sum of x\n        Y = 0,\n        // sum of y\n        XY = 0,\n        // sum of x * y\n        X2 = 0,\n        // sum of x * x\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n      visitPoints(data, x, y, function (dx, dy) {\n        ++n;\n        X += (dx - X) / n;\n        Y += (dy - Y) / n;\n        XY += (dx * dy - XY) / n;\n        X2 += (dx * dx - X2) / n;\n        if (!domain) {\n          if (dx < xmin) xmin = dx;\n          if (dx > xmax) xmax = dx;\n        }\n      });\n      var _ols = ols(X, Y, XY, X2),\n        _ols2 = _slicedToArray(_ols, 2),\n        intercept = _ols2[0],\n        slope = _ols2[1],\n        fn = function fn(x) {\n          return slope * x + intercept;\n        },\n        out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];\n      out.a = slope;\n      out.b = intercept;\n      out.predict = fn;\n      out.rSquared = determination(data, x, y, Y, fn);\n      return out;\n    }\n    linear.domain = function (arr) {\n      return arguments.length ? (domain = arr, linear) : domain;\n    };\n    linear.x = function (fn) {\n      return arguments.length ? (x = fn, linear) : x;\n    };\n    linear.y = function (fn) {\n      return arguments.length ? (y = fn, linear) : y;\n    };\n    return linear;\n  }\n\n  // Returns the medium value of an array of numbers.\n  function median(arr) {\n    arr.sort(function (a, b) {\n      return a - b;\n    });\n    var i = arr.length / 2;\n    return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];\n  }\n  var maxiters = 2,\n    epsilon = 1e-12;\n  function loess() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      bandwidth = .3;\n    function loess(data) {\n      var _points = points(data, x, y, true),\n        _points2 = _slicedToArray(_points, 4),\n        xv = _points2[0],\n        yv = _points2[1],\n        ux = _points2[2],\n        uy = _points2[3],\n        n = xv.length,\n        bw = Math.max(2, ~~(bandwidth * n)),\n        yhat = new Float64Array(n),\n        residuals = new Float64Array(n),\n        robustWeights = new Float64Array(n).fill(1);\n      for (var iter = -1; ++iter <= maxiters;) {\n        var interval = [0, bw - 1];\n        for (var i = 0; i < n; ++i) {\n          var dx = xv[i],\n            i0 = interval[0],\n            i1 = interval[1],\n            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;\n          var W = 0,\n            X = 0,\n            Y = 0,\n            XY = 0,\n            X2 = 0,\n            denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity\n\n          for (var k = i0; k <= i1; ++k) {\n            var xk = xv[k],\n              yk = yv[k],\n              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],\n              xkw = xk * w;\n            W += w;\n            X += xkw;\n            Y += yk * w;\n            XY += yk * xkw;\n            X2 += xk * xkw;\n          } // Linear regression fit\n\n          var _ols = ols(X / W, Y / W, XY / W, X2 / W),\n            _ols2 = _slicedToArray(_ols, 2),\n            a = _ols2[0],\n            b = _ols2[1];\n          yhat[i] = a + b * dx;\n          residuals[i] = Math.abs(yv[i] - yhat[i]);\n          updateInterval(xv, i + 1, interval);\n        }\n        if (iter === maxiters) {\n          break;\n        }\n        var medianResidual = median(residuals);\n        if (Math.abs(medianResidual) < epsilon) break;\n        for (var _i = 0, arg, _w; _i < n; ++_i) {\n          arg = residuals[_i] / (6 * medianResidual); // Default to epsilon (rather than zero) for large deviations\n          // Keeping weights tiny but non-zero prevents singularites\n\n          robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;\n        }\n      }\n      return output(xv, yhat, ux, uy);\n    }\n    loess.bandwidth = function (bw) {\n      return arguments.length ? (bandwidth = bw, loess) : bandwidth;\n    };\n    loess.x = function (fn) {\n      return arguments.length ? (x = fn, loess) : x;\n    };\n    loess.y = function (fn) {\n      return arguments.length ? (y = fn, loess) : y;\n    };\n    return loess;\n  } // Weighting kernel for local regression\n\n  function tricube(x) {\n    return (x = 1 - x * x * x) * x * x;\n  } // Advance sliding window interval of nearest neighbors\n\n  function updateInterval(xv, i, interval) {\n    var val = xv[i],\n      left = interval[0],\n      right = interval[1] + 1;\n    if (right >= xv.length) return; // Step right if distance to new right edge is <= distance to old left edge\n    // Step when distance is equal to ensure movement over duplicate x values\n\n    while (i > left && xv[right] - val <= val - xv[left]) {\n      interval[0] = ++left;\n      interval[1] = right;\n      ++right;\n    }\n  } // Generate smoothed output points\n  // Average points with repeated x values\n\n  function output(xv, yhat, ux, uy) {\n    var n = xv.length,\n      out = [];\n    var i = 0,\n      cnt = 0,\n      prev = [],\n      v;\n    for (; i < n; ++i) {\n      v = xv[i] + ux;\n      if (prev[0] === v) {\n        // Average output values via online update\n        prev[1] += (yhat[i] - prev[1]) / ++cnt;\n      } else {\n        // Add new output point\n        cnt = 0;\n        prev[1] += uy;\n        prev = [v, yhat[i]];\n        out.push(prev);\n      }\n    }\n    prev[1] += uy;\n    return out;\n  }\n  function logarithmic() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      base = Math.E,\n      domain;\n    function logarithmic(data) {\n      var n = 0,\n        X = 0,\n        Y = 0,\n        XY = 0,\n        X2 = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity,\n        lb = Math.log(base);\n      visitPoints(data, x, y, function (dx, dy) {\n        var lx = Math.log(dx) / lb;\n        ++n;\n        X += (lx - X) / n;\n        Y += (dy - Y) / n;\n        XY += (lx * dy - XY) / n;\n        X2 += (lx * lx - X2) / n;\n        if (!domain) {\n          if (dx < xmin) xmin = dx;\n          if (dx > xmax) xmax = dx;\n        }\n      });\n      var _ols = ols(X, Y, XY, X2),\n        _ols2 = _slicedToArray(_ols, 2),\n        intercept = _ols2[0],\n        slope = _ols2[1],\n        fn = function fn(x) {\n          return slope * Math.log(x) / lb + intercept;\n        },\n        out = interpose(xmin, xmax, fn);\n      out.a = slope;\n      out.b = intercept;\n      out.predict = fn;\n      out.rSquared = determination(data, x, y, Y, fn);\n      return out;\n    }\n    logarithmic.domain = function (arr) {\n      return arguments.length ? (domain = arr, logarithmic) : domain;\n    };\n    logarithmic.x = function (fn) {\n      return arguments.length ? (x = fn, logarithmic) : x;\n    };\n    logarithmic.y = function (fn) {\n      return arguments.length ? (y = fn, logarithmic) : y;\n    };\n    logarithmic.base = function (n) {\n      return arguments.length ? (base = n, logarithmic) : base;\n    };\n    return logarithmic;\n  }\n  function quad() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      domain;\n    function quadratic(data) {\n      var _points = points(data, x, y),\n        _points2 = _slicedToArray(_points, 4),\n        xv = _points2[0],\n        yv = _points2[1],\n        ux = _points2[2],\n        uy = _points2[3],\n        n = xv.length;\n      var X2 = 0,\n        X3 = 0,\n        X4 = 0,\n        XY = 0,\n        X2Y = 0,\n        i,\n        dx,\n        dy,\n        x2;\n      for (i = 0; i < n;) {\n        dx = xv[i];\n        dy = yv[i++];\n        x2 = dx * dx;\n        X2 += (x2 - X2) / i;\n        X3 += (x2 * dx - X3) / i;\n        X4 += (x2 * x2 - X4) / i;\n        XY += (dx * dy - XY) / i;\n        X2Y += (x2 * dy - X2Y) / i;\n      }\n      var Y = 0,\n        n0 = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n      visitPoints(data, x, y, function (dx, dy) {\n        n0++;\n        Y += (dy - Y) / n0;\n        if (!domain) {\n          if (dx < xmin) xmin = dx;\n          if (dx > xmax) xmax = dx;\n        }\n      });\n      var X2X2 = X4 - X2 * X2,\n        d = X2 * X2X2 - X3 * X3,\n        a = (X2Y * X2 - XY * X3) / d,\n        b = (XY * X2X2 - X2Y * X3) / d,\n        c = -a * X2,\n        fn = function fn(x) {\n          x = x - ux;\n          return a * x * x + b * x + c + uy;\n        };\n      var out = interpose(xmin, xmax, fn);\n      out.a = a;\n      out.b = b - 2 * a * ux;\n      out.c = c - b * ux + a * ux * ux + uy;\n      out.predict = fn;\n      out.rSquared = determination(data, x, y, Y, fn);\n      return out;\n    }\n    quadratic.domain = function (arr) {\n      return arguments.length ? (domain = arr, quadratic) : domain;\n    };\n    quadratic.x = function (fn) {\n      return arguments.length ? (x = fn, quadratic) : x;\n    };\n    quadratic.y = function (fn) {\n      return arguments.length ? (y = fn, quadratic) : y;\n    };\n    return quadratic;\n  }\n\n  // Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246\n  // License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE\n  // ...with ideas from vega-statistics by Jeffrey Heer\n  // Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/poly.js\n  // License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n\n  function polynomial() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      order = 3,\n      domain;\n    function polynomial(data) {\n      // Use more efficient methods for lower orders\n      if (order === 1) {\n        var o = linear().x(x).y(y).domain(domain)(data);\n        o.coefficients = [o.b, o.a];\n        delete o.a;\n        delete o.b;\n        return o;\n      }\n      if (order === 2) {\n        var _o = quad().x(x).y(y).domain(domain)(data);\n        _o.coefficients = [_o.c, _o.b, _o.a];\n        delete _o.a;\n        delete _o.b;\n        delete _o.c;\n        return _o;\n      }\n      var _points = points(data, x, y),\n        _points2 = _slicedToArray(_points, 4),\n        xv = _points2[0],\n        yv = _points2[1],\n        ux = _points2[2],\n        uy = _points2[3],\n        n = xv.length,\n        lhs = [],\n        rhs = [],\n        k = order + 1;\n      var Y = 0,\n        n0 = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n      visitPoints(data, x, y, function (dx, dy) {\n        ++n0;\n        Y += (dy - Y) / n0;\n        if (!domain) {\n          if (dx < xmin) xmin = dx;\n          if (dx > xmax) xmax = dx;\n        }\n      });\n      var i, j, l, v, c;\n      for (i = 0; i < k; ++i) {\n        for (l = 0, v = 0; l < n; ++l) {\n          v += Math.pow(xv[l], i) * yv[l];\n        }\n        lhs.push(v);\n        c = new Float64Array(k);\n        for (j = 0; j < k; ++j) {\n          for (l = 0, v = 0; l < n; ++l) {\n            v += Math.pow(xv[l], i + j);\n          }\n          c[j] = v;\n        }\n        rhs.push(c);\n      }\n      rhs.push(lhs);\n      var coef = gaussianElimination(rhs),\n        fn = function fn(x) {\n          x -= ux;\n          var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;\n          for (i = 3; i < k; ++i) {\n            y += coef[i] * Math.pow(x, i);\n          }\n          return y;\n        },\n        out = interpose(xmin, xmax, fn);\n      out.coefficients = uncenter(k, coef, -ux, uy);\n      out.predict = fn;\n      out.rSquared = determination(data, x, y, Y, fn);\n      return out;\n    }\n    polynomial.domain = function (arr) {\n      return arguments.length ? (domain = arr, polynomial) : domain;\n    };\n    polynomial.x = function (fn) {\n      return arguments.length ? (x = fn, polynomial) : x;\n    };\n    polynomial.y = function (fn) {\n      return arguments.length ? (y = fn, polynomial) : y;\n    };\n    polynomial.order = function (n) {\n      return arguments.length ? (order = n, polynomial) : order;\n    };\n    return polynomial;\n  }\n  function uncenter(k, a, x, y) {\n    var z = Array(k);\n    var i, j, v, c; // initialize to zero\n\n    for (i = 0; i < k; ++i) {\n      z[i] = 0;\n    } // polynomial expansion\n\n    for (i = k - 1; i >= 0; --i) {\n      v = a[i];\n      c = 1;\n      z[i] += v;\n      for (j = 1; j <= i; ++j) {\n        c *= (i + 1 - j) / j; // binomial coefficent\n\n        z[i - j] += v * Math.pow(x, j) * c;\n      }\n    } // bias term\n\n    z[0] += y;\n    return z;\n  } // Given an array for a two-dimensional matrix and the polynomial order,\n  // solve A * x = b using Gaussian elimination.\n\n  function gaussianElimination(matrix) {\n    var n = matrix.length - 1,\n      coef = [];\n    var i, j, k, r, t;\n    for (i = 0; i < n; ++i) {\n      r = i; // max row\n\n      for (j = i + 1; j < n; ++j) {\n        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {\n          r = j;\n        }\n      }\n      for (k = i; k < n + 1; ++k) {\n        t = matrix[k][i];\n        matrix[k][i] = matrix[k][r];\n        matrix[k][r] = t;\n      }\n      for (j = i + 1; j < n; ++j) {\n        for (k = n; k >= i; k--) {\n          matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];\n        }\n      }\n    }\n    for (j = n - 1; j >= 0; --j) {\n      t = 0;\n      for (k = j + 1; k < n; ++k) {\n        t += matrix[k][j] * coef[k];\n      }\n      coef[j] = (matrix[n][j] - t) / matrix[j][j];\n    }\n    return coef;\n  }\n  function power() {\n    var x = function x(d) {\n        return d[0];\n      },\n      y = function y(d) {\n        return d[1];\n      },\n      domain;\n    function power(data) {\n      var n = 0,\n        X = 0,\n        Y = 0,\n        XY = 0,\n        X2 = 0,\n        YS = 0,\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n      visitPoints(data, x, y, function (dx, dy) {\n        var lx = Math.log(dx),\n          ly = Math.log(dy);\n        ++n;\n        X += (lx - X) / n;\n        Y += (ly - Y) / n;\n        XY += (lx * ly - XY) / n;\n        X2 += (lx * lx - X2) / n;\n        YS += (dy - YS) / n;\n        if (!domain) {\n          if (dx < xmin) xmin = dx;\n          if (dx > xmax) xmax = dx;\n        }\n      });\n      var _ols = ols(X, Y, XY, X2),\n        _ols2 = _slicedToArray(_ols, 2),\n        a = _ols2[0],\n        b = _ols2[1];\n      a = Math.exp(a);\n      var fn = function fn(x) {\n          return a * Math.pow(x, b);\n        },\n        out = interpose(xmin, xmax, fn);\n      out.a = a;\n      out.b = b;\n      out.predict = fn;\n      out.rSquared = determination(data, x, y, YS, fn);\n      return out;\n    }\n    power.domain = function (arr) {\n      return arguments.length ? (domain = arr, power) : domain;\n    };\n    power.x = function (fn) {\n      return arguments.length ? (x = fn, power) : x;\n    };\n    power.y = function (fn) {\n      return arguments.length ? (y = fn, power) : y;\n    };\n    return power;\n  }\n  exports.regressionExp = exponential;\n  exports.regressionLinear = linear;\n  exports.regressionLoess = loess;\n  exports.regressionLog = logarithmic;\n  exports.regressionPoly = polynomial;\n  exports.regressionPow = power;\n  exports.regressionQuad = quad;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}