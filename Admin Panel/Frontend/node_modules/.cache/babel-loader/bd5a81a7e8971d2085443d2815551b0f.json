{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { debounce, each, isString } from '@antv/util';\nimport { GROUP_Z_INDEX, VIEW_LIFE_CIRCLE } from '../constant';\nimport { getEngine } from '../engine';\nimport { createDom, getChartSize, removeDom, modifyCSS } from '../util/dom';\nimport View from './view';\n/**\n * Chart 类，是使用 G2 进行绘图的入口。\n */\nvar Chart = /** @class */function (_super) {\n  __extends(Chart, _super);\n  // @ts-ignore\n  function Chart(props) {\n    var _this = this;\n    var container = props.container,\n      width = props.width,\n      height = props.height,\n      _a = props.autoFit,\n      autoFit = _a === void 0 ? false : _a,\n      padding = props.padding,\n      appendPadding = props.appendPadding,\n      _b = props.renderer,\n      renderer = _b === void 0 ? 'canvas' : _b,\n      pixelRatio = props.pixelRatio,\n      _c = props.localRefresh,\n      localRefresh = _c === void 0 ? true : _c,\n      _d = props.visible,\n      visible = _d === void 0 ? true : _d,\n      _e = props.supportCSSTransform,\n      supportCSSTransform = _e === void 0 ? false : _e,\n      _f = props.defaultInteractions,\n      defaultInteractions = _f === void 0 ? ['tooltip', 'legend-filter', 'legend-active', 'continuous-filter', 'ellipsis-text', 'axis-description'] : _f,\n      options = props.options,\n      limitInPlot = props.limitInPlot,\n      theme = props.theme,\n      syncViewPadding = props.syncViewPadding;\n    var ele = isString(container) ? document.getElementById(container) : container;\n    // 生成内部正式绘制的 div 元素\n    var wrapperElement = createDom('<div style=\"position:relative;\"></div>');\n    ele.appendChild(wrapperElement);\n    // if autoFit, use the container size, to avoid the graph render twice.\n    var size = getChartSize(ele, autoFit, width, height);\n    var G = getEngine(renderer);\n    var canvas = new G.Canvas(__assign({\n      container: wrapperElement,\n      pixelRatio: pixelRatio,\n      localRefresh: localRefresh,\n      supportCSSTransform: supportCSSTransform\n    }, size));\n    // 调用 view 的创建\n    _this = _super.call(this, {\n      parent: null,\n      canvas: canvas,\n      // create 3 group layers for views.\n      backgroundGroup: canvas.addGroup({\n        zIndex: GROUP_Z_INDEX.BG\n      }),\n      middleGroup: canvas.addGroup({\n        zIndex: GROUP_Z_INDEX.MID\n      }),\n      foregroundGroup: canvas.addGroup({\n        zIndex: GROUP_Z_INDEX.FORE\n      }),\n      padding: padding,\n      appendPadding: appendPadding,\n      visible: visible,\n      options: options,\n      limitInPlot: limitInPlot,\n      theme: theme,\n      syncViewPadding: syncViewPadding\n    }) || this;\n    /**\n     * when container size changed, change chart size props, and re-render.\n     */\n    _this.onResize = debounce(function () {\n      _this.forceFit();\n    }, 300);\n    _this.ele = ele;\n    _this.canvas = canvas;\n    _this.width = size.width;\n    _this.height = size.height;\n    _this.autoFit = autoFit;\n    _this.localRefresh = localRefresh;\n    _this.renderer = renderer;\n    _this.wrapperElement = wrapperElement;\n    // 自适应大小\n    _this.updateCanvasStyle();\n    _this.bindAutoFit();\n    _this.initDefaultInteractions(defaultInteractions);\n    return _this;\n  }\n  Chart.prototype.initDefaultInteractions = function (interactions) {\n    var _this = this;\n    each(interactions, function (interaction) {\n      _this.interaction(interaction);\n    });\n  };\n  /**\n   * 设置 WAI-ARIA 无障碍标签。如何根据图形语法自动生成 arial 内容？\n   * @param ariaOption\n   */\n  Chart.prototype.aria = function (ariaOption) {\n    var ATTR = 'aria-label';\n    if (ariaOption === false) {\n      this.ele.removeAttribute(ATTR);\n    } else {\n      this.ele.setAttribute(ATTR, ariaOption.label);\n    }\n  };\n  /**\n   * 改变图表大小，同时重新渲染。\n   * @param width 图表宽度\n   * @param height 图表高度\n   * @returns\n   */\n  Chart.prototype.changeSize = function (width, height) {\n    // 如果宽高一致，那么 changeSize 不执行任何操作\n    if (this.width === width && this.height === height) {\n      return this;\n    }\n    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);\n    this.width = width;\n    this.height = height;\n    this.canvas.changeSize(width, height);\n    // 重新渲染\n    this.render(true);\n    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);\n    return this;\n  };\n  /**\n   * 清空图表，同时清除掉 aria 配置\n   */\n  Chart.prototype.clear = function () {\n    _super.prototype.clear.call(this);\n    this.aria(false);\n  };\n  /**\n   * 销毁图表，同时解绑事件，销毁创建的 G.Canvas 实例。\n   * @returns void\n   */\n  Chart.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n    this.unbindAutoFit();\n    this.canvas.destroy();\n    removeDom(this.wrapperElement);\n    this.wrapperElement = null;\n  };\n  /**\n   * 显示或隐藏图表\n   * @param visible 是否可见，true 表示显示，false 表示隐藏\n   * @returns\n   */\n  Chart.prototype.changeVisible = function (visible) {\n    _super.prototype.changeVisible.call(this, visible); // 需要更新 visible 变量\n    this.wrapperElement.style.display = visible ? '' : 'none';\n    return this;\n  };\n  /**\n   * 自动根据容器大小 resize 画布\n   */\n  Chart.prototype.forceFit = function () {\n    // skip if already destroyed\n    if (!this.destroyed) {\n      // 注意第二参数用 true，意思是即时 autoFit = false，forceFit() 调用之后一样是适配容器\n      var _a = getChartSize(this.ele, true, this.width, this.height),\n        width = _a.width,\n        height = _a.height;\n      this.changeSize(width, height);\n    }\n  };\n  Chart.prototype.updateCanvasStyle = function () {\n    modifyCSS(this.canvas.get('el'), {\n      display: 'inline-block',\n      verticalAlign: 'middle'\n    });\n  };\n  Chart.prototype.bindAutoFit = function () {\n    if (this.autoFit) {\n      window.addEventListener('resize', this.onResize);\n    }\n  };\n  Chart.prototype.unbindAutoFit = function () {\n    if (this.autoFit) {\n      window.removeEventListener('resize', this.onResize);\n    }\n  };\n  return Chart;\n}(View);\nexport default Chart;","map":null,"metadata":{},"sourceType":"module"}