{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { each, isArray, isFunction, isString, debounce, throttle } from '@antv/util';\nimport { createAction, createCallbackAction } from './action/register';\nimport InteractionContext from './context';\nimport Interaction from './interaction';\n// 将字符串转换成 action\nexport function parseAction(actionStr, context, arg) {\n  var arr = actionStr.split(':');\n  var actionName = arr[0];\n  // 如果已经初始化过 action ，则直接引用之前的 action\n  var action = context.getAction(actionName) || createAction(actionName, context);\n  if (!action) {\n    throw new Error(\"There is no action named \".concat(actionName));\n  }\n  var methodName = arr[1];\n  return {\n    action: action,\n    methodName: methodName,\n    arg: arg\n  };\n}\n// 执行 Action\nfunction executeAction(actionObject) {\n  var action = actionObject.action,\n    methodName = actionObject.methodName,\n    arg = actionObject.arg;\n  if (action[methodName]) {\n    action[methodName](arg);\n  } else {\n    throw new Error(\"Action(\".concat(action.name, \") doesn't have a method called \").concat(methodName));\n  }\n}\nvar STEP_NAMES = {\n  START: 'start',\n  SHOW_ENABLE: 'showEnable',\n  END: 'end',\n  ROLLBACK: 'rollback',\n  PROCESSING: 'processing'\n};\n/**\n * 支持语法的交互类\n */\nvar GrammarInteraction = /** @class */function (_super) {\n  __extends(GrammarInteraction, _super);\n  function GrammarInteraction(view, steps) {\n    var _this = _super.call(this, view, steps) || this;\n    _this.callbackCaches = {};\n    // 某个触发和反馈在本环节是否执行或\n    _this.emitCaches = {};\n    _this.steps = steps;\n    return _this;\n  }\n  /**\n   * 初始化\n   */\n  GrammarInteraction.prototype.init = function () {\n    this.initContext();\n    _super.prototype.init.call(this);\n  };\n  /**\n   * 清理资源\n   */\n  GrammarInteraction.prototype.destroy = function () {\n    _super.prototype.destroy.call(this); // 先清理事件\n    this.steps = null;\n    if (this.context) {\n      this.context.destroy();\n      this.context = null;\n    }\n    this.callbackCaches = null;\n    this.view = null;\n  };\n  /**\n   * 绑定事件\n   */\n  GrammarInteraction.prototype.initEvents = function () {\n    var _this = this;\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n        if (callback) {\n          // 如果存在 callback，才绑定，有时候会出现无 callback 的情况\n          _this.bindEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  /**\n   * 清理绑定的事件\n   */\n  GrammarInteraction.prototype.clearEvents = function () {\n    var _this = this;\n    each(this.steps, function (stepArr, stepName) {\n      each(stepArr, function (step) {\n        var callback = _this.getActionCallback(stepName, step);\n        if (callback) {\n          _this.offEvent(step.trigger, callback);\n        }\n      });\n    });\n  };\n  // 初始化上下文，并初始化 action\n  GrammarInteraction.prototype.initContext = function () {\n    var view = this.view;\n    var context = new InteractionContext(view);\n    this.context = context;\n    var steps = this.steps;\n    // 生成具体的 Action\n    each(steps, function (subSteps) {\n      each(subSteps, function (step) {\n        if (isFunction(step.action)) {\n          // 如果传入回调函数，则直接生成 CallbackAction\n          step.actionObject = {\n            action: createCallbackAction(step.action, context),\n            methodName: 'execute'\n          };\n        } else if (isString(step.action)) {\n          // 如果是字符串\n          step.actionObject = parseAction(step.action, context, step.arg);\n        } else if (isArray(step.action)) {\n          // 如果是数组\n          var actionArr = step.action;\n          var argArr_1 = isArray(step.arg) ? step.arg : [step.arg];\n          step.actionObject = [];\n          each(actionArr, function (actionStr, idx) {\n            step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));\n          });\n        }\n        // 如果 action 既不是字符串，也不是函数，则不会生成 actionObject\n      });\n    });\n  };\n  // 是否允许指定阶段名称执行\n  GrammarInteraction.prototype.isAllowStep = function (stepName) {\n    var currentStepName = this.currentStepName;\n    var steps = this.steps;\n    // 相同的阶段允许同时执行\n    if (currentStepName === stepName) {\n      return true;\n    }\n    if (stepName === STEP_NAMES.SHOW_ENABLE) {\n      // 示能在整个过程中都可用\n      return true;\n    }\n    if (stepName === STEP_NAMES.PROCESSING) {\n      // 只有当前是 start 时，才允许 processing\n      return currentStepName === STEP_NAMES.START;\n    }\n    if (stepName === STEP_NAMES.START) {\n      // 如果当前是 processing，则无法 start，必须等待 end 后才能执行\n      return currentStepName !== STEP_NAMES.PROCESSING;\n    }\n    if (stepName === STEP_NAMES.END) {\n      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;\n    }\n    if (stepName === STEP_NAMES.ROLLBACK) {\n      if (steps[STEP_NAMES.END]) {\n        // 如果定义了 end, 只有 end 时才允许回滚\n        return currentStepName === STEP_NAMES.END;\n      } else if (currentStepName === STEP_NAMES.START) {\n        // 如果未定义 end, 则判断是否是开始\n        return true;\n      }\n    }\n    return false;\n  };\n  // 具体的指定阶段是否允许执行\n  GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {\n    if (this.isAllowStep(stepName)) {\n      var key = this.getKey(stepName, step);\n      // 如果是在本环节内仅允许触发一次，同时已经触发过，则不允许再触发\n      if (step.once && this.emitCaches[key]) {\n        return false;\n      }\n      // 如果是允许的阶段，则验证 isEnable 方法\n      if (step.isEnable) {\n        return step.isEnable(this.context);\n      }\n      return true; // 如果没有 isEnable 则允许执行\n    }\n\n    return false;\n  };\n  GrammarInteraction.prototype.enterStep = function (stepName) {\n    this.currentStepName = stepName;\n    this.emitCaches = {}; // 清除所有本环节触发的缓存\n  };\n  // 执行完某个触发和反馈（子环节）\n  GrammarInteraction.prototype.afterExecute = function (stepName, step) {\n    // show enable 不计入正常的流程，其他情况则设置当前的 step\n    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {\n      this.enterStep(stepName);\n    }\n    var key = this.getKey(stepName, step);\n    // 一旦执行，则缓存标记为，一直保持到跳出改环节\n    this.emitCaches[key] = true;\n  };\n  // 获取某个环节的唯一的键值\n  GrammarInteraction.prototype.getKey = function (stepName, step) {\n    return stepName + step.trigger + step.action;\n  };\n  // 获取 step 的回调函数，如果已经生成，则直接返回，如果未生成，则创建\n  GrammarInteraction.prototype.getActionCallback = function (stepName, step) {\n    var _this = this;\n    var context = this.context;\n    var callbackCaches = this.callbackCaches;\n    var actionObject = step.actionObject;\n    if (step.action && actionObject) {\n      var key = this.getKey(stepName, step);\n      if (!callbackCaches[key]) {\n        // 动态生成执行的方法，执行对应 action 的名称\n        var actionCallback = function actionCallback(event) {\n          context.event = event; // 保证检测时的 event\n          if (_this.isAllowExecute(stepName, step)) {\n            // 如果是数组时，则依次执行\n            if (isArray(actionObject)) {\n              each(actionObject, function (obj) {\n                context.event = event; // 可能触发新的事件，保证执行前的 context.event 是正确的\n                executeAction(obj);\n              });\n            } else {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              executeAction(actionObject);\n            }\n            _this.afterExecute(stepName, step);\n            if (step.callback) {\n              context.event = event; // 保证执行前的 context.event 是正确的\n              step.callback(context);\n            }\n          } else {\n            // 如果未通过验证，则事件不要绑定在上面\n            context.event = null;\n          }\n        };\n        // 如果设置了 debounce\n        if (step.debounce) {\n          callbackCaches[key] = debounce(actionCallback, step.debounce.wait, step.debounce.immediate);\n        } else if (step.throttle) {\n          // 设置 throttle\n          callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {\n            leading: step.throttle.leading,\n            trailing: step.throttle.trailing\n          });\n        } else {\n          // 直接设置\n          callbackCaches[key] = actionCallback;\n        }\n      }\n      return callbackCaches[key];\n    }\n    return null;\n  };\n  GrammarInteraction.prototype.bindEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.addEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.addEventListener(nameArr[1], callback);\n    } else {\n      this.view.on(eventName, callback);\n    }\n  };\n  GrammarInteraction.prototype.offEvent = function (eventName, callback) {\n    var nameArr = eventName.split(':');\n    if (nameArr[0] === 'window') {\n      window.removeEventListener(nameArr[1], callback);\n    } else if (nameArr[0] === 'document') {\n      document.removeEventListener(nameArr[1], callback);\n    } else {\n      this.view.off(eventName, callback);\n    }\n  };\n  return GrammarInteraction;\n}(Interaction);\nexport default GrammarInteraction;","map":null,"metadata":{},"sourceType":"module"}