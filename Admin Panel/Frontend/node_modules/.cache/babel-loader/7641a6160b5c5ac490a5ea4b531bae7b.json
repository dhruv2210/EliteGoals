{"ast":null,"code":"/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nimport { assign, forIn, isFunction } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  y: 0,\n  nodeWidthRatio: 0.05,\n  weight: false,\n  nodePaddingRatio: 0.1,\n  id: function id(node) {\n    return node.id;\n  },\n  source: function source(edge) {\n    return edge.source;\n  },\n  target: function target(edge) {\n    return edge.target;\n  },\n  sourceWeight: function sourceWeight(edge) {\n    return edge.value || 1;\n  },\n  targetWeight: function targetWeight(edge) {\n    return edge.value || 1;\n  },\n  sortBy: null\n};\n/**\n * 处理节点的value、edges\n * @param nodeById\n * @param edges\n * @param options\n */\nfunction processGraph(nodeById, edges, options) {\n  forIn(nodeById, function (node, id) {\n    // in edges, out edges\n    node.inEdges = edges.filter(function (edge) {\n      return \"\" + options.target(edge) === \"\" + id;\n    });\n    node.outEdges = edges.filter(function (edge) {\n      return \"\" + options.source(edge) === \"\" + id;\n    });\n    // frequency\n    node.edges = node.outEdges.concat(node.inEdges);\n    node.frequency = node.edges.length;\n    // weight\n    node.value = 0;\n    node.inEdges.forEach(function (edge) {\n      node.value += options.targetWeight(edge);\n    });\n    node.outEdges.forEach(function (edge) {\n      node.value += options.sourceWeight(edge);\n    });\n  });\n}\n/**\n * 节点排序\n * @param nodes\n * @param options\n */\nfunction sortNodes(nodes, options) {\n  var sortMethods = {\n    weight: function weight(a, b) {\n      return b.value - a.value;\n    },\n    frequency: function frequency(a, b) {\n      return b.frequency - a.frequency;\n    },\n    id: function id(a, b) {\n      return (\"\" + options.id(a)).localeCompare(\"\" + options.id(b));\n    }\n  };\n  var method = sortMethods[options.sortBy];\n  if (!method && isFunction(options.sortBy)) {\n    method = options.sortBy;\n  }\n  if (method) {\n    nodes.sort(method);\n  }\n}\nfunction layoutNodes(nodes, options) {\n  var len = nodes.length;\n  if (!len) {\n    throw new TypeError(\"Invalid nodes: it's empty!\");\n  }\n  if (options.weight) {\n    var nodePaddingRatio_1 = options.nodePaddingRatio;\n    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {\n      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');\n    }\n    var margin_1 = nodePaddingRatio_1 / (2 * len);\n    var nodeWidthRatio_1 = options.nodeWidthRatio;\n    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {\n      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');\n    }\n    var totalValue_1 = 0;\n    nodes.forEach(function (node) {\n      totalValue_1 += node.value;\n    });\n    nodes.forEach(function (node) {\n      node.weight = node.value / totalValue_1;\n      node.width = node.weight * (1 - nodePaddingRatio_1);\n      node.height = nodeWidthRatio_1;\n    });\n    nodes.forEach(function (node, index) {\n      // x\n      var deltaX = 0;\n      for (var i = index - 1; i >= 0; i--) {\n        deltaX += nodes[i].width + 2 * margin_1;\n      }\n      var minX = node.minX = margin_1 + deltaX;\n      var maxX = node.maxX = node.minX + node.width;\n      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;\n      var maxY = node.maxY = minY + nodeWidthRatio_1;\n      node.x = [minX, maxX, maxX, minX];\n      node.y = [minY, minY, maxY, maxY];\n      /* points\n       * 3---2\n       * |   |\n       * 0---1\n       */\n      // node.x = minX + 0.5 * node.width;\n      // node.y = options.y;\n    });\n  } else {\n    var deltaX_1 = 1 / len;\n    nodes.forEach(function (node, index) {\n      node.x = (index + 0.5) * deltaX_1;\n      node.y = options.y;\n    });\n  }\n  return nodes;\n}\nfunction locatingEdges(nodeById, edges, options) {\n  if (options.weight) {\n    var valueById_1 = {};\n    forIn(nodeById, function (node, id) {\n      valueById_1[id] = node.value;\n    });\n    edges.forEach(function (edge) {\n      var sId = options.source(edge);\n      var tId = options.target(edge);\n      var sNode = nodeById[sId];\n      var tNode = nodeById[tId];\n      if (sNode && tNode) {\n        var sValue = valueById_1[sId];\n        var currentSValue = options.sourceWeight(edge);\n        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;\n        var sEnd = sStart + currentSValue / sNode.value * sNode.width;\n        valueById_1[sId] -= currentSValue;\n        var tValue = valueById_1[tId];\n        var currentTValue = options.targetWeight(edge);\n        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;\n        var tEnd = tStart + currentTValue / tNode.value * tNode.width;\n        valueById_1[tId] -= currentTValue;\n        var y = options.y;\n        edge.x = [sStart, sEnd, tStart, tEnd];\n        edge.y = [y, y, y, y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  } else {\n    edges.forEach(function (edge) {\n      var sNode = nodeById[options.source(edge)];\n      var tNode = nodeById[options.target(edge)];\n      if (sNode && tNode) {\n        edge.x = [sNode.x, tNode.x];\n        edge.y = [sNode.y, tNode.y];\n        // 将edge的source与target的id换为 sourceNode与targetNode\n        edge.source = sNode;\n        edge.target = tNode;\n      }\n    });\n  }\n  return edges;\n}\nexport function getDefaultOptions(options) {\n  return assign({}, DEFAULT_OPTIONS, options);\n}\nexport function chordLayout(chordLayoutOptions, chordLayoutInputData) {\n  var options = getDefaultOptions(chordLayoutOptions);\n  var nodeById = {};\n  var nodes = chordLayoutInputData.nodes;\n  var links = chordLayoutInputData.links;\n  nodes.forEach(function (node) {\n    var id = options.id(node);\n    nodeById[id] = node;\n  });\n  processGraph(nodeById, links, options);\n  sortNodes(nodes, options);\n  var outputNodes = layoutNodes(nodes, options);\n  var outputLinks = locatingEdges(nodeById, links, options);\n  return {\n    nodes: outputNodes,\n    links: outputLinks\n  };\n}","map":null,"metadata":{},"sourceType":"module"}