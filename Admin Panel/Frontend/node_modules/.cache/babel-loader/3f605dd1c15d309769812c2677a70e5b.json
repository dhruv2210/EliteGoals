{"ast":null,"code":"import { __read } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each } from '@antv/util';\nimport { getDistanceToCenter } from '../../../util/coordinate';\nfunction _points2path(points, isInCircle) {\n  var path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n  return path;\n}\nfunction _convertArr(arr, coord) {\n  var tmp = [arr[0]];\n  for (var i = 1, len = arr.length; i < len; i = i + 2) {\n    var point = coord.convert({\n      x: arr[i],\n      y: arr[i + 1]\n    });\n    tmp.push(point.x, point.y);\n  }\n  return tmp;\n}\nfunction _convertArcPath(path, coord) {\n  var isTransposed = coord.isTransposed;\n  var r = path[1];\n  var x = path[6];\n  var y = path[7];\n  var point = coord.convert({\n    x: x,\n    y: y\n  });\n  var direction = isTransposed ? 0 : 1;\n  return ['A', r, r, 0, 0, direction, point.x, point.y];\n}\nfunction _convertPolarPath(pre, cur, coord) {\n  var isTransposed = coord.isTransposed,\n    startAngle = coord.startAngle,\n    endAngle = coord.endAngle;\n  var prePoint = pre[0].toLowerCase() === 'a' ? {\n    x: pre[6],\n    y: pre[7]\n  } : {\n    x: pre[1],\n    y: pre[2]\n  };\n  var curPoint = {\n    x: cur[1],\n    y: cur[2]\n  };\n  var rst = [];\n  var xDim = isTransposed ? 'y' : 'x';\n  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);\n  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 圆弧的方向\n  var flag = angleRange > Math.PI ? 1 : 0; // 大弧还是小弧标志位\n  var convertPoint = coord.convert(curPoint);\n  var r = getDistanceToCenter(coord, convertPoint);\n  if (r >= 0.5) {\n    // 小于1像素的圆在图像上无法识别\n    if (angleRange === Math.PI * 2) {\n      var middlePoint = {\n        x: (curPoint.x + prePoint.x) / 2,\n        y: (curPoint.y + prePoint.y) / 2\n      };\n      var middleConvertPoint = coord.convert(middlePoint);\n      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    } else {\n      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);\n    }\n  }\n  return rst;\n}\n// 当存在整体的圆时，去除圆前面和后面的线，防止出现直线穿过整个圆的情形\nfunction _filterFullCirleLine(path) {\n  each(path, function (subPath, index) {\n    var cur = subPath;\n    if (cur[0].toLowerCase() === 'a') {\n      var pre = path[index - 1];\n      var next = path[index + 1];\n      if (next && next[0].toLowerCase() === 'a') {\n        if (pre && pre[0].toLowerCase() === 'l') {\n          pre[0] = 'M';\n        }\n      } else if (pre && pre[0].toLowerCase() === 'a') {\n        if (next && next[0].toLowerCase() === 'l') {\n          next[0] = 'M';\n        }\n      }\n    }\n  });\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport var smoothBezier = function smoothBezier(points, smooth, isLoop, constraint) {\n  var _a;\n  var cps = [];\n  var hasConstraint = !!constraint;\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n  var nextCp0;\n  var cp1;\n  var cp0;\n  if (hasConstraint) {\n    _a = __read(constraint, 2), min = _a[0], max = _a[1];\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if (i === 0 && !isLoop) {\n      cp0 = point;\n    } else if (i === len - 1 && !isLoop) {\n      cp1 = point;\n      cps.push(cp0);\n      cps.push(cp1);\n    } else {\n      prevPoint = points[isLoop ? i ? i - 1 : len - 1 : i - 1];\n      nextPoint = points[isLoop ? (i + 1) % len : i + 1];\n      var v = [0, 0];\n      v = vec2.sub(v, nextPoint, prevPoint);\n      v = vec2.scale(v, v, smooth);\n      var d0 = vec2.distance(point, prevPoint);\n      var d1 = vec2.distance(point, nextPoint);\n      var sum = d0 + d1;\n      if (sum !== 0) {\n        d0 /= sum;\n        d1 /= sum;\n      }\n      var v1 = vec2.scale([0, 0], v, -d0);\n      var v2 = vec2.scale([0, 0], v, d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      nextCp0 = vec2.add([0, 0], point, v2);\n      // 下一个控制点必须在这个点和下一个点之间\n      nextCp0 = vec2.min([0, 0], nextCp0, vec2.max([0, 0], nextPoint, point));\n      nextCp0 = vec2.max([0, 0], nextCp0, vec2.min([0, 0], nextPoint, point));\n      // 重新计算 cp1 的值\n      v1 = vec2.sub([0, 0], nextCp0, point);\n      v1 = vec2.scale([0, 0], v1, -d0 / d1);\n      cp1 = vec2.add([0, 0], point, v1);\n      // 上一个控制点必须要在上一个点和这一个点之间\n      cp1 = vec2.min([0, 0], cp1, vec2.max([0, 0], prevPoint, point));\n      cp1 = vec2.max([0, 0], cp1, vec2.min([0, 0], prevPoint, point));\n      // 重新计算 nextCp0 的值\n      v2 = vec2.sub([0, 0], point, cp1);\n      v2 = vec2.scale([0, 0], v2, d1 / d0);\n      nextCp0 = vec2.add([0, 0], point, v2);\n      if (hasConstraint) {\n        cp1 = vec2.max([0, 0], cp1, min);\n        cp1 = vec2.min([0, 0], cp1, max);\n        nextCp0 = vec2.max([0, 0], nextCp0, min);\n        nextCp0 = vec2.min([0, 0], nextCp0, max);\n      }\n      cps.push(cp0);\n      cps.push(cp1);\n      cp0 = nextCp0;\n    }\n  }\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n/**\n * @ignore\n * 将点连接成路径 path\n */\nexport function getLinePath(points, isInCircle) {\n  return _points2path(points, isInCircle);\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points, isInCircle);\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  var constraint = constaint || [\n  // 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n/**\n * @ignore\n * 将归一化后的路径数据转换成坐标\n */\nexport function convertNormalPath(coord, path) {\n  var tmp = [];\n  each(path, function (subPath) {\n    var action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'l':\n      case 'c':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  return tmp;\n}\n/**\n * @ignore\n * 将路径转换为极坐标下的真实路径\n */\nexport function convertPolarPath(coord, path) {\n  var tmp = [];\n  var pre;\n  var cur;\n  var transposed;\n  var equals;\n  each(path, function (subPath, index) {\n    var action = subPath[0];\n    switch (action.toLowerCase()) {\n      case 'm':\n      case 'c':\n      case 'q':\n        tmp.push(_convertArr(subPath, coord));\n        break;\n      case 'l':\n        pre = path[index - 1];\n        cur = subPath;\n        transposed = coord.isTransposed;\n        // 是否半径相同，转换成圆弧\n        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];\n        if (equals) {\n          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));\n        } else {\n          // y 不相等，所以直接转换\n          tmp.push(_convertArr(subPath, coord));\n        }\n        break;\n      case 'a':\n        tmp.push(_convertArcPath(subPath, coord));\n        break;\n      case 'z':\n      default:\n        tmp.push(subPath);\n        break;\n    }\n  });\n  _filterFullCirleLine(tmp); // 过滤多余的直线\n  return tmp;\n}","map":null,"metadata":{},"sourceType":"module"}