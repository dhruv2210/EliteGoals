{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { isArray, isFunction, isString } from '@antv/util';\nimport { getContainerSize, LEVEL, log } from '../../utils';\nimport { normalPadding } from '../../utils/padding';\nimport { functor, wordCloud } from '../../utils/transform/word-cloud';\n/**\n * 用 DataSet 转换词云图数据\n * @param params\n */\nexport function transform(params) {\n  var rawOptions = params.options,\n    chart = params.chart;\n  var _a = chart,\n    width = _a.width,\n    height = _a.height,\n    chartPadding = _a.padding,\n    appendPadding = _a.appendPadding,\n    ele = _a.ele;\n  var data = rawOptions.data,\n    imageMask = rawOptions.imageMask,\n    wordField = rawOptions.wordField,\n    weightField = rawOptions.weightField,\n    colorField = rawOptions.colorField,\n    wordStyle = rawOptions.wordStyle,\n    timeInterval = rawOptions.timeInterval,\n    random = rawOptions.random,\n    spiral = rawOptions.spiral,\n    _b = rawOptions.autoFit,\n    autoFit = _b === void 0 ? true : _b,\n    placementStrategy = rawOptions.placementStrategy;\n  if (!data || !data.length) {\n    return [];\n  }\n  var fontFamily = wordStyle.fontFamily,\n    fontWeight = wordStyle.fontWeight,\n    padding = wordStyle.padding,\n    fontSize = wordStyle.fontSize;\n  var arr = getSingleKeyValues(data, weightField);\n  var range = [min(arr), max(arr)];\n  // 变换出 text 和 value 字段\n  var words = data.map(function (datum) {\n    return {\n      text: datum[wordField],\n      value: datum[weightField],\n      color: datum[colorField],\n      datum: datum\n    };\n  });\n  var options = {\n    imageMask: imageMask,\n    font: fontFamily,\n    fontSize: getFontSizeMapping(fontSize, range),\n    fontWeight: fontWeight,\n    // 图表宽高减去 padding 之后的宽高\n    size: getSize({\n      width: width,\n      height: height,\n      padding: chartPadding,\n      appendPadding: appendPadding,\n      autoFit: autoFit,\n      container: ele\n    }),\n    padding: padding,\n    timeInterval: timeInterval,\n    random: random,\n    spiral: spiral,\n    rotate: getRotate(rawOptions)\n  };\n  // 自定义布局函数\n  if (isFunction(placementStrategy)) {\n    var result = words.map(function (word, index, words) {\n      return __assign(__assign(__assign({}, word), {\n        hasText: !!word.text,\n        font: functor(options.font)(word, index, words),\n        weight: functor(options.fontWeight)(word, index, words),\n        rotate: functor(options.rotate)(word, index, words),\n        size: functor(options.fontSize)(word, index, words),\n        style: 'normal'\n      }), placementStrategy.call(chart, word, index, words));\n    });\n    // 添加两个参照数据，分别表示左上角和右下角\n    result.push({\n      text: '',\n      value: 0,\n      x: 0,\n      y: 0,\n      opacity: 0\n    });\n    result.push({\n      text: '',\n      value: 0,\n      x: options.size[0],\n      y: options.size[1],\n      opacity: 0\n    });\n    return result;\n  }\n  // 数据准备在外部做，wordCloud 单纯就是做布局\n  return wordCloud(words, options);\n}\n/**\n * 获取最终的实际绘图尺寸：[width, height]\n * @param chart\n */\nexport function getSize(options) {\n  var width = options.width,\n    height = options.height;\n  var container = options.container,\n    autoFit = options.autoFit,\n    padding = options.padding,\n    appendPadding = options.appendPadding;\n  // 由于词云图每个词语的坐标都是先通过 DataSet 根据图表宽高计算出来的，\n  // 也就是说，如果一开始提供给 DataSet 的宽高信息和最终显示的宽高不相同，\n  // 那么就会出现布局错乱的情况，所以这里处理的目的就是让一开始提供给 DataSet 的\n  // 宽高信息与最终显示的宽高信息相同，避免显示错乱。\n  if (autoFit) {\n    var containerSize = getContainerSize(container);\n    width = containerSize.width;\n    height = containerSize.height;\n  }\n  // 宽高不能为 0，否则会造成死循环\n  width = width || 400;\n  height = height || 400;\n  var _a = resolvePadding({\n      padding: padding,\n      appendPadding: appendPadding\n    }),\n    top = _a[0],\n    right = _a[1],\n    bottom = _a[2],\n    left = _a[3];\n  var result = [width - (left + right), height - (top + bottom)];\n  return result;\n}\n/**\n * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding\n * @param chart\n */\nfunction resolvePadding(options) {\n  var padding = normalPadding(options.padding);\n  var appendPadding = normalPadding(options.appendPadding);\n  var top = padding[0] + appendPadding[0];\n  var right = padding[1] + appendPadding[1];\n  var bottom = padding[2] + appendPadding[2];\n  var left = padding[3] + appendPadding[3];\n  return [top, right, bottom, left];\n}\n/**\n * 处理 imageMask 可能为 url 字符串的情况\n * @param  {HTMLImageElement | string} img\n * @return {Promise}\n */\nexport function processImageMask(img) {\n  return new Promise(function (res, rej) {\n    if (img instanceof HTMLImageElement) {\n      res(img);\n      return;\n    }\n    if (isString(img)) {\n      var image_1 = new Image();\n      image_1.crossOrigin = 'anonymous';\n      image_1.src = img;\n      image_1.onload = function () {\n        res(image_1);\n      };\n      image_1.onerror = function () {\n        log(LEVEL.ERROR, false, 'image %s load failed !!!', img);\n        rej();\n      };\n      return;\n    }\n    log(LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');\n    rej();\n  });\n}\n/**\n * 把用户提供的 fontSize 值转换成符合 DataSet 要求的值\n * @param options\n * @param range\n */\nexport function getFontSizeMapping(fontSize, range) {\n  if (isFunction(fontSize)) {\n    return fontSize;\n  }\n  if (isArray(fontSize)) {\n    var fMin_1 = fontSize[0],\n      fMax_1 = fontSize[1];\n    if (!range) {\n      return function () {\n        return (fMax_1 + fMin_1) / 2;\n      };\n    }\n    var min_1 = range[0],\n      max_1 = range[1];\n    if (max_1 === min_1) {\n      return function () {\n        return (fMax_1 + fMin_1) / 2;\n      };\n    }\n    return function fontSize(_a) {\n      var value = _a.value;\n      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value - min_1) + fMin_1;\n    };\n  }\n  return function () {\n    return fontSize;\n  };\n}\nexport function getSingleKeyValues(data, key) {\n  return data.map(function (v) {\n    return v[key];\n  }).filter(function (v) {\n    // 过滤非 number\n    if (typeof v === 'number' && !isNaN(v)) return true;\n    return false;\n  });\n}\n/**\n * 把用户提供的关于旋转角度的字段值转换成符合 DataSet 要求的值\n * @param options\n */\nfunction getRotate(options) {\n  var _a = resolveRotate(options),\n    rotation = _a.rotation,\n    rotationSteps = _a.rotationSteps;\n  if (!isArray(rotation)) return rotation;\n  var min = rotation[0];\n  var max = rotation[1];\n  // 等于 1 时不旋转，所以把每份大小设为 0\n  var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);\n  return function rotate() {\n    if (max === min) return max;\n    return Math.floor(Math.random() * rotationSteps) * perSize;\n  };\n}\n/**\n * 确保值在要求范围内\n * @param options\n */\nfunction resolveRotate(options) {\n  var rotationSteps = options.wordStyle.rotationSteps;\n  if (rotationSteps < 1) {\n    log(LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');\n    rotationSteps = 1;\n  }\n  return {\n    rotation: options.wordStyle.rotation,\n    rotationSteps: rotationSteps\n  };\n}\n/**\n * 传入一个元素为数字的数组，\n * 返回该数组中值最小的数字。\n * @param numbers\n */\nfunction min(numbers) {\n  return Math.min.apply(Math, numbers);\n}\n/**\n * 传入一个元素为数字的数组，\n * 返回该数组中值最大的数字。\n * @param numbers\n */\nfunction max(numbers) {\n  return Math.max.apply(Math, numbers);\n}","map":null,"metadata":{},"sourceType":"module"}