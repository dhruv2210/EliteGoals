{"ast":null,"code":"import { toArray } from '@antv/util';\nimport { SHAPE_TO_TAGS } from '../constant';\n/**\n * 创建并返回图形的 svg 元素\n * @param type svg类型\n */\nexport function createSVGElement(type) {\n  return document.createElementNS('http://www.w3.org/2000/svg', type);\n}\n/**\n * 创建并返回图形的 dom 元素\n * @param  {IShape} shape 图形\n * @return {SVGElement}\n */\nexport function createDom(shape) {\n  var type = SHAPE_TO_TAGS[shape.type];\n  var parent = shape.getParent();\n  if (!type) {\n    throw new Error(\"the type \" + shape.type + \" is not supported by svg\");\n  }\n  var element = createSVGElement(type);\n  if (shape.get('id')) {\n    element.id = shape.get('id');\n  }\n  shape.set('el', element);\n  shape.set('attrs', {});\n  // 对于 defs 下的 dom 节点，parent 为空，通过 context 统一挂载到 defs 节点下\n  if (parent) {\n    var parentNode = parent.get('el');\n    if (parentNode) {\n      parentNode.appendChild(element);\n    } else {\n      // parentNode maybe null for group\n      parentNode = parent.createDom();\n      parent.set('el', parentNode);\n      parentNode.appendChild(element);\n    }\n  }\n  return element;\n}\n/**\n * 对 dom 元素进行排序\n * @param {IElement} element  元素\n * @param {sorter}   function 排序函数\n */\nexport function sortDom(element, sorter) {\n  var el = element.get('el');\n  var childList = toArray(el.children).sort(sorter);\n  // create empty fragment\n  var fragment = document.createDocumentFragment();\n  childList.forEach(function (child) {\n    fragment.appendChild(child);\n  });\n  el.appendChild(fragment);\n}\n/**\n * 将 dom 元素移动到父元素下的指定位置\n * @param {SVGElement} element     dom 元素\n * @param {number}     targetIndex 目标位置(从 0 开始)\n */\nexport function moveTo(element, targetIndex) {\n  var parentNode = element.parentNode;\n  var siblings = Array.from(parentNode.childNodes).filter(\n  // 要求为元素节点，且不能为 defs 节点\n  function (node) {\n    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';\n  });\n  // 获取目标节点\n  var target = siblings[targetIndex];\n  var currentIndex = siblings.indexOf(element);\n  // 如果目标节点存在\n  if (target) {\n    // 当前索引 > 目标索引，直接插入到目标节点之前即可\n    if (currentIndex > targetIndex) {\n      parentNode.insertBefore(element, target);\n    } else if (currentIndex < targetIndex) {\n      // 当前索引 < 目标索引\n      // 获取目标节点的下一个节点\n      var targetNext = siblings[targetIndex + 1];\n      // 如果目标节点的下一个节点存在，插入到该节点之前\n      if (targetNext) {\n        parentNode.insertBefore(element, targetNext);\n      } else {\n        // 如果该节点不存在，则追加到末尾\n        parentNode.appendChild(element);\n      }\n    }\n  } else {\n    parentNode.appendChild(element);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}