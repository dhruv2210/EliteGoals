{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { setShadow, setTransform, setClip } from '../util/svg';\nimport { createDom } from '../util/dom';\nimport { refreshElement } from '../util/draw';\nimport { SVG_ATTR_MAP } from '../constant';\nimport * as Shape from './index';\nimport Group from '../group';\nimport { getBBoxMethod } from '@antv/g-base';\nvar ShapeBase = /** @class */function (_super) {\n  __extends(ShapeBase, _super);\n  function ShapeBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'svg';\n    _this.canFill = false;\n    _this.canStroke = false;\n    return _this;\n  }\n  ShapeBase.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    // 设置默认值\n    return __assign(__assign({}, attrs), {\n      lineWidth: 1,\n      lineAppendWidth: 0,\n      strokeOpacity: 1,\n      fillOpacity: 1\n    });\n  };\n  // 覆盖基类的 afterAttrsChange 方法\n  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {\n    _super.prototype.afterAttrsChange.call(this, targetAttrs);\n    var canvas = this.get('canvas');\n    // 只有挂载到画布下，才对元素进行实际渲染\n    if (canvas && canvas.get('autoDraw')) {\n      var context = canvas.get('context');\n      this.draw(context, targetAttrs);\n    }\n  };\n  ShapeBase.prototype.getShapeBase = function () {\n    return Shape;\n  };\n  ShapeBase.prototype.getGroupBase = function () {\n    return Group;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  ShapeBase.prototype.onCanvasChange = function (changeType) {\n    refreshElement(this, changeType);\n  };\n  ShapeBase.prototype.calculateBBox = function () {\n    var el = this.get('el');\n    var bbox = null;\n    // 包围盒计算依赖于绘制，如果还没有生成对应的 Dom 元素，则包围盒的长宽均为 0\n    if (el) {\n      bbox = el.getBBox();\n    } else {\n      var bboxMethod = getBBoxMethod(this.get('type'));\n      if (bboxMethod) {\n        bbox = bboxMethod(this);\n      }\n    }\n    if (bbox) {\n      var x = bbox.x,\n        y = bbox.y,\n        width = bbox.width,\n        height = bbox.height;\n      var lineWidth = this.getHitLineWidth();\n      var halfWidth = lineWidth / 2;\n      var minX = x - halfWidth;\n      var minY = y - halfWidth;\n      var maxX = x + width + halfWidth;\n      var maxY = y + height + halfWidth;\n      return {\n        x: minX,\n        y: minY,\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        width: width + lineWidth,\n        height: height + lineWidth\n      };\n    }\n    return {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  ShapeBase.prototype.isFill = function () {\n    var _a = this.attr(),\n      fill = _a.fill,\n      fillStyle = _a.fillStyle;\n    return (fill || fillStyle || this.isClipShape()) && this.canFill;\n  };\n  ShapeBase.prototype.isStroke = function () {\n    var _a = this.attr(),\n      stroke = _a.stroke,\n      strokeStyle = _a.strokeStyle;\n    return (stroke || strokeStyle) && this.canStroke;\n  };\n  ShapeBase.prototype.draw = function (context, targetAttrs) {\n    var el = this.get('el');\n    if (this.get('destroyed')) {\n      if (el) {\n        el.parentNode.removeChild(el);\n      }\n    } else {\n      if (!el) {\n        createDom(this);\n      }\n      setClip(this, context);\n      this.createPath(context, targetAttrs);\n      this.shadow(context, targetAttrs);\n      this.strokeAndFill(context, targetAttrs);\n      this.transform(targetAttrs);\n    }\n  };\n  /**\n   * @protected\n   * 绘制图形的路径\n   * @param {Defs} context 上下文\n   * @param {ShapeAttrs} targetAttrs 渲染的目标属性\n   */\n  ShapeBase.prototype.createPath = function (context, targetAttrs) {};\n  // stroke and fill\n  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {\n    var attrs = targetAttrs || this.attr();\n    var fill = attrs.fill,\n      fillStyle = attrs.fillStyle,\n      stroke = attrs.stroke,\n      strokeStyle = attrs.strokeStyle,\n      fillOpacity = attrs.fillOpacity,\n      strokeOpacity = attrs.strokeOpacity,\n      lineWidth = attrs.lineWidth;\n    var el = this.get('el');\n    if (this.canFill) {\n      // 初次渲染和更新渲染的逻辑有所不同: 初次渲染值为空时，需要设置为 none，否则就会是黑色，而更新渲染则不需要\n      if (!targetAttrs) {\n        this._setColor(context, 'fill', fill || fillStyle);\n      } else if ('fill' in attrs) {\n        this._setColor(context, 'fill', fill);\n      } else if ('fillStyle' in attrs) {\n        // compatible with fillStyle\n        this._setColor(context, 'fill', fillStyle);\n      }\n      if (fillOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['fillOpacity'], fillOpacity);\n      }\n    }\n    if (this.canStroke && lineWidth > 0) {\n      if (!targetAttrs) {\n        this._setColor(context, 'stroke', stroke || strokeStyle);\n      } else if ('stroke' in attrs) {\n        this._setColor(context, 'stroke', stroke);\n      } else if ('strokeStyle' in attrs) {\n        // compatible with strokeStyle\n        this._setColor(context, 'stroke', strokeStyle);\n      }\n      if (strokeOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);\n      }\n      if (lineWidth) {\n        el.setAttribute(SVG_ATTR_MAP['lineWidth'], lineWidth);\n      }\n    }\n  };\n  ShapeBase.prototype._setColor = function (context, attr, value) {\n    var el = this.get('el');\n    if (!value) {\n      // need to set `none` to avoid default value\n      el.setAttribute(SVG_ATTR_MAP[attr], 'none');\n      return;\n    }\n    value = value.trim();\n    if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {\n      var id = context.find('gradient', value);\n      if (!id) {\n        id = context.addGradient(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n    } else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {\n      var id = context.find('pattern', value);\n      if (!id) {\n        id = context.addPattern(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n    } else {\n      el.setAttribute(SVG_ATTR_MAP[attr], value);\n    }\n  };\n  ShapeBase.prototype.shadow = function (context, targetAttrs) {\n    var attrs = this.attr();\n    var _a = targetAttrs || attrs,\n      shadowOffsetX = _a.shadowOffsetX,\n      shadowOffsetY = _a.shadowOffsetY,\n      shadowBlur = _a.shadowBlur,\n      shadowColor = _a.shadowColor;\n    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {\n      setShadow(this, context);\n    }\n  };\n  ShapeBase.prototype.transform = function (targetAttrs) {\n    var attrs = this.attr();\n    var matrix = (targetAttrs || attrs).matrix;\n    if (matrix) {\n      setTransform(this);\n    }\n  };\n  ShapeBase.prototype.isInShape = function (refX, refY) {\n    return this.isPointInPath(refX, refY);\n  };\n  ShapeBase.prototype.isPointInPath = function (refX, refY) {\n    var el = this.get('el');\n    var canvas = this.get('canvas');\n    var bbox = canvas.get('el').getBoundingClientRect();\n    var clientX = refX + bbox.left;\n    var clientY = refY + bbox.top;\n    var element = document.elementFromPoint(clientX, clientY);\n    if (element && element.isEqualNode(el)) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * 获取线拾取的宽度\n   * @returns {number} 线的拾取宽度\n   */\n  ShapeBase.prototype.getHitLineWidth = function () {\n    var _a = this.attrs,\n      lineWidth = _a.lineWidth,\n      lineAppendWidth = _a.lineAppendWidth;\n    if (this.isStroke()) {\n      return lineWidth + lineAppendWidth;\n    }\n    return 0;\n  };\n  return ShapeBase;\n}(AbstractShape);\nexport default ShapeBase;","map":null,"metadata":{},"sourceType":"module"}