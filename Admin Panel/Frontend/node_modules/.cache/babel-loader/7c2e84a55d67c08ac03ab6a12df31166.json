{"ast":null,"code":"import { __assign, __extends, __values } from \"tslib\";\nimport { deepMix, find, get, isEqual, isFunction, mix, isString, isBoolean, flatten, isArray } from '@antv/util';\nimport { Crosshair, HtmlTooltip } from '../../dependents';\nimport { getAngleByPoint, getDistanceToCenter, getCoordinateClipCfg } from '../../util/coordinate';\nimport { polarToCartesian } from '../../util/graphics';\nimport { findItemsFromView } from '../../util/tooltip';\nimport { BBox } from '../../util/bbox';\nimport { Controller } from './base';\nimport Event from '../event';\n// Filter duplicates, use `name`, `color`, `value` and `title` property values as condition\nfunction uniq(items) {\n  var uniqItems = [];\n  var _loop_1 = function _loop_1(index) {\n    var item = items[index];\n    var result = find(uniqItems, function (subItem) {\n      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;\n    });\n    if (!result) {\n      uniqItems.push(item);\n    }\n  };\n  for (var index = 0; index < items.length; index++) {\n    _loop_1(index);\n  }\n  return uniqItems;\n}\n/** @ignore */\nvar Tooltip = /** @class */function (_super) {\n  __extends(Tooltip, _super);\n  function Tooltip() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.isLocked = false;\n    return _this;\n  }\n  Object.defineProperty(Tooltip.prototype, \"name\", {\n    get: function get() {\n      return 'tooltip';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Tooltip.prototype.init = function () {};\n  Tooltip.prototype.isVisible = function () {\n    var option = this.view.getOptions().tooltip;\n    return option !== false;\n  };\n  Tooltip.prototype.render = function () {};\n  /**\n   * Shows tooltip\n   * @param point\n   */\n  Tooltip.prototype.showTooltip = function (point) {\n    this.point = point;\n    if (!this.isVisible()) {\n      // 如果设置 tooltip(false) 则始终不显示\n      return;\n    }\n    var view = this.view;\n    var items = this.getTooltipItems(point);\n    if (!items.length) {\n      // 无内容则不展示，同时 tooltip 需要隐藏\n      this.hideTooltip();\n      return;\n    }\n    var title = this.getTitle(items);\n    var dataPoint = {\n      x: items[0].x,\n      y: items[0].y\n    }; // 数据点位置\n    view.emit('tooltip:show', Event.fromData(view, 'tooltip:show', __assign({\n      items: items,\n      title: title\n    }, point)));\n    var cfg = this.getTooltipCfg();\n    var follow = cfg.follow,\n      showMarkers = cfg.showMarkers,\n      showCrosshairs = cfg.showCrosshairs,\n      showContent = cfg.showContent,\n      marker = cfg.marker;\n    var lastItems = this.items;\n    var lastTitle = this.title;\n    if (!isEqual(lastTitle, title) || !isEqual(lastItems, items)) {\n      // 内容发生变化了更新 tooltip\n      view.emit('tooltip:change', Event.fromData(view, 'tooltip:change', __assign({\n        items: items,\n        title: title\n      }, point)));\n      if (isFunction(showContent) ? showContent(items) : showContent) {\n        // 展示 tooltip 内容框才渲染 tooltip\n        if (!this.tooltip) {\n          // 延迟生成\n          this.renderTooltip();\n        }\n        this.tooltip.update(mix({}, cfg, {\n          items: this.getItemsAfterProcess(items),\n          title: title\n        }, follow ? point : {}));\n        this.tooltip.show();\n      }\n      if (showMarkers) {\n        // 展示 tooltipMarkers，tooltipMarkers 跟随数据\n        this.renderTooltipMarkers(items, marker);\n      }\n    } else {\n      // 内容未发生变化，则更新位置\n      if (this.tooltip && follow) {\n        this.tooltip.update(point);\n        this.tooltip.show(); // tooltip 有可能被隐藏，需要保证显示状态\n      }\n\n      if (this.tooltipMarkersGroup) {\n        this.tooltipMarkersGroup.show();\n      }\n    }\n    this.items = items;\n    this.title = title;\n    if (showCrosshairs) {\n      // 展示 tooltip 辅助线\n      var isCrosshairsFollowCursor = get(cfg, ['crosshairs', 'follow'], false); // 辅助线是否要跟随鼠标\n      this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);\n    }\n  };\n  Tooltip.prototype.hideTooltip = function () {\n    var follow = this.getTooltipCfg().follow;\n    if (!follow) {\n      this.point = null;\n      return;\n    }\n    // hide the tooltipMarkers\n    var tooltipMarkersGroup = this.tooltipMarkersGroup;\n    if (tooltipMarkersGroup) {\n      tooltipMarkersGroup.hide();\n    }\n    // hide crosshairs\n    var xCrosshair = this.xCrosshair;\n    var yCrosshair = this.yCrosshair;\n    if (xCrosshair) {\n      xCrosshair.hide();\n    }\n    if (yCrosshair) {\n      yCrosshair.hide();\n    }\n    var tooltip = this.tooltip;\n    if (tooltip) {\n      tooltip.hide();\n    }\n    this.view.emit('tooltip:hide', Event.fromData(this.view, 'tooltip:hide', {}));\n    this.point = null;\n  };\n  /**\n   * lockTooltip\n   */\n  Tooltip.prototype.lockTooltip = function () {\n    this.isLocked = true;\n    if (this.tooltip) {\n      // tooltip contianer 可捕获事件\n      this.tooltip.setCapture(true);\n    }\n  };\n  /**\n   * unlockTooltip\n   */\n  Tooltip.prototype.unlockTooltip = function () {\n    this.isLocked = false;\n    var cfg = this.getTooltipCfg();\n    if (this.tooltip) {\n      // 重置 capture 属性\n      this.tooltip.setCapture(cfg.capture);\n    }\n  };\n  /**\n   * isTooltipLocked\n   */\n  Tooltip.prototype.isTooltipLocked = function () {\n    return this.isLocked;\n  };\n  Tooltip.prototype.clear = function () {\n    var _a = this,\n      tooltip = _a.tooltip,\n      xCrosshair = _a.xCrosshair,\n      yCrosshair = _a.yCrosshair,\n      tooltipMarkersGroup = _a.tooltipMarkersGroup;\n    if (tooltip) {\n      tooltip.hide();\n      tooltip.clear();\n    }\n    if (xCrosshair) {\n      xCrosshair.clear();\n    }\n    if (yCrosshair) {\n      yCrosshair.clear();\n    }\n    if (tooltipMarkersGroup) {\n      tooltipMarkersGroup.clear();\n    }\n    // 如果 customContent 不为空，就重新生成 tooltip\n    if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.get('customContent')) {\n      this.tooltip.destroy();\n      this.tooltip = null;\n    }\n    // title 和 items 需要清空, 否则 tooltip 内容会出现置空的情况\n    // 即：需要走进 !isEqual(lastTitle, title) || !isEqual(lastItems, items) 的逻辑，更新 tooltip 的内容\n    this.title = null;\n    this.items = null;\n  };\n  Tooltip.prototype.destroy = function () {\n    if (this.tooltip) {\n      this.tooltip.destroy();\n    }\n    if (this.xCrosshair) {\n      this.xCrosshair.destroy();\n    }\n    if (this.yCrosshair) {\n      this.yCrosshair.destroy();\n    }\n    if (this.guideGroup) {\n      this.guideGroup.remove(true);\n    }\n    this.reset();\n  };\n  Tooltip.prototype.reset = function () {\n    this.items = null;\n    this.title = null;\n    this.tooltipMarkersGroup = null;\n    this.tooltipCrosshairsGroup = null;\n    this.xCrosshair = null;\n    this.yCrosshair = null;\n    this.tooltip = null;\n    this.guideGroup = null;\n    this.isLocked = false;\n    this.point = null;\n  };\n  Tooltip.prototype.changeVisible = function (visible) {\n    if (this.visible === visible) {\n      return;\n    }\n    var _a = this,\n      tooltip = _a.tooltip,\n      tooltipMarkersGroup = _a.tooltipMarkersGroup,\n      xCrosshair = _a.xCrosshair,\n      yCrosshair = _a.yCrosshair;\n    if (visible) {\n      if (tooltip) {\n        tooltip.show();\n      }\n      if (tooltipMarkersGroup) {\n        tooltipMarkersGroup.show();\n      }\n      if (xCrosshair) {\n        xCrosshair.show();\n      }\n      if (yCrosshair) {\n        yCrosshair.show();\n      }\n    } else {\n      if (tooltip) {\n        tooltip.hide();\n      }\n      if (tooltipMarkersGroup) {\n        tooltipMarkersGroup.hide();\n      }\n      if (xCrosshair) {\n        xCrosshair.hide();\n      }\n      if (yCrosshair) {\n        yCrosshair.hide();\n      }\n    }\n    this.visible = visible;\n  };\n  Tooltip.prototype.getTooltipItems = function (point) {\n    var e_1, _a, e_2, _b, e_3, _c;\n    var items = this.findItemsFromView(this.view, point);\n    if (items.length) {\n      // 三层\n      items = flatten(items);\n      try {\n        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {\n          var itemArr = items_1_1.value;\n          try {\n            for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {\n              var item = itemArr_1_1.value;\n              var _d = item.mappingData,\n                x = _d.x,\n                y = _d.y;\n              item.x = isArray(x) ? x[x.length - 1] : x;\n              item.y = isArray(y) ? y[y.length - 1] : y;\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return)) _b.call(itemArr_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      var shared = this.getTooltipCfg().shared;\n      // shared: false 代表只显示当前拾取到的 shape 的数据，但是一个 view 会有多个 Geometry，所以有可能会拾取到多个 shape\n      if (shared === false && items.length > 1) {\n        var snapItem = items[0];\n        var min = Math.abs(point.y - snapItem[0].y);\n        try {\n          for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {\n            var aItem = items_2_1.value;\n            var yDistance = Math.abs(point.y - aItem[0].y);\n            if (yDistance <= min) {\n              snapItem = aItem;\n              min = yDistance;\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (items_2_1 && !items_2_1.done && (_c = items_2.return)) _c.call(items_2);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n        items = [snapItem];\n      }\n      return uniq(flatten(items));\n    }\n    return [];\n  };\n  Tooltip.prototype.layout = function () {};\n  Tooltip.prototype.update = function () {\n    if (this.point) {\n      this.showTooltip(this.point);\n    }\n    if (this.tooltip) {\n      // #2279 修复resize之后tooltip越界的问题\n      // 确保tooltip已经创建的情况下\n      var canvas = this.view.getCanvas();\n      // TODO 逍为 tooltip 的区域不应该是 canvas，而应该是整个 特别是在图比较小的时候\n      // 更新 region\n      this.tooltip.set('region', {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: canvas.get('width'),\n          y: canvas.get('height')\n        }\n      });\n    }\n  };\n  /**\n   * 当前鼠标点是在 enter tooltip 中\n   * @param point\n   */\n  Tooltip.prototype.isCursorEntered = function (point) {\n    // 是可捕获的，并且点在 tooltip dom 上\n    if (this.tooltip) {\n      var el = this.tooltip.getContainer();\n      var capture = this.tooltip.get('capture');\n      if (el && capture) {\n        var _a = el.getBoundingClientRect(),\n          x = _a.x,\n          y = _a.y,\n          width = _a.width,\n          height = _a.height;\n        return new BBox(x, y, width, height).isPointIn(point);\n      }\n    }\n    return false;\n  };\n  // 获取 tooltip 配置，因为用户可能会通过 view.tooltip() 重新配置 tooltip，所以就不做缓存，每次直接读取\n  Tooltip.prototype.getTooltipCfg = function () {\n    var view = this.view;\n    var option = view.getOptions().tooltip;\n    var processOption = this.processCustomContent(option);\n    var theme = view.getTheme();\n    var defaultCfg = get(theme, ['components', 'tooltip'], {});\n    var enterable = get(processOption, 'enterable', defaultCfg.enterable);\n    return deepMix({}, defaultCfg, processOption, {\n      capture: enterable || this.isLocked ? true : false\n    });\n  };\n  // process customContent\n  Tooltip.prototype.processCustomContent = function (option) {\n    if (isBoolean(option) || !get(option, 'customContent')) {\n      return option;\n    }\n    var currentCustomContent = option.customContent;\n    var customContent = function customContent(title, items) {\n      var content = currentCustomContent(title, items) || '';\n      return isString(content) ? '<div class=\"g2-tooltip\">' + content + '</div>' : content;\n    };\n    return __assign(__assign({}, option), {\n      customContent: customContent\n    });\n  };\n  Tooltip.prototype.getTitle = function (items) {\n    var title = items[0].title || items[0].name;\n    this.title = title;\n    return title;\n  };\n  Tooltip.prototype.renderTooltip = function () {\n    var canvas = this.view.getCanvas();\n    var region = {\n      start: {\n        x: 0,\n        y: 0\n      },\n      end: {\n        x: canvas.get('width'),\n        y: canvas.get('height')\n      }\n    };\n    var cfg = this.getTooltipCfg();\n    var tooltip = new HtmlTooltip(__assign(__assign({\n      parent: canvas.get('el').parentNode,\n      region: region\n    }, cfg), {\n      visible: false,\n      crosshairs: null\n    }));\n    tooltip.init();\n    this.tooltip = tooltip;\n  };\n  Tooltip.prototype.renderTooltipMarkers = function (items, marker) {\n    var e_4, _a;\n    var tooltipMarkersGroup = this.getTooltipMarkersGroup();\n    var rootView = this.view.getRootView();\n    var limitInPlot = rootView.limitInPlot;\n    try {\n      for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {\n        var item = items_3_1.value;\n        var x = item.x,\n          y = item.y;\n        // 有裁剪就剪切\n        if (limitInPlot || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {\n          var _b = getCoordinateClipCfg(rootView.getCoordinate()),\n            type = _b.type,\n            attrs_1 = _b.attrs;\n          tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip({\n            type: type,\n            attrs: attrs_1\n          });\n        } else {\n          // 清除已有的 clip\n          tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip(undefined);\n        }\n        var theme = this.view.getTheme();\n        var markerDefaultCfg = get(theme, ['components', 'tooltip', 'marker'], {});\n        var attrs = __assign(__assign({\n          fill: item.color,\n          symbol: 'circle',\n          shadowColor: item.color\n        }, isFunction(marker) ? __assign(__assign({}, markerDefaultCfg), marker(item)) : marker), {\n          x: x,\n          y: y\n        });\n        tooltipMarkersGroup.addShape('marker', {\n          attrs: attrs\n        });\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (items_3_1 && !items_3_1.done && (_a = items_3.return)) _a.call(items_3);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  };\n  Tooltip.prototype.renderCrosshairs = function (point, cfg) {\n    var crosshairsType = get(cfg, ['crosshairs', 'type'], 'x'); // 默认展示 x 轴上的辅助线\n    if (crosshairsType === 'x') {\n      if (this.yCrosshair) {\n        this.yCrosshair.hide();\n      }\n      this.renderXCrosshairs(point, cfg);\n    } else if (crosshairsType === 'y') {\n      if (this.xCrosshair) {\n        this.xCrosshair.hide();\n      }\n      this.renderYCrosshairs(point, cfg);\n    } else if (crosshairsType === 'xy') {\n      this.renderXCrosshairs(point, cfg);\n      this.renderYCrosshairs(point, cfg);\n    }\n  };\n  // 渲染 x 轴上的 tooltip 辅助线\n  Tooltip.prototype.renderXCrosshairs = function (point, tooltipCfg) {\n    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();\n    var start;\n    var end;\n    if (coordinate.isRect) {\n      if (coordinate.isTransposed) {\n        start = {\n          x: coordinate.start.x,\n          y: point.y\n        };\n        end = {\n          x: coordinate.end.x,\n          y: point.y\n        };\n      } else {\n        start = {\n          x: point.x,\n          y: coordinate.end.y\n        };\n        end = {\n          x: point.x,\n          y: coordinate.start.y\n        };\n      }\n    } else {\n      // 极坐标下 x 轴上的 crosshairs 表现为半径\n      var angle = getAngleByPoint(coordinate, point);\n      var center = coordinate.getCenter();\n      var radius = coordinate.getRadius();\n      end = polarToCartesian(center.x, center.y, radius, angle);\n      start = center;\n    }\n    var cfg = deepMix({\n      start: start,\n      end: end,\n      container: this.getTooltipCrosshairsGroup()\n    }, get(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('x', point, tooltipCfg));\n    delete cfg.type; // 与 Crosshairs 组件的 type 冲突故删除\n    var xCrosshair = this.xCrosshair;\n    if (xCrosshair) {\n      xCrosshair.update(cfg);\n    } else {\n      xCrosshair = new Crosshair.Line(cfg);\n      xCrosshair.init();\n    }\n    xCrosshair.render();\n    xCrosshair.show();\n    this.xCrosshair = xCrosshair;\n  };\n  // 渲染 y 轴上的辅助线\n  Tooltip.prototype.renderYCrosshairs = function (point, tooltipCfg) {\n    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();\n    var cfg;\n    var type;\n    if (coordinate.isRect) {\n      var start = void 0;\n      var end = void 0;\n      if (coordinate.isTransposed) {\n        start = {\n          x: point.x,\n          y: coordinate.end.y\n        };\n        end = {\n          x: point.x,\n          y: coordinate.start.y\n        };\n      } else {\n        start = {\n          x: coordinate.start.x,\n          y: point.y\n        };\n        end = {\n          x: coordinate.end.x,\n          y: point.y\n        };\n      }\n      cfg = {\n        start: start,\n        end: end\n      };\n      type = 'Line';\n    } else {\n      // 极坐标下 y 轴上的 crosshairs 表现为圆弧\n      cfg = {\n        center: coordinate.getCenter(),\n        // @ts-ignore\n        radius: getDistanceToCenter(coordinate, point),\n        startAngle: coordinate.startAngle,\n        endAngle: coordinate.endAngle\n      };\n      type = 'Circle';\n    }\n    cfg = deepMix({\n      container: this.getTooltipCrosshairsGroup()\n    }, cfg, get(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('y', point, tooltipCfg));\n    delete cfg.type; // 与 Crosshairs 组件的 type 冲突故删除\n    var yCrosshair = this.yCrosshair;\n    if (yCrosshair) {\n      // 如果坐标系发生直角坐标系与极坐标的切换操作\n      if (coordinate.isRect && yCrosshair.get('type') === 'circle' || !coordinate.isRect && yCrosshair.get('type') === 'line') {\n        yCrosshair = new Crosshair[type](cfg);\n        yCrosshair.init();\n      } else {\n        yCrosshair.update(cfg);\n      }\n    } else {\n      yCrosshair = new Crosshair[type](cfg);\n      yCrosshair.init();\n    }\n    yCrosshair.render();\n    yCrosshair.show();\n    this.yCrosshair = yCrosshair;\n  };\n  Tooltip.prototype.getCrosshairsText = function (type, point, tooltipCfg) {\n    var textCfg = get(tooltipCfg, ['crosshairs', 'text']);\n    var follow = get(tooltipCfg, ['crosshairs', 'follow']);\n    var items = this.items;\n    if (textCfg) {\n      var view = this.getViewWithGeometry(this.view);\n      // 需要展示文本\n      var firstItem = items[0];\n      var xScale = view.getXScale();\n      var yScale = view.getYScales()[0];\n      var xValue = void 0;\n      var yValue = void 0;\n      if (follow) {\n        // 如果需要跟随鼠标移动，就需要将当前鼠标坐标点转换为对应的数值\n        var invertPoint = this.view.getCoordinate().invert(point);\n        xValue = xScale.invert(invertPoint.x); // 转换为原始值\n        yValue = yScale.invert(invertPoint.y); // 转换为原始值\n      } else {\n        xValue = firstItem.data[xScale.field];\n        yValue = firstItem.data[yScale.field];\n      }\n      var content = type === 'x' ? xValue : yValue;\n      if (isFunction(textCfg)) {\n        textCfg = textCfg(type, content, items, point);\n      } else {\n        textCfg.content = content;\n      }\n      return {\n        text: textCfg\n      };\n    }\n  };\n  // 获取存储 tooltipMarkers 和 crosshairs 的容器\n  Tooltip.prototype.getGuideGroup = function () {\n    if (!this.guideGroup) {\n      var foregroundGroup = this.view.foregroundGroup;\n      this.guideGroup = foregroundGroup.addGroup({\n        name: 'tooltipGuide',\n        capture: false\n      });\n    }\n    return this.guideGroup;\n  };\n  // 获取 tooltipMarkers 存储的容器\n  Tooltip.prototype.getTooltipMarkersGroup = function () {\n    var tooltipMarkersGroup = this.tooltipMarkersGroup;\n    if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {\n      tooltipMarkersGroup.clear();\n      tooltipMarkersGroup.show();\n    } else {\n      tooltipMarkersGroup = this.getGuideGroup().addGroup({\n        name: 'tooltipMarkersGroup'\n      });\n      tooltipMarkersGroup.toFront();\n      this.tooltipMarkersGroup = tooltipMarkersGroup;\n    }\n    return tooltipMarkersGroup;\n  };\n  // 获取 tooltip crosshairs 存储的容器\n  Tooltip.prototype.getTooltipCrosshairsGroup = function () {\n    var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;\n    if (!tooltipCrosshairsGroup) {\n      tooltipCrosshairsGroup = this.getGuideGroup().addGroup({\n        name: 'tooltipCrosshairsGroup',\n        capture: false\n      });\n      tooltipCrosshairsGroup.toBack();\n      this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;\n    }\n    return tooltipCrosshairsGroup;\n  };\n  Tooltip.prototype.findItemsFromView = function (view, point) {\n    var e_5, _a;\n    if (view.getOptions().tooltip === false) {\n      // 如果 view 关闭了 tooltip\n      return [];\n    }\n    var tooltipCfg = this.getTooltipCfg();\n    var result = findItemsFromView(view, point, tooltipCfg);\n    try {\n      // 递归查找，并合并结果\n      for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var childView = _c.value;\n        result = result.concat(this.findItemsFromView(childView, point));\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n    return result;\n  };\n  // FIXME: hack 方法\n  // 因为 tooltip 的交互是挂载在 Chart 上，所以当chart 上没有绘制 Geometry 的时候，就查找不到数据，并且绘图区域同子 View 的区域不同\n  Tooltip.prototype.getViewWithGeometry = function (view) {\n    var _this = this;\n    if (view.geometries.length) {\n      return view;\n    }\n    return find(view.views, function (childView) {\n      return _this.getViewWithGeometry(childView);\n    });\n  };\n  /**\n   * 根据用户配置的 items 配置，来进行用户自定义的处理，并返回最终的 items\n   * 默认不做任何处理\n   */\n  Tooltip.prototype.getItemsAfterProcess = function (originalItems) {\n    var customItems = this.getTooltipCfg().customItems;\n    var fn = customItems ? customItems : function (v) {\n      return v;\n    };\n    return fn(originalItems);\n  };\n  return Tooltip;\n}(Controller);\nexport default Tooltip;","map":null,"metadata":{},"sourceType":"module"}