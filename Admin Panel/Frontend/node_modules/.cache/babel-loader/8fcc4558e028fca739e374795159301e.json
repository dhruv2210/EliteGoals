{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport { Action } from '@antv/g2';\nimport { get } from '@antv/util';\nimport { findViewById } from '../../../../utils';\nimport { EDGES_VIEW_ID, NODES_VIEW_ID } from '../../constant';\nvar SankeyNodeDragAction = /** @class */function (_super) {\n  __extends(SankeyNodeDragAction, _super);\n  function SankeyNodeDragAction() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * 是否在拖拽中的标记\n     */\n    _this.isDragging = false;\n    return _this;\n  }\n  /**\n   * 当前操作的是否是 element\n   */\n  SankeyNodeDragAction.prototype.isNodeElement = function () {\n    var shape = get(this.context, 'event.target');\n    if (shape) {\n      var element = shape.get('element');\n      return element && element.getModel().data.isNode;\n    }\n    return false;\n  };\n  SankeyNodeDragAction.prototype.getNodeView = function () {\n    return findViewById(this.context.view, NODES_VIEW_ID);\n  };\n  SankeyNodeDragAction.prototype.getEdgeView = function () {\n    return findViewById(this.context.view, EDGES_VIEW_ID);\n  };\n  /**\n   * 获取当前操作的 index\n   * @param element\n   */\n  SankeyNodeDragAction.prototype.getCurrentDatumIdx = function (element) {\n    return this.getNodeView().geometries[0].elements.indexOf(element);\n  };\n  /**\n   * 点击下去，开始\n   */\n  SankeyNodeDragAction.prototype.start = function () {\n    // 记录开始了的状态\n    if (this.isNodeElement()) {\n      this.prevPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y')\n      };\n      var element = this.context.event.target.get('element');\n      var idx = this.getCurrentDatumIdx(element);\n      if (idx === -1) {\n        return;\n      }\n      this.currentElementIdx = idx;\n      this.context.isDragging = true;\n      this.isDragging = true;\n      // 关闭动画并暂存配置\n      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;\n      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;\n      this.getNodeView().animate(false);\n      this.getEdgeView().animate(false);\n    }\n  };\n  /**\n   * 移动过程中，平移\n   */\n  SankeyNodeDragAction.prototype.translate = function () {\n    if (this.isDragging) {\n      var chart = this.context.view;\n      var currentPoint = {\n        x: get(this.context, 'event.x'),\n        y: get(this.context, 'event.y')\n      };\n      var x = currentPoint.x - this.prevPoint.x;\n      var y = currentPoint.y - this.prevPoint.y;\n      var nodeView = this.getNodeView();\n      var element = nodeView.geometries[0].elements[this.currentElementIdx];\n      // 修改数据\n      if (element && element.getModel()) {\n        var prevDatum = element.getModel().data;\n        var data = nodeView.getOptions().data;\n        var coordinate = nodeView.getCoordinate();\n        var datumGap_1 = {\n          x: x / coordinate.getWidth(),\n          y: y / coordinate.getHeight()\n        };\n        var nextDatum = __assign(__assign({}, prevDatum), {\n          x: prevDatum.x.map(function (x) {\n            return x += datumGap_1.x;\n          }),\n          y: prevDatum.y.map(function (y) {\n            return y += datumGap_1.y;\n          })\n        });\n        // 处理一下在 [0, 1] 范围\n        // 1. 更新 node 数据\n        var newData = __spreadArrays(data);\n        newData[this.currentElementIdx] = nextDatum;\n        nodeView.data(newData);\n        // 2. 更新 edge 数据\n        var name_1 = prevDatum.name;\n        var edgeView = this.getEdgeView();\n        var edgeData = edgeView.getOptions().data;\n        edgeData.forEach(function (datum) {\n          // 2.1 以该 node 为 source 的边，修改 [x0, x1, x2, x3] 中的 x0, x1\n          if (datum.source === name_1) {\n            datum.x[0] += datumGap_1.x;\n            datum.x[1] += datumGap_1.x;\n            datum.y[0] += datumGap_1.y;\n            datum.y[1] += datumGap_1.y;\n          }\n          // 2.2 以该 node 为 target 的边，修改 [x0, x1, x2, x3] 中的 x2, x3\n          if (datum.target === name_1) {\n            datum.x[2] += datumGap_1.x;\n            datum.x[3] += datumGap_1.x;\n            datum.y[2] += datumGap_1.y;\n            datum.y[3] += datumGap_1.y;\n          }\n        });\n        edgeView.data(edgeData);\n        // 3. 更新最新位置\n        this.prevPoint = currentPoint;\n        // node edge 都改变了，所以要从底层 render\n        chart.render(true);\n      }\n    }\n  };\n  /**\n   * 结论，清除状态\n   */\n  SankeyNodeDragAction.prototype.end = function () {\n    this.isDragging = false;\n    this.context.isDragging = false;\n    this.prevPoint = null;\n    this.currentElementIdx = null;\n    // 还原动画\n    this.getNodeView().animate(this.prevNodeAnimateCfg);\n    this.getEdgeView().animate(this.prevEdgeAnimateCfg);\n  };\n  return SankeyNodeDragAction;\n}(Action);\nexport { SankeyNodeDragAction };","map":null,"metadata":{},"sourceType":"module"}