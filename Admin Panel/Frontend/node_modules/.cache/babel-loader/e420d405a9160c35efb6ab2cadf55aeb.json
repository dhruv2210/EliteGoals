{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { max, min } from '@antv/util';\nimport Element from './element';\nimport { isFunction, isObject, each, removeFromArray, upperFirst, isAllowCapture } from '../util/util';\nvar SHAPE_MAP = {};\nvar INDEX = '_INDEX';\n/**\n * 设置 canvas\n * @param {IElement} element 元素\n * @param {ICanvas}  canvas  画布\n */\nfunction setCanvas(element, canvas) {\n  element.set('canvas', canvas);\n  if (element.isGroup()) {\n    var children = element.get('children');\n    if (children.length) {\n      children.forEach(function (child) {\n        setCanvas(child, canvas);\n      });\n    }\n  }\n}\n/**\n * 设置 timeline\n * @param {IElement} element  元素\n * @param {Timeline} timeline 时间轴\n */\nfunction setTimeline(element, timeline) {\n  element.set('timeline', timeline);\n  if (element.isGroup()) {\n    var children = element.get('children');\n    if (children.length) {\n      children.forEach(function (child) {\n        setTimeline(child, timeline);\n      });\n    }\n  }\n}\nfunction contains(container, element) {\n  var children = container.getChildren();\n  return children.indexOf(element) >= 0;\n}\nfunction removeChild(container, element, destroy) {\n  if (destroy === void 0) {\n    destroy = true;\n  }\n  // 不再调用 element.remove() 方法，会出现循环调用\n  if (destroy) {\n    element.destroy();\n  } else {\n    element.set('parent', null);\n    element.set('canvas', null);\n  }\n  removeFromArray(container.getChildren(), element);\n}\nfunction getComparer(compare) {\n  return function (left, right) {\n    var result = compare(left, right);\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\n  };\n}\nvar Container = /** @class */function (_super) {\n  __extends(Container, _super);\n  function Container() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Container.prototype.isCanvas = function () {\n    return false;\n  };\n  // 根据子节点确定 BBox\n  Container.prototype.getBBox = function () {\n    // 所有的值可能在画布的可视区外\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var xArr = [];\n    var yArr = [];\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    var children = this.getChildren().filter(function (child) {\n      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);\n    });\n    if (children.length > 0) {\n      each(children, function (child) {\n        var box = child.getBBox();\n        xArr.push(box.minX, box.maxX);\n        yArr.push(box.minY, box.maxY);\n      });\n      minX = min(xArr);\n      maxX = max(xArr);\n      minY = min(yArr);\n      maxY = max(yArr);\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    var box = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return box;\n  };\n  // 获取画布的包围盒\n  Container.prototype.getCanvasBBox = function () {\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var xArr = [];\n    var yArr = [];\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    var children = this.getChildren().filter(function (child) {\n      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);\n    });\n    if (children.length > 0) {\n      each(children, function (child) {\n        var box = child.getCanvasBBox();\n        xArr.push(box.minX, box.maxX);\n        yArr.push(box.minY, box.maxY);\n      });\n      minX = min(xArr);\n      maxX = max(xArr);\n      minY = min(yArr);\n      maxY = max(yArr);\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    var box = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return box;\n  };\n  Container.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    cfg['children'] = [];\n    return cfg;\n  };\n  Container.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (name === 'matrix') {\n      var totalMatrix = this.getTotalMatrix();\n      this._applyChildrenMarix(totalMatrix);\n    }\n  };\n  // 不但应用到自己身上还要应用于子元素\n  Container.prototype.applyMatrix = function (matrix) {\n    var preTotalMatrix = this.getTotalMatrix();\n    _super.prototype.applyMatrix.call(this, matrix);\n    var totalMatrix = this.getTotalMatrix();\n    // totalMatrix 没有发生变化时，这里仅考虑两者都为 null 时\n    // 不继续向下传递矩阵\n    if (totalMatrix === preTotalMatrix) {\n      return;\n    }\n    this._applyChildrenMarix(totalMatrix);\n  };\n  // 在子元素上设置矩阵\n  Container.prototype._applyChildrenMarix = function (totalMatrix) {\n    var children = this.getChildren();\n    each(children, function (child) {\n      child.applyMatrix(totalMatrix);\n    });\n  };\n  // 兼容老版本的接口\n  Container.prototype.addShape = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var type = args[0];\n    var cfg = args[1];\n    if (isObject(type)) {\n      cfg = type;\n    } else {\n      cfg['type'] = type;\n    }\n    var shapeType = SHAPE_MAP[cfg.type];\n    if (!shapeType) {\n      shapeType = upperFirst(cfg.type);\n      SHAPE_MAP[cfg.type] = shapeType;\n    }\n    var ShapeBase = this.getShapeBase();\n    var shape = new ShapeBase[shapeType](cfg);\n    this.add(shape);\n    return shape;\n  };\n  Container.prototype.addGroup = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var groupClass = args[0],\n      cfg = args[1];\n    var group;\n    if (isFunction(groupClass)) {\n      if (cfg) {\n        group = new groupClass(cfg);\n      } else {\n        group = new groupClass({\n          // canvas,\n          parent: this\n        });\n      }\n    } else {\n      var tmpCfg = groupClass || {};\n      var TmpGroupClass = this.getGroupBase();\n      group = new TmpGroupClass(tmpCfg);\n    }\n    this.add(group);\n    return group;\n  };\n  Container.prototype.getCanvas = function () {\n    var canvas;\n    if (this.isCanvas()) {\n      canvas = this;\n    } else {\n      canvas = this.get('canvas');\n    }\n    return canvas;\n  };\n  Container.prototype.getShape = function (x, y, ev) {\n    // 如果不支持拾取，则直接返回\n    if (!isAllowCapture(this)) {\n      return null;\n    }\n    var children = this.getChildren();\n    var shape;\n    // 如果容器是 group\n    if (!this.isCanvas()) {\n      var v = [x, y, 1];\n      // 将 x, y 转换成对应于 group 的局部坐标\n      v = this.invertFromMatrix(v);\n      if (!this.isClipped(v[0], v[1])) {\n        shape = this._findShape(children, v[0], v[1], ev);\n      }\n    } else {\n      shape = this._findShape(children, x, y, ev);\n    }\n    return shape;\n  };\n  Container.prototype._findShape = function (children, x, y, ev) {\n    var shape = null;\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i];\n      if (isAllowCapture(child)) {\n        if (child.isGroup()) {\n          shape = child.getShape(x, y, ev);\n        } else if (child.isHit(x, y)) {\n          shape = child;\n        }\n      }\n      if (shape) {\n        break;\n      }\n    }\n    return shape;\n  };\n  Container.prototype.add = function (element) {\n    var canvas = this.getCanvas();\n    var children = this.getChildren();\n    var timeline = this.get('timeline');\n    var preParent = element.getParent();\n    if (preParent) {\n      removeChild(preParent, element, false);\n    }\n    element.set('parent', this);\n    if (canvas) {\n      setCanvas(element, canvas);\n    }\n    if (timeline) {\n      setTimeline(element, timeline);\n    }\n    children.push(element);\n    element.onCanvasChange('add');\n    this._applyElementMatrix(element);\n  };\n  // 将当前容器的矩阵应用到子元素\n  Container.prototype._applyElementMatrix = function (element) {\n    var totalMatrix = this.getTotalMatrix();\n    // 添加图形或者分组时，需要把当前图元的矩阵设置进去\n    if (totalMatrix) {\n      element.applyMatrix(totalMatrix);\n    }\n  };\n  Container.prototype.getChildren = function () {\n    return this.get('children');\n  };\n  Container.prototype.sort = function () {\n    var children = this.getChildren();\n    // 稳定排序\n    each(children, function (child, index) {\n      child[INDEX] = index;\n      return child;\n    });\n    children.sort(getComparer(function (obj1, obj2) {\n      return obj1.get('zIndex') - obj2.get('zIndex');\n    }));\n    this.onCanvasChange('sort');\n  };\n  Container.prototype.clear = function () {\n    this.set('clearing', true);\n    if (this.destroyed) {\n      return;\n    }\n    var children = this.getChildren();\n    for (var i = children.length - 1; i >= 0; i--) {\n      children[i].destroy(); // 销毁子元素\n    }\n\n    this.set('children', []);\n    this.onCanvasChange('clear');\n    this.set('clearing', false);\n  };\n  Container.prototype.destroy = function () {\n    if (this.get('destroyed')) {\n      return;\n    }\n    this.clear();\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 获取第一个子元素\n   * @return {IElement} 第一个元素\n   */\n  Container.prototype.getFirst = function () {\n    return this.getChildByIndex(0);\n  };\n  /**\n   * 获取最后一个子元素\n   * @return {IElement} 元素\n   */\n  Container.prototype.getLast = function () {\n    var children = this.getChildren();\n    return this.getChildByIndex(children.length - 1);\n  };\n  /**\n   * 根据索引获取子元素\n   * @return {IElement} 第一个元素\n   */\n  Container.prototype.getChildByIndex = function (index) {\n    var children = this.getChildren();\n    return children[index];\n  };\n  /**\n   * 子元素的数量\n   * @return {number} 子元素数量\n   */\n  Container.prototype.getCount = function () {\n    var children = this.getChildren();\n    return children.length;\n  };\n  /**\n   * 是否包含对应元素\n   * @param {IElement} element 元素\n   * @return {boolean}\n   */\n  Container.prototype.contain = function (element) {\n    var children = this.getChildren();\n    return children.indexOf(element) > -1;\n  };\n  /**\n   * 移除对应子元素\n   * @param {IElement} element 子元素\n   * @param {boolean} destroy 是否销毁子元素，默认为 true\n   */\n  Container.prototype.removeChild = function (element, destroy) {\n    if (destroy === void 0) {\n      destroy = true;\n    }\n    if (this.contain(element)) {\n      element.remove(destroy);\n    }\n  };\n  /**\n   * 查找所有匹配的元素\n   * @param  {ElementFilterFn}   fn  匹配函数\n   * @return {IElement[]} 元素数组\n   */\n  Container.prototype.findAll = function (fn) {\n    var rst = [];\n    var children = this.getChildren();\n    each(children, function (element) {\n      if (fn(element)) {\n        rst.push(element);\n      }\n      if (element.isGroup()) {\n        rst = rst.concat(element.findAll(fn));\n      }\n    });\n    return rst;\n  };\n  /**\n   * 查找元素，找到第一个返回\n   * @param  {ElementFilterFn} fn    匹配函数\n   * @return {IElement|null} 元素，可以为空\n   */\n  Container.prototype.find = function (fn) {\n    var rst = null;\n    var children = this.getChildren();\n    each(children, function (element) {\n      if (fn(element)) {\n        rst = element;\n      } else if (element.isGroup()) {\n        rst = element.find(fn);\n      }\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  };\n  /**\n   * 根据 ID 查找元素\n   * @param {string} id 元素 id\n   * @return {IElement|null} 元素\n   */\n  Container.prototype.findById = function (id) {\n    return this.find(function (element) {\n      return element.get('id') === id;\n    });\n  };\n  /**\n   * 该方法即将废弃，不建议使用\n   * 根据 className 查找元素\n   * TODO: 该方式定义暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除\n   * @param {string} className 元素 className\n   * @return {IElement | null} 元素\n   */\n  Container.prototype.findByClassName = function (className) {\n    return this.find(function (element) {\n      return element.get('className') === className;\n    });\n  };\n  /**\n   * 根据 name 查找元素列表\n   * @param {string}      name 元素名称\n   * @return {IElement[]} 元素\n   */\n  Container.prototype.findAllByName = function (name) {\n    return this.findAll(function (element) {\n      return element.get('name') === name;\n    });\n  };\n  return Container;\n}(Element);\nexport default Container;","map":null,"metadata":{},"sourceType":"module"}