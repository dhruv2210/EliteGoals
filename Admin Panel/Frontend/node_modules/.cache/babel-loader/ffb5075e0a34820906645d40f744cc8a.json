{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */function (_super) {\n  __extends(Symmetric, _super);\n  function Symmetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Symmetric.prototype.process = function (groupDataArray) {\n    var mergeData = _.flatten(groupDataArray);\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 每个 x 值对应的 最大值\n    var cache = this.getXValuesMaxMap(mergeData);\n    // 所有数据的最大的值\n    var max = Math.max.apply(Math, Object.keys(cache).map(function (key) {\n      return cache[key];\n    }));\n    return _.map(groupDataArray, function (dataArray) {\n      return _.map(dataArray, function (data) {\n        var _a, _b;\n        var yValue = data[yField];\n        var xValue = data[xField];\n        // 数组处理逻辑\n        if (_.isArray(yValue)) {\n          var off_1 = (max - cache[xValue]) / 2;\n          return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) {\n            return off_1 + y;\n          }), _a));\n        }\n        // 非数组处理逻辑\n        var offset = (max - yValue) / 2;\n        return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n      });\n    });\n  };\n  // 获取每个 x 对应的最大的值\n  Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n    var _this = this;\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 根据 xField 的值进行分组\n    var groupDataArray = _.groupBy(mergeData, function (data) {\n      return data[xField];\n    });\n    // 获取每个 xField 值中的最大值\n    return _.mapValues(groupDataArray, function (dataArray) {\n      return _this.getDimMaxValue(dataArray, yField);\n    });\n  };\n  Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n    // 所有的 value 值\n    var dimValues = _.map(mergeData, function (data) {\n      return _.get(data, dim, []);\n    });\n    // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n    var flattenValues = _.flatten(dimValues);\n    // 求出数组的最大值\n    return Math.max.apply(Math, flattenValues);\n  };\n  return Symmetric;\n}(Adjust);\nexport default Symmetric;","map":null,"metadata":{},"sourceType":"module"}