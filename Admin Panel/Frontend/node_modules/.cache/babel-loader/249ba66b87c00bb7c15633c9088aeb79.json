{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { get, each } from '@antv/util';\nimport { intersect } from '../../../util/collision-detect';\nimport { getLabelBackgroundInfo } from '../util';\nimport { createWorker } from '../util/createWorker';\nimport { code as layoutCode } from './worker/hide-overlap';\nvar layout = function layout(items) {\n  var boxes = items.slice();\n  for (var i = 0; i < boxes.length; i++) {\n    var box1 = boxes[i];\n    if (box1.visible) {\n      for (var j = i + 1; j < boxes.length; j++) {\n        var box2 = boxes[j];\n        if (box1 !== box2 && box2.visible) {\n          if (intersect(box1, box2)) {\n            box2.visible = false;\n          }\n        }\n      }\n    }\n  }\n  return boxes;\n};\nvar cache = new Map();\nvar worker = createWorker(layoutCode);\n/**\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行隐藏（非移除）\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function hideOverlap(labelItems, labels, shapes, region) {\n  return __awaiter(this, void 0, void 0, function () {\n    var boxes, memoKey, cb, params, res, e_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          boxes = labels.map(function (d, idx) {\n            return __assign(__assign({}, getLabelBackgroundInfo(d, labelItems[idx], get(labelItems[idx], 'background.padding'))), {\n              visible: true\n            });\n          });\n          memoKey = JSON.stringify(boxes);\n          cb = function cb(items) {\n            cache.set(memoKey, items);\n            each(items, function (_a, idx) {\n              var visible = _a.visible;\n              var labelShape = labels[idx];\n              if (visible) {\n                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();\n              } else {\n                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();\n              }\n            });\n            return items;\n          };\n          if (!cache.get(memoKey)) return [3 /*break*/, 1];\n          cb(cache.get(memoKey));\n          return [3 /*break*/, 7];\n        case 1:\n          if (!worker) return [3 /*break*/, 6];\n          _a.label = 2;\n        case 2:\n          _a.trys.push([2, 4,, 5]);\n          params = JSON.stringify({\n            type: 'hide-overlap',\n            items: boxes\n          });\n          return [4 /*yield*/, worker.post(params, function () {\n            return cb(layout(boxes));\n          })];\n        case 3:\n          res = _a.sent();\n          cb(Array.isArray(res.data) ? res.data : []);\n          return [3 /*break*/, 5];\n        case 4:\n          e_1 = _a.sent();\n          console.error(e_1);\n          cb(layout(boxes));\n          return [3 /*break*/, 5];\n        case 5:\n          return [3 /*break*/, 7];\n        case 6:\n          // Normal layout in main thread.\n          cb(layout(boxes));\n          _a.label = 7;\n        case 7:\n          return [2 /*return*/];\n      }\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}