(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.manaSyringe = {}));
}(this, (function (exports) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var NAMED_TAG = "named";
  var NAME_TAG = "name";
  var UNMANAGED_TAG = "unmanaged";
  var OPTIONAL_TAG = "optional";
  var INJECT_TAG = "inject";
  var MULTI_INJECT_TAG = "multi_inject";
  var TAGGED = "inversify:tagged";
  var TAGGED_PROP = "inversify:tagged_props";
  var PARAM_TYPES = "inversify:paramtypes";
  var DESIGN_PARAM_TYPES = "design:paramtypes";
  var POST_CONSTRUCT = "post_construct";
  function getNonCustomTagKeys() {
      return [
          INJECT_TAG,
          MULTI_INJECT_TAG,
          NAME_TAG,
          UNMANAGED_TAG,
          NAMED_TAG,
          OPTIONAL_TAG,
      ];
  }
  var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();

  var BindingScopeEnum = {
      Request: "Request",
      Singleton: "Singleton",
      Transient: "Transient"
  };
  var BindingTypeEnum = {
      ConstantValue: "ConstantValue",
      Constructor: "Constructor",
      DynamicValue: "DynamicValue",
      Factory: "Factory",
      Function: "Function",
      Instance: "Instance",
      Invalid: "Invalid",
      Provider: "Provider"
  };
  var TargetTypeEnum = {
      ClassProperty: "ClassProperty",
      ConstructorArgument: "ConstructorArgument",
      Variable: "Variable"
  };

  var idCounter = 0;
  function id() {
      return idCounter++;
  }

  var Binding = (function () {
      function Binding(serviceIdentifier, scope) {
          this.id = id();
          this.activated = false;
          this.serviceIdentifier = serviceIdentifier;
          this.scope = scope;
          this.type = BindingTypeEnum.Invalid;
          this.constraint = function (request) { return true; };
          this.implementationType = null;
          this.cache = null;
          this.factory = null;
          this.provider = null;
          this.onActivation = null;
          this.dynamicValue = null;
      }
      Binding.prototype.clone = function () {
          var clone = new Binding(this.serviceIdentifier, this.scope);
          clone.activated = (clone.scope === BindingScopeEnum.Singleton) ? this.activated : false;
          clone.implementationType = this.implementationType;
          clone.dynamicValue = this.dynamicValue;
          clone.scope = this.scope;
          clone.type = this.type;
          clone.factory = this.factory;
          clone.provider = this.provider;
          clone.constraint = this.constraint;
          clone.onActivation = this.onActivation;
          clone.cache = this.cache;
          return clone;
      };
      return Binding;
  }());

  var DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
  var DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
  var NULL_ARGUMENT = "NULL argument";
  var KEY_NOT_FOUND = "Key Not Found";
  var AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
  var CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
  var NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
  var MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
  var MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
  var UNDEFINED_INJECT_ANNOTATION = function (name) {
      return "@inject called with undefined this could mean that the class " + name + " has " +
          "a circular dependency problem. You can use a LazyServiceIdentifer to  " +
          "overcome this limitation.";
  };
  var CIRCULAR_DEPENDENCY = "Circular dependency found:";
  var INVALID_BINDING_TYPE = "Invalid binding type:";
  var NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
  var INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
  var INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
  var INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is " +
      "used as service identifier";
  var INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators " +
      "must be applied to the parameters of a class constructor or a class property.";
  var ARGUMENTS_LENGTH_MISMATCH = function () {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
      }
      return "The number of constructor arguments in the derived class " +
          (values[0] + " must be >= than the number of constructor arguments of its base class.");
  };
  var CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options " +
      "must be an object.";
  var CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must " +
      "be a string ('singleton' or 'transient').";
  var CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must " +
      "be a boolean";
  var CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must " +
      "be a boolean";
  var MULTIPLE_POST_CONSTRUCT_METHODS = "Cannot apply @postConstruct decorator multiple times in the same class";
  var POST_CONSTRUCT_ERROR = function () {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
      }
      return "@postConstruct error in class " + values[0] + ": " + values[1];
  };
  var CIRCULAR_DEPENDENCY_IN_FACTORY = function () {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
      }
      return "It looks like there is a circular dependency " +
          ("in one of the '" + values[0] + "' bindings. Please investigate bindings with") +
          ("service identifier '" + values[1] + "'.");
  };
  var STACK_OVERFLOW = "Maximum call stack size exceeded";

  var MetadataReader = (function () {
      function MetadataReader() {
      }
      MetadataReader.prototype.getConstructorMetadata = function (constructorFunc) {
          var compilerGeneratedMetadata = Reflect.getMetadata(PARAM_TYPES, constructorFunc);
          var userGeneratedMetadata = Reflect.getMetadata(TAGGED, constructorFunc);
          return {
              compilerGeneratedMetadata: compilerGeneratedMetadata,
              userGeneratedMetadata: userGeneratedMetadata || {}
          };
      };
      MetadataReader.prototype.getPropertiesMetadata = function (constructorFunc) {
          var userGeneratedMetadata = Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
          return userGeneratedMetadata;
      };
      return MetadataReader;
  }());

  var BindingCount = {
      MultipleBindingsAvailable: 2,
      NoBindingsAvailable: 0,
      OnlyOneBindingAvailable: 1
  };

  function isStackOverflowExeption(error) {
      return (error instanceof RangeError ||
          error.message === STACK_OVERFLOW);
  }

  function getServiceIdentifierAsString(serviceIdentifier) {
      if (typeof serviceIdentifier === "function") {
          var _serviceIdentifier = serviceIdentifier;
          return _serviceIdentifier.name;
      }
      else if (typeof serviceIdentifier === "symbol") {
          return serviceIdentifier.toString();
      }
      else {
          var _serviceIdentifier = serviceIdentifier;
          return _serviceIdentifier;
      }
  }
  function listRegisteredBindingsForServiceIdentifier(container, serviceIdentifier, getBindings) {
      var registeredBindingsList = "";
      var registeredBindings = getBindings(container, serviceIdentifier);
      if (registeredBindings.length !== 0) {
          registeredBindingsList = "\nRegistered bindings:";
          registeredBindings.forEach(function (binding) {
              var name = "Object";
              if (binding.implementationType !== null) {
                  name = getFunctionName(binding.implementationType);
              }
              registeredBindingsList = registeredBindingsList + "\n " + name;
              if (binding.constraint.metaData) {
                  registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
              }
          });
      }
      return registeredBindingsList;
  }
  function alreadyDependencyChain(request, serviceIdentifier) {
      if (request.parentRequest === null) {
          return false;
      }
      else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
          return true;
      }
      else {
          return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
      }
  }
  function dependencyChainToString(request) {
      function _createStringArr(req, result) {
          if (result === void 0) { result = []; }
          var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
          result.push(serviceIdentifier);
          if (req.parentRequest !== null) {
              return _createStringArr(req.parentRequest, result);
          }
          return result;
      }
      var stringArr = _createStringArr(request);
      return stringArr.reverse().join(" --> ");
  }
  function circularDependencyToException(request) {
      request.childRequests.forEach(function (childRequest) {
          if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
              var services = dependencyChainToString(childRequest);
              throw new Error(CIRCULAR_DEPENDENCY + " " + services);
          }
          else {
              circularDependencyToException(childRequest);
          }
      });
  }
  function listMetadataForTarget(serviceIdentifierString, target) {
      if (target.isTagged() || target.isNamed()) {
          var m_1 = "";
          var namedTag = target.getNamedTag();
          var otherTags = target.getCustomTags();
          if (namedTag !== null) {
              m_1 += namedTag.toString() + "\n";
          }
          if (otherTags !== null) {
              otherTags.forEach(function (tag) {
                  m_1 += tag.toString() + "\n";
              });
          }
          return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
      }
      else {
          return " " + serviceIdentifierString;
      }
  }
  function getFunctionName(v) {
      if (v.name) {
          return v.name;
      }
      else {
          var name_1 = v.toString();
          var match = name_1.match(/^function\s*([^\s(]+)/);
          return match ? match[1] : "Anonymous function: " + name_1;
      }
  }

  var Context = (function () {
      function Context(container) {
          this.id = id();
          this.container = container;
      }
      Context.prototype.addPlan = function (plan) {
          this.plan = plan;
      };
      Context.prototype.setCurrentRequest = function (currentRequest) {
          this.currentRequest = currentRequest;
      };
      return Context;
  }());

  var Metadata = (function () {
      function Metadata(key, value) {
          this.key = key;
          this.value = value;
      }
      Metadata.prototype.toString = function () {
          if (this.key === NAMED_TAG) {
              return "named: " + this.value.toString() + " ";
          }
          else {
              return "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }";
          }
      };
      return Metadata;
  }());

  var Plan = (function () {
      function Plan(parentContext, rootRequest) {
          this.parentContext = parentContext;
          this.rootRequest = rootRequest;
      }
      return Plan;
  }());

  function tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {
      var metadataKey = TAGGED;
      _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);
  }
  function tagProperty(annotationTarget, propertyName, metadata) {
      var metadataKey = TAGGED_PROP;
      _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);
  }
  function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
      var paramsOrPropertiesMetadata = {};
      var isParameterDecorator = (typeof parameterIndex === "number");
      var key = (parameterIndex !== undefined && isParameterDecorator) ? parameterIndex.toString() : propertyName;
      if (isParameterDecorator && propertyName !== undefined) {
          throw new Error(INVALID_DECORATOR_OPERATION);
      }
      if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
          paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
      }
      var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
      if (!Array.isArray(paramOrPropertyMetadata)) {
          paramOrPropertyMetadata = [];
      }
      else {
          for (var _i = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i < paramOrPropertyMetadata_1.length; _i++) {
              var m = paramOrPropertyMetadata_1[_i];
              if (m.key === metadata.key) {
                  throw new Error(DUPLICATED_METADATA + " " + m.key.toString());
              }
          }
      }
      paramOrPropertyMetadata.push(metadata);
      paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
      Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
  }
  function _decorate(decorators, target) {
      Reflect.decorate(decorators, target);
  }
  function _param(paramIndex, decorator) {
      return function (target, key) { decorator(target, key, paramIndex); };
  }
  function decorate(decorator, target, parameterIndex) {
      if (typeof parameterIndex === "number") {
          _decorate([_param(parameterIndex, decorator)], target);
      }
      else if (typeof parameterIndex === "string") {
          Reflect.decorate([decorator], target, parameterIndex);
      }
      else {
          _decorate([decorator], target);
      }
  }

  var LazyServiceIdentifer = (function () {
      function LazyServiceIdentifer(cb) {
          this._cb = cb;
      }
      LazyServiceIdentifer.prototype.unwrap = function () {
          return this._cb();
      };
      return LazyServiceIdentifer;
  }());
  function inject(serviceIdentifier) {
      return function (target, targetKey, index) {
          if (serviceIdentifier === undefined) {
              throw new Error(UNDEFINED_INJECT_ANNOTATION(target.name));
          }
          var metadata = new Metadata(INJECT_TAG, serviceIdentifier);
          if (typeof index === "number") {
              tagParameter(target, targetKey, index, metadata);
          }
          else {
              tagProperty(target, targetKey, metadata);
          }
      };
  }

  var QueryableString = (function () {
      function QueryableString(str) {
          this.str = str;
      }
      QueryableString.prototype.startsWith = function (searchString) {
          return this.str.indexOf(searchString) === 0;
      };
      QueryableString.prototype.endsWith = function (searchString) {
          var reverseString = "";
          var reverseSearchString = searchString.split("").reverse().join("");
          reverseString = this.str.split("").reverse().join("");
          return this.startsWith.call({ str: reverseString }, reverseSearchString);
      };
      QueryableString.prototype.contains = function (searchString) {
          return (this.str.indexOf(searchString) !== -1);
      };
      QueryableString.prototype.equals = function (compareString) {
          return this.str === compareString;
      };
      QueryableString.prototype.value = function () {
          return this.str;
      };
      return QueryableString;
  }());

  var Target = (function () {
      function Target(type, name, serviceIdentifier, namedOrTagged) {
          this.id = id();
          this.type = type;
          this.serviceIdentifier = serviceIdentifier;
          this.name = new QueryableString(name || "");
          this.metadata = new Array();
          var metadataItem = null;
          if (typeof namedOrTagged === "string") {
              metadataItem = new Metadata(NAMED_TAG, namedOrTagged);
          }
          else if (namedOrTagged instanceof Metadata) {
              metadataItem = namedOrTagged;
          }
          if (metadataItem !== null) {
              this.metadata.push(metadataItem);
          }
      }
      Target.prototype.hasTag = function (key) {
          for (var _i = 0, _a = this.metadata; _i < _a.length; _i++) {
              var m = _a[_i];
              if (m.key === key) {
                  return true;
              }
          }
          return false;
      };
      Target.prototype.isArray = function () {
          return this.hasTag(MULTI_INJECT_TAG);
      };
      Target.prototype.matchesArray = function (name) {
          return this.matchesTag(MULTI_INJECT_TAG)(name);
      };
      Target.prototype.isNamed = function () {
          return this.hasTag(NAMED_TAG);
      };
      Target.prototype.isTagged = function () {
          return this.metadata.some(function (metadata) { return NON_CUSTOM_TAG_KEYS.every(function (key) { return metadata.key !== key; }); });
      };
      Target.prototype.isOptional = function () {
          return this.matchesTag(OPTIONAL_TAG)(true);
      };
      Target.prototype.getNamedTag = function () {
          if (this.isNamed()) {
              return this.metadata.filter(function (m) { return m.key === NAMED_TAG; })[0];
          }
          return null;
      };
      Target.prototype.getCustomTags = function () {
          if (this.isTagged()) {
              return this.metadata.filter(function (metadata) { return NON_CUSTOM_TAG_KEYS.every(function (key) { return metadata.key !== key; }); });
          }
          else {
              return null;
          }
      };
      Target.prototype.matchesNamedTag = function (name) {
          return this.matchesTag(NAMED_TAG)(name);
      };
      Target.prototype.matchesTag = function (key) {
          var _this = this;
          return function (value) {
              for (var _i = 0, _a = _this.metadata; _i < _a.length; _i++) {
                  var m = _a[_i];
                  if (m.key === key && m.value === value) {
                      return true;
                  }
              }
              return false;
          };
      };
      return Target;
  }());

  var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
      return to;
  };
  function getDependencies(metadataReader, func) {
      var constructorName = getFunctionName(func);
      var targets = getTargets(metadataReader, constructorName, func, false);
      return targets;
  }
  function getTargets(metadataReader, constructorName, func, isBaseClass) {
      var metadata = metadataReader.getConstructorMetadata(func);
      var serviceIdentifiers = metadata.compilerGeneratedMetadata;
      if (serviceIdentifiers === undefined) {
          var msg = MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
          throw new Error(msg);
      }
      var constructorArgsMetadata = metadata.userGeneratedMetadata;
      var keys = Object.keys(constructorArgsMetadata);
      var hasUserDeclaredUnknownInjections = (func.length === 0 && keys.length > 0);
      var hasOptionalParameters = keys.length > func.length;
      var iterations = (hasUserDeclaredUnknownInjections || hasOptionalParameters) ? keys.length : func.length;
      var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
      var propertyTargets = getClassPropsAsTargets(metadataReader, func);
      var targets = __spreadArray(__spreadArray([], constructorTargets), propertyTargets);
      return targets;
  }
  function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
      var targetMetadata = constructorArgsMetadata[index.toString()] || [];
      var metadata = formatTargetMetadata(targetMetadata);
      var isManaged = metadata.unmanaged !== true;
      var serviceIdentifier = serviceIdentifiers[index];
      var injectIdentifier = (metadata.inject || metadata.multiInject);
      serviceIdentifier = (injectIdentifier) ? (injectIdentifier) : serviceIdentifier;
      if (serviceIdentifier instanceof LazyServiceIdentifer) {
          serviceIdentifier = serviceIdentifier.unwrap();
      }
      if (isManaged) {
          var isObject = serviceIdentifier === Object;
          var isFunction = serviceIdentifier === Function;
          var isUndefined = serviceIdentifier === undefined;
          var isUnknownType = (isObject || isFunction || isUndefined);
          if (!isBaseClass && isUnknownType) {
              var msg = MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
              throw new Error(msg);
          }
          var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
          target.metadata = targetMetadata;
          return target;
      }
      return null;
  }
  function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
      var targets = [];
      for (var i = 0; i < iterations; i++) {
          var index = i;
          var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
          if (target !== null) {
              targets.push(target);
          }
      }
      return targets;
  }
  function getClassPropsAsTargets(metadataReader, constructorFunc) {
      var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
      var targets = [];
      var keys = Object.keys(classPropsMetadata);
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var key = keys_1[_i];
          var targetMetadata = classPropsMetadata[key];
          var metadata = formatTargetMetadata(classPropsMetadata[key]);
          var targetName = metadata.targetName || key;
          var serviceIdentifier = (metadata.inject || metadata.multiInject);
          var target = new Target(TargetTypeEnum.ClassProperty, targetName, serviceIdentifier);
          target.metadata = targetMetadata;
          targets.push(target);
      }
      var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
      if (baseConstructor !== Object) {
          var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);
          targets = __spreadArray(__spreadArray([], targets), baseTargets);
      }
      return targets;
  }
  function getBaseClassDependencyCount(metadataReader, func) {
      var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
      if (baseConstructor !== Object) {
          var baseConstructorName = getFunctionName(baseConstructor);
          var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
          var metadata = targets.map(function (t) {
              return t.metadata.filter(function (m) {
                  return m.key === UNMANAGED_TAG;
              });
          });
          var unmanagedCount = [].concat.apply([], metadata).length;
          var dependencyCount = targets.length - unmanagedCount;
          if (dependencyCount > 0) {
              return dependencyCount;
          }
          else {
              return getBaseClassDependencyCount(metadataReader, baseConstructor);
          }
      }
      else {
          return 0;
      }
  }
  function formatTargetMetadata(targetMetadata) {
      var targetMetadataMap = {};
      targetMetadata.forEach(function (m) {
          targetMetadataMap[m.key.toString()] = m.value;
      });
      return {
          inject: targetMetadataMap[INJECT_TAG],
          multiInject: targetMetadataMap[MULTI_INJECT_TAG],
          targetName: targetMetadataMap[NAME_TAG],
          unmanaged: targetMetadataMap[UNMANAGED_TAG]
      };
  }

  var Request = (function () {
      function Request(serviceIdentifier, parentContext, parentRequest, bindings, target) {
          this.id = id();
          this.serviceIdentifier = serviceIdentifier;
          this.parentContext = parentContext;
          this.parentRequest = parentRequest;
          this.target = target;
          this.childRequests = [];
          this.bindings = (Array.isArray(bindings) ? bindings : [bindings]);
          this.requestScope = parentRequest === null
              ? new Map()
              : null;
      }
      Request.prototype.addChildRequest = function (serviceIdentifier, bindings, target) {
          var child = new Request(serviceIdentifier, this.parentContext, this, bindings, target);
          this.childRequests.push(child);
          return child;
      };
      return Request;
  }());

  function getBindingDictionary(cntnr) {
      return cntnr._bindingDictionary;
  }
  function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
      var metadataKey = isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG;
      var injectMetadata = new Metadata(metadataKey, serviceIdentifier);
      var target = new Target(targetType, name, serviceIdentifier, injectMetadata);
      if (key !== undefined) {
          var tagMetadata = new Metadata(key, value);
          target.metadata.push(tagMetadata);
      }
      return target;
  }
  function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
      var bindings = getBindings(context.container, target.serviceIdentifier);
      var activeBindings = [];
      if (bindings.length === BindingCount.NoBindingsAvailable &&
          context.container.options.autoBindInjectable &&
          typeof target.serviceIdentifier === "function" &&
          metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
          context.container.bind(target.serviceIdentifier).toSelf();
          bindings = getBindings(context.container, target.serviceIdentifier);
      }
      if (!avoidConstraints) {
          activeBindings = bindings.filter(function (binding) {
              var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
              return binding.constraint(request);
          });
      }
      else {
          activeBindings = bindings;
      }
      _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
      return activeBindings;
  }
  function _validateActiveBindingCount(serviceIdentifier, bindings, target, container) {
      switch (bindings.length) {
          case BindingCount.NoBindingsAvailable:
              if (target.isOptional()) {
                  return bindings;
              }
              else {
                  var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
                  var msg = NOT_REGISTERED;
                  msg += listMetadataForTarget(serviceIdentifierString, target);
                  msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
                  throw new Error(msg);
              }
          case BindingCount.OnlyOneBindingAvailable:
              if (!target.isArray()) {
                  return bindings;
              }
          case BindingCount.MultipleBindingsAvailable:
          default:
              if (!target.isArray()) {
                  var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
                  var msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString;
                  msg += listRegisteredBindingsForServiceIdentifier(container, serviceIdentifierString, getBindings);
                  throw new Error(msg);
              }
              else {
                  return bindings;
              }
      }
  }
  function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
      var activeBindings;
      var childRequest;
      if (parentRequest === null) {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
          childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
          var thePlan = new Plan(context, childRequest);
          context.addPlan(thePlan);
      }
      else {
          activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
          childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
      }
      activeBindings.forEach(function (binding) {
          var subChildRequest = null;
          if (target.isArray()) {
              subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
          }
          else {
              if (binding.cache) {
                  return;
              }
              subChildRequest = childRequest;
          }
          if (binding.type === BindingTypeEnum.Instance && binding.implementationType !== null) {
              var dependencies = getDependencies(metadataReader, binding.implementationType);
              if (!context.container.options.skipBaseClassChecks) {
                  var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
                  if (dependencies.length < baseClassDependencyCount) {
                      var error = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType));
                      throw new Error(error);
                  }
              }
              dependencies.forEach(function (dependency) {
                  _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
              });
          }
      });
  }
  function getBindings(container, serviceIdentifier) {
      var bindings = [];
      var bindingDictionary = getBindingDictionary(container);
      if (bindingDictionary.hasKey(serviceIdentifier)) {
          bindings = bindingDictionary.get(serviceIdentifier);
      }
      else if (container.parent !== null) {
          bindings = getBindings(container.parent, serviceIdentifier);
      }
      return bindings;
  }
  function plan(metadataReader, container, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
      if (avoidConstraints === void 0) { avoidConstraints = false; }
      var context = new Context(container);
      var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
      try {
          _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
          return context;
      }
      catch (error) {
          if (isStackOverflowExeption(error)) {
              if (context.plan) {
                  circularDependencyToException(context.plan.rootRequest);
              }
          }
          throw error;
      }
  }
  function createMockRequest(container, serviceIdentifier, key, value) {
      var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value));
      var context = new Context(container);
      var request = new Request(serviceIdentifier, context, null, [], target);
      return request;
  }

  var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
      return to;
  };
  function _injectProperties(instance, childRequests, resolveRequest) {
      var propertyInjectionsRequests = childRequests.filter(function (childRequest) {
          return (childRequest.target !== null &&
              childRequest.target.type === TargetTypeEnum.ClassProperty);
      });
      var propertyInjections = propertyInjectionsRequests.map(resolveRequest);
      propertyInjectionsRequests.forEach(function (r, index) {
          var propertyName = "";
          propertyName = r.target.name.value();
          var injection = propertyInjections[index];
          instance[propertyName] = injection;
      });
      return instance;
  }
  function _createInstance(Func, injections) {
      return new (Func.bind.apply(Func, __spreadArray$1([void 0], injections)))();
  }
  function _postConstruct(constr, result) {
      if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
          var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
          try {
              result[data.value]();
          }
          catch (e) {
              throw new Error(POST_CONSTRUCT_ERROR(constr.name, e.message));
          }
      }
  }
  function resolveInstance(constr, childRequests, resolveRequest) {
      var result = null;
      if (childRequests.length > 0) {
          var constructorInjectionsRequests = childRequests.filter(function (childRequest) {
              return (childRequest.target !== null && childRequest.target.type === TargetTypeEnum.ConstructorArgument);
          });
          var constructorInjections = constructorInjectionsRequests.map(resolveRequest);
          result = _createInstance(constr, constructorInjections);
          result = _injectProperties(result, childRequests, resolveRequest);
      }
      else {
          result = new constr();
      }
      _postConstruct(constr, result);
      return result;
  }

  var invokeFactory = function (factoryType, serviceIdentifier, fn) {
      try {
          return fn();
      }
      catch (error) {
          if (isStackOverflowExeption(error)) {
              throw new Error(CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier.toString()));
          }
          else {
              throw error;
          }
      }
  };
  var _resolveRequest = function (requestScope) {
      return function (request) {
          request.parentContext.setCurrentRequest(request);
          var bindings = request.bindings;
          var childRequests = request.childRequests;
          var targetIsAnArray = request.target && request.target.isArray();
          var targetParentIsNotAnArray = !request.parentRequest ||
              !request.parentRequest.target ||
              !request.target ||
              !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
          if (targetIsAnArray && targetParentIsNotAnArray) {
              return childRequests.map(function (childRequest) {
                  var _f = _resolveRequest(requestScope);
                  return _f(childRequest);
              });
          }
          else {
              var result = null;
              if (request.target.isOptional() && bindings.length === 0) {
                  return undefined;
              }
              var binding_1 = bindings[0];
              var isSingleton = binding_1.scope === BindingScopeEnum.Singleton;
              var isRequestSingleton = binding_1.scope === BindingScopeEnum.Request;
              if (isSingleton && binding_1.activated) {
                  return binding_1.cache;
              }
              if (isRequestSingleton &&
                  requestScope !== null &&
                  requestScope.has(binding_1.id)) {
                  return requestScope.get(binding_1.id);
              }
              if (binding_1.type === BindingTypeEnum.ConstantValue) {
                  result = binding_1.cache;
                  binding_1.activated = true;
              }
              else if (binding_1.type === BindingTypeEnum.Function) {
                  result = binding_1.cache;
                  binding_1.activated = true;
              }
              else if (binding_1.type === BindingTypeEnum.Constructor) {
                  result = binding_1.implementationType;
              }
              else if (binding_1.type === BindingTypeEnum.DynamicValue && binding_1.dynamicValue !== null) {
                  result = invokeFactory("toDynamicValue", binding_1.serviceIdentifier, function () { return binding_1.dynamicValue(request.parentContext); });
              }
              else if (binding_1.type === BindingTypeEnum.Factory && binding_1.factory !== null) {
                  result = invokeFactory("toFactory", binding_1.serviceIdentifier, function () { return binding_1.factory(request.parentContext); });
              }
              else if (binding_1.type === BindingTypeEnum.Provider && binding_1.provider !== null) {
                  result = invokeFactory("toProvider", binding_1.serviceIdentifier, function () { return binding_1.provider(request.parentContext); });
              }
              else if (binding_1.type === BindingTypeEnum.Instance && binding_1.implementationType !== null) {
                  result = resolveInstance(binding_1.implementationType, childRequests, _resolveRequest(requestScope));
              }
              else {
                  var serviceIdentifier = getServiceIdentifierAsString(request.serviceIdentifier);
                  throw new Error(INVALID_BINDING_TYPE + " " + serviceIdentifier);
              }
              if (typeof binding_1.onActivation === "function") {
                  result = binding_1.onActivation(request.parentContext, result);
              }
              if (isSingleton) {
                  binding_1.cache = result;
                  binding_1.activated = true;
              }
              if (isRequestSingleton &&
                  requestScope !== null &&
                  !requestScope.has(binding_1.id)) {
                  requestScope.set(binding_1.id, result);
              }
              return result;
          }
      };
  };
  function resolve(context) {
      var _f = _resolveRequest(context.plan.rootRequest.requestScope);
      return _f(context.plan.rootRequest);
  }

  var traverseAncerstors = function (request, constraint) {
      var parent = request.parentRequest;
      if (parent !== null) {
          return constraint(parent) ? true : traverseAncerstors(parent, constraint);
      }
      else {
          return false;
      }
  };
  var taggedConstraint = function (key) { return function (value) {
      var constraint = function (request) {
          return request !== null && request.target !== null && request.target.matchesTag(key)(value);
      };
      constraint.metaData = new Metadata(key, value);
      return constraint;
  }; };
  var namedConstraint = taggedConstraint(NAMED_TAG);
  var typeConstraint = function (type) { return function (request) {
      var binding = null;
      if (request !== null) {
          binding = request.bindings[0];
          if (typeof type === "string") {
              var serviceIdentifier = binding.serviceIdentifier;
              return serviceIdentifier === type;
          }
          else {
              var constructor = request.bindings[0].implementationType;
              return type === constructor;
          }
      }
      return false;
  }; };

  var BindingWhenSyntax = (function () {
      function BindingWhenSyntax(binding) {
          this._binding = binding;
      }
      BindingWhenSyntax.prototype.when = function (constraint) {
          this._binding.constraint = constraint;
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenTargetNamed = function (name) {
          this._binding.constraint = namedConstraint(name);
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenTargetIsDefault = function () {
          this._binding.constraint = function (request) {
              var targetIsDefault = (request.target !== null) &&
                  (!request.target.isNamed()) &&
                  (!request.target.isTagged());
              return targetIsDefault;
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenTargetTagged = function (tag, value) {
          this._binding.constraint = taggedConstraint(tag)(value);
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenInjectedInto = function (parent) {
          this._binding.constraint = function (request) {
              return typeConstraint(parent)(request.parentRequest);
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenParentNamed = function (name) {
          this._binding.constraint = function (request) {
              return namedConstraint(name)(request.parentRequest);
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenParentTagged = function (tag, value) {
          this._binding.constraint = function (request) {
              return taggedConstraint(tag)(value)(request.parentRequest);
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
          this._binding.constraint = function (request) {
              return traverseAncerstors(request, typeConstraint(ancestor));
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenNoAncestorIs = function (ancestor) {
          this._binding.constraint = function (request) {
              return !traverseAncerstors(request, typeConstraint(ancestor));
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenAnyAncestorNamed = function (name) {
          this._binding.constraint = function (request) {
              return traverseAncerstors(request, namedConstraint(name));
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenNoAncestorNamed = function (name) {
          this._binding.constraint = function (request) {
              return !traverseAncerstors(request, namedConstraint(name));
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
          this._binding.constraint = function (request) {
              return traverseAncerstors(request, taggedConstraint(tag)(value));
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
          this._binding.constraint = function (request) {
              return !traverseAncerstors(request, taggedConstraint(tag)(value));
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
          this._binding.constraint = function (request) {
              return traverseAncerstors(request, constraint);
          };
          return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax.prototype.whenNoAncestorMatches = function (constraint) {
          this._binding.constraint = function (request) {
              return !traverseAncerstors(request, constraint);
          };
          return new BindingOnSyntax(this._binding);
      };
      return BindingWhenSyntax;
  }());

  var BindingOnSyntax = (function () {
      function BindingOnSyntax(binding) {
          this._binding = binding;
      }
      BindingOnSyntax.prototype.onActivation = function (handler) {
          this._binding.onActivation = handler;
          return new BindingWhenSyntax(this._binding);
      };
      return BindingOnSyntax;
  }());

  var BindingWhenOnSyntax = (function () {
      function BindingWhenOnSyntax(binding) {
          this._binding = binding;
          this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new BindingOnSyntax(this._binding);
      }
      BindingWhenOnSyntax.prototype.when = function (constraint) {
          return this._bindingWhenSyntax.when(constraint);
      };
      BindingWhenOnSyntax.prototype.whenTargetNamed = function (name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingWhenOnSyntax.prototype.whenTargetIsDefault = function () {
          return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingWhenOnSyntax.prototype.whenParentNamed = function (name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingWhenOnSyntax.prototype.onActivation = function (handler) {
          return this._bindingOnSyntax.onActivation(handler);
      };
      return BindingWhenOnSyntax;
  }());

  var BindingInSyntax = (function () {
      function BindingInSyntax(binding) {
          this._binding = binding;
      }
      BindingInSyntax.prototype.inRequestScope = function () {
          this._binding.scope = BindingScopeEnum.Request;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax.prototype.inSingletonScope = function () {
          this._binding.scope = BindingScopeEnum.Singleton;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax.prototype.inTransientScope = function () {
          this._binding.scope = BindingScopeEnum.Transient;
          return new BindingWhenOnSyntax(this._binding);
      };
      return BindingInSyntax;
  }());

  var BindingInWhenOnSyntax = (function () {
      function BindingInWhenOnSyntax(binding) {
          this._binding = binding;
          this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
          this._bindingOnSyntax = new BindingOnSyntax(this._binding);
          this._bindingInSyntax = new BindingInSyntax(binding);
      }
      BindingInWhenOnSyntax.prototype.inRequestScope = function () {
          return this._bindingInSyntax.inRequestScope();
      };
      BindingInWhenOnSyntax.prototype.inSingletonScope = function () {
          return this._bindingInSyntax.inSingletonScope();
      };
      BindingInWhenOnSyntax.prototype.inTransientScope = function () {
          return this._bindingInSyntax.inTransientScope();
      };
      BindingInWhenOnSyntax.prototype.when = function (constraint) {
          return this._bindingWhenSyntax.when(constraint);
      };
      BindingInWhenOnSyntax.prototype.whenTargetNamed = function (name) {
          return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingInWhenOnSyntax.prototype.whenTargetIsDefault = function () {
          return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingInWhenOnSyntax.prototype.whenTargetTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingInWhenOnSyntax.prototype.whenInjectedInto = function (parent) {
          return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingInWhenOnSyntax.prototype.whenParentNamed = function (name) {
          return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingInWhenOnSyntax.prototype.whenParentTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingInWhenOnSyntax.prototype.whenAnyAncestorIs = function (ancestor) {
          return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax.prototype.whenNoAncestorIs = function (ancestor) {
          return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax.prototype.whenAnyAncestorNamed = function (name) {
          return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingInWhenOnSyntax.prototype.whenAnyAncestorTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax.prototype.whenNoAncestorNamed = function (name) {
          return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingInWhenOnSyntax.prototype.whenNoAncestorTagged = function (tag, value) {
          return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax.prototype.whenAnyAncestorMatches = function (constraint) {
          return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax.prototype.whenNoAncestorMatches = function (constraint) {
          return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax.prototype.onActivation = function (handler) {
          return this._bindingOnSyntax.onActivation(handler);
      };
      return BindingInWhenOnSyntax;
  }());

  var BindingToSyntax = (function () {
      function BindingToSyntax(binding) {
          this._binding = binding;
      }
      BindingToSyntax.prototype.to = function (constructor) {
          this._binding.type = BindingTypeEnum.Instance;
          this._binding.implementationType = constructor;
          return new BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toSelf = function () {
          if (typeof this._binding.serviceIdentifier !== "function") {
              throw new Error("" + INVALID_TO_SELF_VALUE);
          }
          var self = this._binding.serviceIdentifier;
          return this.to(self);
      };
      BindingToSyntax.prototype.toConstantValue = function (value) {
          this._binding.type = BindingTypeEnum.ConstantValue;
          this._binding.cache = value;
          this._binding.dynamicValue = null;
          this._binding.implementationType = null;
          this._binding.scope = BindingScopeEnum.Singleton;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toDynamicValue = function (func) {
          this._binding.type = BindingTypeEnum.DynamicValue;
          this._binding.cache = null;
          this._binding.dynamicValue = func;
          this._binding.implementationType = null;
          return new BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toConstructor = function (constructor) {
          this._binding.type = BindingTypeEnum.Constructor;
          this._binding.implementationType = constructor;
          this._binding.scope = BindingScopeEnum.Singleton;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toFactory = function (factory) {
          this._binding.type = BindingTypeEnum.Factory;
          this._binding.factory = factory;
          this._binding.scope = BindingScopeEnum.Singleton;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toFunction = function (func) {
          if (typeof func !== "function") {
              throw new Error(INVALID_FUNCTION_BINDING);
          }
          var bindingWhenOnSyntax = this.toConstantValue(func);
          this._binding.type = BindingTypeEnum.Function;
          this._binding.scope = BindingScopeEnum.Singleton;
          return bindingWhenOnSyntax;
      };
      BindingToSyntax.prototype.toAutoFactory = function (serviceIdentifier) {
          this._binding.type = BindingTypeEnum.Factory;
          this._binding.factory = function (context) {
              var autofactory = function () { return context.container.get(serviceIdentifier); };
              return autofactory;
          };
          this._binding.scope = BindingScopeEnum.Singleton;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toProvider = function (provider) {
          this._binding.type = BindingTypeEnum.Provider;
          this._binding.provider = provider;
          this._binding.scope = BindingScopeEnum.Singleton;
          return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax.prototype.toService = function (service) {
          this.toDynamicValue(function (context) { return context.container.get(service); });
      };
      return BindingToSyntax;
  }());

  var ContainerSnapshot = (function () {
      function ContainerSnapshot() {
      }
      ContainerSnapshot.of = function (bindings, middleware) {
          var snapshot = new ContainerSnapshot();
          snapshot.bindings = bindings;
          snapshot.middleware = middleware;
          return snapshot;
      };
      return ContainerSnapshot;
  }());

  var Lookup = (function () {
      function Lookup() {
          this._map = new Map();
      }
      Lookup.prototype.getMap = function () {
          return this._map;
      };
      Lookup.prototype.add = function (serviceIdentifier, value) {
          if (serviceIdentifier === null || serviceIdentifier === undefined) {
              throw new Error(NULL_ARGUMENT);
          }
          if (value === null || value === undefined) {
              throw new Error(NULL_ARGUMENT);
          }
          var entry = this._map.get(serviceIdentifier);
          if (entry !== undefined) {
              entry.push(value);
              this._map.set(serviceIdentifier, entry);
          }
          else {
              this._map.set(serviceIdentifier, [value]);
          }
      };
      Lookup.prototype.get = function (serviceIdentifier) {
          if (serviceIdentifier === null || serviceIdentifier === undefined) {
              throw new Error(NULL_ARGUMENT);
          }
          var entry = this._map.get(serviceIdentifier);
          if (entry !== undefined) {
              return entry;
          }
          else {
              throw new Error(KEY_NOT_FOUND);
          }
      };
      Lookup.prototype.remove = function (serviceIdentifier) {
          if (serviceIdentifier === null || serviceIdentifier === undefined) {
              throw new Error(NULL_ARGUMENT);
          }
          if (!this._map.delete(serviceIdentifier)) {
              throw new Error(KEY_NOT_FOUND);
          }
      };
      Lookup.prototype.removeByCondition = function (condition) {
          var _this = this;
          this._map.forEach(function (entries, key) {
              var updatedEntries = entries.filter(function (entry) { return !condition(entry); });
              if (updatedEntries.length > 0) {
                  _this._map.set(key, updatedEntries);
              }
              else {
                  _this._map.delete(key);
              }
          });
      };
      Lookup.prototype.hasKey = function (serviceIdentifier) {
          if (serviceIdentifier === null || serviceIdentifier === undefined) {
              throw new Error(NULL_ARGUMENT);
          }
          return this._map.has(serviceIdentifier);
      };
      Lookup.prototype.clone = function () {
          var copy = new Lookup();
          this._map.forEach(function (value, key) {
              value.forEach(function (b) { return copy.add(key, b.clone()); });
          });
          return copy;
      };
      Lookup.prototype.traverse = function (func) {
          this._map.forEach(function (value, key) {
              func(key, value);
          });
      };
      return Lookup;
  }());

  var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  };
  var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
          to[j] = from[i];
      return to;
  };
  var Container = (function () {
      function Container(containerOptions) {
          this._appliedMiddleware = [];
          var options = containerOptions || {};
          if (typeof options !== "object") {
              throw new Error("" + CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
          }
          if (options.defaultScope === undefined) {
              options.defaultScope = BindingScopeEnum.Transient;
          }
          else if (options.defaultScope !== BindingScopeEnum.Singleton &&
              options.defaultScope !== BindingScopeEnum.Transient &&
              options.defaultScope !== BindingScopeEnum.Request) {
              throw new Error("" + CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
          }
          if (options.autoBindInjectable === undefined) {
              options.autoBindInjectable = false;
          }
          else if (typeof options.autoBindInjectable !== "boolean") {
              throw new Error("" + CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
          }
          if (options.skipBaseClassChecks === undefined) {
              options.skipBaseClassChecks = false;
          }
          else if (typeof options.skipBaseClassChecks !== "boolean") {
              throw new Error("" + CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
          }
          this.options = {
              autoBindInjectable: options.autoBindInjectable,
              defaultScope: options.defaultScope,
              skipBaseClassChecks: options.skipBaseClassChecks
          };
          this.id = id();
          this._bindingDictionary = new Lookup();
          this._snapshots = [];
          this._middleware = null;
          this.parent = null;
          this._metadataReader = new MetadataReader();
      }
      Container.merge = function (container1, container2) {
          var container3 = [];
          for (var _i = 2; _i < arguments.length; _i++) {
              container3[_i - 2] = arguments[_i];
          }
          var container = new Container();
          var targetContainers = __spreadArray$2([container1, container2], container3).map(function (targetContainer) { return getBindingDictionary(targetContainer); });
          var bindingDictionary = getBindingDictionary(container);
          function copyDictionary(origin, destination) {
              origin.traverse(function (key, value) {
                  value.forEach(function (binding) {
                      destination.add(binding.serviceIdentifier, binding.clone());
                  });
              });
          }
          targetContainers.forEach(function (targetBindingDictionary) {
              copyDictionary(targetBindingDictionary, bindingDictionary);
          });
          return container;
      };
      Container.prototype.load = function () {
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              modules[_i] = arguments[_i];
          }
          var getHelpers = this._getContainerModuleHelpersFactory();
          for (var _a = 0, modules_1 = modules; _a < modules_1.length; _a++) {
              var currentModule = modules_1[_a];
              var containerModuleHelpers = getHelpers(currentModule.id);
              currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
          }
      };
      Container.prototype.loadAsync = function () {
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              modules[_i] = arguments[_i];
          }
          return __awaiter(this, void 0, void 0, function () {
              var getHelpers, _a, modules_2, currentModule, containerModuleHelpers;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          getHelpers = this._getContainerModuleHelpersFactory();
                          _a = 0, modules_2 = modules;
                          _b.label = 1;
                      case 1:
                          if (!(_a < modules_2.length)) return [3, 4];
                          currentModule = modules_2[_a];
                          containerModuleHelpers = getHelpers(currentModule.id);
                          return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction)];
                      case 2:
                          _b.sent();
                          _b.label = 3;
                      case 3:
                          _a++;
                          return [3, 1];
                      case 4: return [2];
                  }
              });
          });
      };
      Container.prototype.unload = function () {
          var _this = this;
          var modules = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              modules[_i] = arguments[_i];
          }
          var conditionFactory = function (expected) { return function (item) {
              return item.moduleId === expected;
          }; };
          modules.forEach(function (module) {
              var condition = conditionFactory(module.id);
              _this._bindingDictionary.removeByCondition(condition);
          });
      };
      Container.prototype.bind = function (serviceIdentifier) {
          var scope = this.options.defaultScope || BindingScopeEnum.Transient;
          var binding = new Binding(serviceIdentifier, scope);
          this._bindingDictionary.add(serviceIdentifier, binding);
          return new BindingToSyntax(binding);
      };
      Container.prototype.rebind = function (serviceIdentifier) {
          this.unbind(serviceIdentifier);
          return this.bind(serviceIdentifier);
      };
      Container.prototype.unbind = function (serviceIdentifier) {
          try {
              this._bindingDictionary.remove(serviceIdentifier);
          }
          catch (e) {
              throw new Error(CANNOT_UNBIND + " " + getServiceIdentifierAsString(serviceIdentifier));
          }
      };
      Container.prototype.unbindAll = function () {
          this._bindingDictionary = new Lookup();
      };
      Container.prototype.isBound = function (serviceIdentifier) {
          var bound = this._bindingDictionary.hasKey(serviceIdentifier);
          if (!bound && this.parent) {
              bound = this.parent.isBound(serviceIdentifier);
          }
          return bound;
      };
      Container.prototype.isBoundNamed = function (serviceIdentifier, named) {
          return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named);
      };
      Container.prototype.isBoundTagged = function (serviceIdentifier, key, value) {
          var bound = false;
          if (this._bindingDictionary.hasKey(serviceIdentifier)) {
              var bindings = this._bindingDictionary.get(serviceIdentifier);
              var request_1 = createMockRequest(this, serviceIdentifier, key, value);
              bound = bindings.some(function (b) { return b.constraint(request_1); });
          }
          if (!bound && this.parent) {
              bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
          }
          return bound;
      };
      Container.prototype.snapshot = function () {
          this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware));
      };
      Container.prototype.restore = function () {
          var snapshot = this._snapshots.pop();
          if (snapshot === undefined) {
              throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE);
          }
          this._bindingDictionary = snapshot.bindings;
          this._middleware = snapshot.middleware;
      };
      Container.prototype.createChild = function (containerOptions) {
          var child = new Container(containerOptions || this.options);
          child.parent = this;
          return child;
      };
      Container.prototype.applyMiddleware = function () {
          var middlewares = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              middlewares[_i] = arguments[_i];
          }
          this._appliedMiddleware = this._appliedMiddleware.concat(middlewares);
          var initial = (this._middleware) ? this._middleware : this._planAndResolve();
          this._middleware = middlewares.reduce(function (prev, curr) { return curr(prev); }, initial);
      };
      Container.prototype.applyCustomMetadataReader = function (metadataReader) {
          this._metadataReader = metadataReader;
      };
      Container.prototype.get = function (serviceIdentifier) {
          return this._get(false, false, TargetTypeEnum.Variable, serviceIdentifier);
      };
      Container.prototype.getTagged = function (serviceIdentifier, key, value) {
          return this._get(false, false, TargetTypeEnum.Variable, serviceIdentifier, key, value);
      };
      Container.prototype.getNamed = function (serviceIdentifier, named) {
          return this.getTagged(serviceIdentifier, NAMED_TAG, named);
      };
      Container.prototype.getAll = function (serviceIdentifier) {
          return this._get(true, true, TargetTypeEnum.Variable, serviceIdentifier);
      };
      Container.prototype.getAllTagged = function (serviceIdentifier, key, value) {
          return this._get(false, true, TargetTypeEnum.Variable, serviceIdentifier, key, value);
      };
      Container.prototype.getAllNamed = function (serviceIdentifier, named) {
          return this.getAllTagged(serviceIdentifier, NAMED_TAG, named);
      };
      Container.prototype.resolve = function (constructorFunction) {
          var tempContainer = this.createChild();
          tempContainer.bind(constructorFunction).toSelf();
          this._appliedMiddleware.forEach(function (m) {
              tempContainer.applyMiddleware(m);
          });
          return tempContainer.get(constructorFunction);
      };
      Container.prototype._getContainerModuleHelpersFactory = function () {
          var _this = this;
          var setModuleId = function (bindingToSyntax, moduleId) {
              bindingToSyntax._binding.moduleId = moduleId;
          };
          var getBindFunction = function (moduleId) {
              return function (serviceIdentifier) {
                  var _bind = _this.bind.bind(_this);
                  var bindingToSyntax = _bind(serviceIdentifier);
                  setModuleId(bindingToSyntax, moduleId);
                  return bindingToSyntax;
              };
          };
          var getUnbindFunction = function (moduleId) {
              return function (serviceIdentifier) {
                  var _unbind = _this.unbind.bind(_this);
                  _unbind(serviceIdentifier);
              };
          };
          var getIsboundFunction = function (moduleId) {
              return function (serviceIdentifier) {
                  var _isBound = _this.isBound.bind(_this);
                  return _isBound(serviceIdentifier);
              };
          };
          var getRebindFunction = function (moduleId) {
              return function (serviceIdentifier) {
                  var _rebind = _this.rebind.bind(_this);
                  var bindingToSyntax = _rebind(serviceIdentifier);
                  setModuleId(bindingToSyntax, moduleId);
                  return bindingToSyntax;
              };
          };
          return function (mId) { return ({
              bindFunction: getBindFunction(mId),
              isboundFunction: getIsboundFunction(),
              rebindFunction: getRebindFunction(mId),
              unbindFunction: getUnbindFunction()
          }); };
      };
      Container.prototype._get = function (avoidConstraints, isMultiInject, targetType, serviceIdentifier, key, value) {
          var result = null;
          var defaultArgs = {
              avoidConstraints: avoidConstraints,
              contextInterceptor: function (context) { return context; },
              isMultiInject: isMultiInject,
              key: key,
              serviceIdentifier: serviceIdentifier,
              targetType: targetType,
              value: value
          };
          if (this._middleware) {
              result = this._middleware(defaultArgs);
              if (result === undefined || result === null) {
                  throw new Error(INVALID_MIDDLEWARE_RETURN);
              }
          }
          else {
              result = this._planAndResolve()(defaultArgs);
          }
          return result;
      };
      Container.prototype._planAndResolve = function () {
          var _this = this;
          return function (args) {
              var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
              context = args.contextInterceptor(context);
              var result = resolve(context);
              return result;
          };
      };
      return Container;
  }());

  function injectable() {
      return function (target) {
          if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) {
              throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
          }
          var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
          Reflect.defineMetadata(PARAM_TYPES, types, target);
          return target;
      };
  }

  function named(name) {
      return function (target, targetKey, index) {
          var metadata = new Metadata(NAMED_TAG, name);
          if (typeof index === "number") {
              tagParameter(target, targetKey, index, metadata);
          }
          else {
              tagProperty(target, targetKey, metadata);
          }
      };
  }

  function optional() {
      return function (target, targetKey, index) {
          var metadata = new Metadata(OPTIONAL_TAG, true);
          if (typeof index === "number") {
              tagParameter(target, targetKey, index, metadata);
          }
          else {
              tagProperty(target, targetKey, metadata);
          }
      };
  }

  function unmanaged() {
      return function (target, targetKey, index) {
          var metadata = new Metadata(UNMANAGED_TAG, true);
          tagParameter(target, targetKey, index, metadata);
      };
  }

  function postConstruct() {
      return function (target, propertyKey, descriptor) {
          var metadata = new Metadata(POST_CONSTRUCT, propertyKey);
          if (Reflect.hasOwnMetadata(POST_CONSTRUCT, target.constructor)) {
              throw new Error(MULTIPLE_POST_CONSTRUCT_METHODS);
          }
          Reflect.defineMetadata(POST_CONSTRUCT, metadata, target.constructor);
      };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Reflect$1;
  (function (Reflect) {
      // Metadata Proposal
      // https://rbuckton.github.io/reflect-metadata/
      (function (factory) {
          var root = typeof commonjsGlobal === "object" ? commonjsGlobal :
              typeof self === "object" ? self :
                  typeof this === "object" ? this :
                      Function("return this;")();
          var exporter = makeExporter(Reflect);
          if (typeof root.Reflect === "undefined") {
              root.Reflect = Reflect;
          }
          else {
              exporter = makeExporter(root.Reflect, exporter);
          }
          factory(exporter);
          function makeExporter(target, previous) {
              return function (key, value) {
                  if (typeof target[key] !== "function") {
                      Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                  }
                  if (previous)
                      previous(key, value);
              };
          }
      })(function (exporter) {
          var hasOwn = Object.prototype.hasOwnProperty;
          // feature test for Symbol support
          var supportsSymbol = typeof Symbol === "function";
          var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
          var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
          var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
          var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
          var downLevel = !supportsCreate && !supportsProto;
          var HashMap = {
              // create an object in dictionary mode (a.k.a. "slow" mode in v8)
              create: supportsCreate
                  ? function () { return MakeDictionary(Object.create(null)); }
                  : supportsProto
                      ? function () { return MakeDictionary({ __proto__: null }); }
                      : function () { return MakeDictionary({}); },
              has: downLevel
                  ? function (map, key) { return hasOwn.call(map, key); }
                  : function (map, key) { return key in map; },
              get: downLevel
                  ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                  : function (map, key) { return map[key]; },
          };
          // Load global or shim versions of Map, Set, and WeakMap
          var functionPrototype = Object.getPrototypeOf(Function);
          var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
          var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
          var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
          var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
          // [[Metadata]] internal slot
          // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
          var Metadata = new _WeakMap();
          /**
           * Applies a set of decorators to a property of a target object.
           * @param decorators An array of decorators.
           * @param target The target object.
           * @param propertyKey (Optional) The property key to decorate.
           * @param attributes (Optional) The property descriptor for the target key.
           * @remarks Decorators are applied in reverse order.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     Example = Reflect.decorate(decoratorsArray, Example);
           *
           *     // property (on constructor)
           *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
           *
           *     // property (on prototype)
           *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
           *
           *     // method (on constructor)
           *     Object.defineProperty(Example, "staticMethod",
           *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
           *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
           *
           *     // method (on prototype)
           *     Object.defineProperty(Example.prototype, "method",
           *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
           *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
           *
           */
          function decorate(decorators, target, propertyKey, attributes) {
              if (!IsUndefined(propertyKey)) {
                  if (!IsArray(decorators))
                      throw new TypeError();
                  if (!IsObject(target))
                      throw new TypeError();
                  if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                      throw new TypeError();
                  if (IsNull(attributes))
                      attributes = undefined;
                  propertyKey = ToPropertyKey(propertyKey);
                  return DecorateProperty(decorators, target, propertyKey, attributes);
              }
              else {
                  if (!IsArray(decorators))
                      throw new TypeError();
                  if (!IsConstructor(target))
                      throw new TypeError();
                  return DecorateConstructor(decorators, target);
              }
          }
          exporter("decorate", decorate);
          // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
          // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
          /**
           * A default metadata decorator factory that can be used on a class, class member, or parameter.
           * @param metadataKey The key for the metadata entry.
           * @param metadataValue The value for the metadata entry.
           * @returns A decorator function.
           * @remarks
           * If `metadataKey` is already defined for the target and target key, the
           * metadataValue for that key will be overwritten.
           * @example
           *
           *     // constructor
           *     @Reflect.metadata(key, value)
           *     class Example {
           *     }
           *
           *     // property (on constructor, TypeScript only)
           *     class Example {
           *         @Reflect.metadata(key, value)
           *         static staticProperty;
           *     }
           *
           *     // property (on prototype, TypeScript only)
           *     class Example {
           *         @Reflect.metadata(key, value)
           *         property;
           *     }
           *
           *     // method (on constructor)
           *     class Example {
           *         @Reflect.metadata(key, value)
           *         static staticMethod() { }
           *     }
           *
           *     // method (on prototype)
           *     class Example {
           *         @Reflect.metadata(key, value)
           *         method() { }
           *     }
           *
           */
          function metadata(metadataKey, metadataValue) {
              function decorator(target, propertyKey) {
                  if (!IsObject(target))
                      throw new TypeError();
                  if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                      throw new TypeError();
                  OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
              }
              return decorator;
          }
          exporter("metadata", metadata);
          /**
           * Define a unique metadata entry on the target.
           * @param metadataKey A key used to store and retrieve metadata.
           * @param metadataValue A value that contains attached metadata.
           * @param target The target object on which to define metadata.
           * @param propertyKey (Optional) The property key for the target.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     Reflect.defineMetadata("custom:annotation", options, Example);
           *
           *     // property (on constructor)
           *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
           *
           *     // property (on prototype)
           *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
           *
           *     // method (on constructor)
           *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
           *
           *     // method (on prototype)
           *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
           *
           *     // decorator factory as metadata-producing annotation.
           *     function MyAnnotation(options): Decorator {
           *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
           *     }
           *
           */
          function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          exporter("defineMetadata", defineMetadata);
          /**
           * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
           * @param metadataKey A key used to store and retrieve metadata.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.hasMetadata("custom:annotation", Example);
           *
           *     // property (on constructor)
           *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
           *
           */
          function hasMetadata(metadataKey, target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryHasMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasMetadata", hasMetadata);
          /**
           * Gets a value indicating whether the target object has the provided metadata key defined.
           * @param metadataKey A key used to store and retrieve metadata.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
           *
           *     // property (on constructor)
           *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
           *
           */
          function hasOwnMetadata(metadataKey, target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("hasOwnMetadata", hasOwnMetadata);
          /**
           * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
           * @param metadataKey A key used to store and retrieve metadata.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.getMetadata("custom:annotation", Example);
           *
           *     // property (on constructor)
           *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
           *
           */
          function getMetadata(metadataKey, target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryGetMetadata(metadataKey, target, propertyKey);
          }
          exporter("getMetadata", getMetadata);
          /**
           * Gets the metadata value for the provided metadata key on the target object.
           * @param metadataKey A key used to store and retrieve metadata.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.getOwnMetadata("custom:annotation", Example);
           *
           *     // property (on constructor)
           *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
           *
           */
          function getOwnMetadata(metadataKey, target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
          }
          exporter("getOwnMetadata", getOwnMetadata);
          /**
           * Gets the metadata keys defined on the target object or its prototype chain.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns An array of unique metadata keys.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.getMetadataKeys(Example);
           *
           *     // property (on constructor)
           *     result = Reflect.getMetadataKeys(Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.getMetadataKeys(Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.getMetadataKeys(Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.getMetadataKeys(Example.prototype, "method");
           *
           */
          function getMetadataKeys(target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryMetadataKeys(target, propertyKey);
          }
          exporter("getMetadataKeys", getMetadataKeys);
          /**
           * Gets the unique metadata keys defined on the target object.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns An array of unique metadata keys.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.getOwnMetadataKeys(Example);
           *
           *     // property (on constructor)
           *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
           *
           */
          function getOwnMetadataKeys(target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              return OrdinaryOwnMetadataKeys(target, propertyKey);
          }
          exporter("getOwnMetadataKeys", getOwnMetadataKeys);
          /**
           * Deletes the metadata entry from the target object with the provided key.
           * @param metadataKey A key used to store and retrieve metadata.
           * @param target The target object on which the metadata is defined.
           * @param propertyKey (Optional) The property key for the target.
           * @returns `true` if the metadata entry was found and deleted; otherwise, false.
           * @example
           *
           *     class Example {
           *         // property declarations are not part of ES6, though they are valid in TypeScript:
           *         // static staticProperty;
           *         // property;
           *
           *         constructor(p) { }
           *         static staticMethod(p) { }
           *         method(p) { }
           *     }
           *
           *     // constructor
           *     result = Reflect.deleteMetadata("custom:annotation", Example);
           *
           *     // property (on constructor)
           *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
           *
           *     // property (on prototype)
           *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
           *
           *     // method (on constructor)
           *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
           *
           *     // method (on prototype)
           *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
           *
           */
          function deleteMetadata(metadataKey, target, propertyKey) {
              if (!IsObject(target))
                  throw new TypeError();
              if (!IsUndefined(propertyKey))
                  propertyKey = ToPropertyKey(propertyKey);
              var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
              if (IsUndefined(metadataMap))
                  return false;
              if (!metadataMap.delete(metadataKey))
                  return false;
              if (metadataMap.size > 0)
                  return true;
              var targetMetadata = Metadata.get(target);
              targetMetadata.delete(propertyKey);
              if (targetMetadata.size > 0)
                  return true;
              Metadata.delete(target);
              return true;
          }
          exporter("deleteMetadata", deleteMetadata);
          function DecorateConstructor(decorators, target) {
              for (var i = decorators.length - 1; i >= 0; --i) {
                  var decorator = decorators[i];
                  var decorated = decorator(target);
                  if (!IsUndefined(decorated) && !IsNull(decorated)) {
                      if (!IsConstructor(decorated))
                          throw new TypeError();
                      target = decorated;
                  }
              }
              return target;
          }
          function DecorateProperty(decorators, target, propertyKey, descriptor) {
              for (var i = decorators.length - 1; i >= 0; --i) {
                  var decorator = decorators[i];
                  var decorated = decorator(target, propertyKey, descriptor);
                  if (!IsUndefined(decorated) && !IsNull(decorated)) {
                      if (!IsObject(decorated))
                          throw new TypeError();
                      descriptor = decorated;
                  }
              }
              return descriptor;
          }
          function GetOrCreateMetadataMap(O, P, Create) {
              var targetMetadata = Metadata.get(O);
              if (IsUndefined(targetMetadata)) {
                  if (!Create)
                      return undefined;
                  targetMetadata = new _Map();
                  Metadata.set(O, targetMetadata);
              }
              var metadataMap = targetMetadata.get(P);
              if (IsUndefined(metadataMap)) {
                  if (!Create)
                      return undefined;
                  metadataMap = new _Map();
                  targetMetadata.set(P, metadataMap);
              }
              return metadataMap;
          }
          // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
          function OrdinaryHasMetadata(MetadataKey, O, P) {
              var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
              if (hasOwn)
                  return true;
              var parent = OrdinaryGetPrototypeOf(O);
              if (!IsNull(parent))
                  return OrdinaryHasMetadata(MetadataKey, parent, P);
              return false;
          }
          // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
          function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
              if (IsUndefined(metadataMap))
                  return false;
              return ToBoolean(metadataMap.has(MetadataKey));
          }
          // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
          function OrdinaryGetMetadata(MetadataKey, O, P) {
              var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
              if (hasOwn)
                  return OrdinaryGetOwnMetadata(MetadataKey, O, P);
              var parent = OrdinaryGetPrototypeOf(O);
              if (!IsNull(parent))
                  return OrdinaryGetMetadata(MetadataKey, parent, P);
              return undefined;
          }
          // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
          function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
              if (IsUndefined(metadataMap))
                  return undefined;
              return metadataMap.get(MetadataKey);
          }
          // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
          function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
              metadataMap.set(MetadataKey, MetadataValue);
          }
          // 3.1.6.1 OrdinaryMetadataKeys(O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
          function OrdinaryMetadataKeys(O, P) {
              var ownKeys = OrdinaryOwnMetadataKeys(O, P);
              var parent = OrdinaryGetPrototypeOf(O);
              if (parent === null)
                  return ownKeys;
              var parentKeys = OrdinaryMetadataKeys(parent, P);
              if (parentKeys.length <= 0)
                  return ownKeys;
              if (ownKeys.length <= 0)
                  return parentKeys;
              var set = new _Set();
              var keys = [];
              for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                  var key = ownKeys_1[_i];
                  var hasKey = set.has(key);
                  if (!hasKey) {
                      set.add(key);
                      keys.push(key);
                  }
              }
              for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                  var key = parentKeys_1[_a];
                  var hasKey = set.has(key);
                  if (!hasKey) {
                      set.add(key);
                      keys.push(key);
                  }
              }
              return keys;
          }
          // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
          // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
          function OrdinaryOwnMetadataKeys(O, P) {
              var keys = [];
              var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
              if (IsUndefined(metadataMap))
                  return keys;
              var keysObj = metadataMap.keys();
              var iterator = GetIterator(keysObj);
              var k = 0;
              while (true) {
                  var next = IteratorStep(iterator);
                  if (!next) {
                      keys.length = k;
                      return keys;
                  }
                  var nextValue = IteratorValue(next);
                  try {
                      keys[k] = nextValue;
                  }
                  catch (e) {
                      try {
                          IteratorClose(iterator);
                      }
                      finally {
                          throw e;
                      }
                  }
                  k++;
              }
          }
          // 6 ECMAScript Data Typ0es and Values
          // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
          function Type(x) {
              if (x === null)
                  return 1 /* Null */;
              switch (typeof x) {
                  case "undefined": return 0 /* Undefined */;
                  case "boolean": return 2 /* Boolean */;
                  case "string": return 3 /* String */;
                  case "symbol": return 4 /* Symbol */;
                  case "number": return 5 /* Number */;
                  case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                  default: return 6 /* Object */;
              }
          }
          // 6.1.1 The Undefined Type
          // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
          function IsUndefined(x) {
              return x === undefined;
          }
          // 6.1.2 The Null Type
          // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
          function IsNull(x) {
              return x === null;
          }
          // 6.1.5 The Symbol Type
          // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
          function IsSymbol(x) {
              return typeof x === "symbol";
          }
          // 6.1.7 The Object Type
          // https://tc39.github.io/ecma262/#sec-object-type
          function IsObject(x) {
              return typeof x === "object" ? x !== null : typeof x === "function";
          }
          // 7.1 Type Conversion
          // https://tc39.github.io/ecma262/#sec-type-conversion
          // 7.1.1 ToPrimitive(input [, PreferredType])
          // https://tc39.github.io/ecma262/#sec-toprimitive
          function ToPrimitive(input, PreferredType) {
              switch (Type(input)) {
                  case 0 /* Undefined */: return input;
                  case 1 /* Null */: return input;
                  case 2 /* Boolean */: return input;
                  case 3 /* String */: return input;
                  case 4 /* Symbol */: return input;
                  case 5 /* Number */: return input;
              }
              var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
              var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
              if (exoticToPrim !== undefined) {
                  var result = exoticToPrim.call(input, hint);
                  if (IsObject(result))
                      throw new TypeError();
                  return result;
              }
              return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
          }
          // 7.1.1.1 OrdinaryToPrimitive(O, hint)
          // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
          function OrdinaryToPrimitive(O, hint) {
              if (hint === "string") {
                  var toString_1 = O.toString;
                  if (IsCallable(toString_1)) {
                      var result = toString_1.call(O);
                      if (!IsObject(result))
                          return result;
                  }
                  var valueOf = O.valueOf;
                  if (IsCallable(valueOf)) {
                      var result = valueOf.call(O);
                      if (!IsObject(result))
                          return result;
                  }
              }
              else {
                  var valueOf = O.valueOf;
                  if (IsCallable(valueOf)) {
                      var result = valueOf.call(O);
                      if (!IsObject(result))
                          return result;
                  }
                  var toString_2 = O.toString;
                  if (IsCallable(toString_2)) {
                      var result = toString_2.call(O);
                      if (!IsObject(result))
                          return result;
                  }
              }
              throw new TypeError();
          }
          // 7.1.2 ToBoolean(argument)
          // https://tc39.github.io/ecma262/2016/#sec-toboolean
          function ToBoolean(argument) {
              return !!argument;
          }
          // 7.1.12 ToString(argument)
          // https://tc39.github.io/ecma262/#sec-tostring
          function ToString(argument) {
              return "" + argument;
          }
          // 7.1.14 ToPropertyKey(argument)
          // https://tc39.github.io/ecma262/#sec-topropertykey
          function ToPropertyKey(argument) {
              var key = ToPrimitive(argument, 3 /* String */);
              if (IsSymbol(key))
                  return key;
              return ToString(key);
          }
          // 7.2 Testing and Comparison Operations
          // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
          // 7.2.2 IsArray(argument)
          // https://tc39.github.io/ecma262/#sec-isarray
          function IsArray(argument) {
              return Array.isArray
                  ? Array.isArray(argument)
                  : argument instanceof Object
                      ? argument instanceof Array
                      : Object.prototype.toString.call(argument) === "[object Array]";
          }
          // 7.2.3 IsCallable(argument)
          // https://tc39.github.io/ecma262/#sec-iscallable
          function IsCallable(argument) {
              // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
              return typeof argument === "function";
          }
          // 7.2.4 IsConstructor(argument)
          // https://tc39.github.io/ecma262/#sec-isconstructor
          function IsConstructor(argument) {
              // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
              return typeof argument === "function";
          }
          // 7.2.7 IsPropertyKey(argument)
          // https://tc39.github.io/ecma262/#sec-ispropertykey
          function IsPropertyKey(argument) {
              switch (Type(argument)) {
                  case 3 /* String */: return true;
                  case 4 /* Symbol */: return true;
                  default: return false;
              }
          }
          // 7.3 Operations on Objects
          // https://tc39.github.io/ecma262/#sec-operations-on-objects
          // 7.3.9 GetMethod(V, P)
          // https://tc39.github.io/ecma262/#sec-getmethod
          function GetMethod(V, P) {
              var func = V[P];
              if (func === undefined || func === null)
                  return undefined;
              if (!IsCallable(func))
                  throw new TypeError();
              return func;
          }
          // 7.4 Operations on Iterator Objects
          // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
          function GetIterator(obj) {
              var method = GetMethod(obj, iteratorSymbol);
              if (!IsCallable(method))
                  throw new TypeError(); // from Call
              var iterator = method.call(obj);
              if (!IsObject(iterator))
                  throw new TypeError();
              return iterator;
          }
          // 7.4.4 IteratorValue(iterResult)
          // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
          function IteratorValue(iterResult) {
              return iterResult.value;
          }
          // 7.4.5 IteratorStep(iterator)
          // https://tc39.github.io/ecma262/#sec-iteratorstep
          function IteratorStep(iterator) {
              var result = iterator.next();
              return result.done ? false : result;
          }
          // 7.4.6 IteratorClose(iterator, completion)
          // https://tc39.github.io/ecma262/#sec-iteratorclose
          function IteratorClose(iterator) {
              var f = iterator["return"];
              if (f)
                  f.call(iterator);
          }
          // 9.1 Ordinary Object Internal Methods and Internal Slots
          // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
          // 9.1.1.1 OrdinaryGetPrototypeOf(O)
          // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
          function OrdinaryGetPrototypeOf(O) {
              var proto = Object.getPrototypeOf(O);
              if (typeof O !== "function" || O === functionPrototype)
                  return proto;
              // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
              // Try to determine the superclass constructor. Compatible implementations
              // must either set __proto__ on a subclass constructor to the superclass constructor,
              // or ensure each class has a valid `constructor` property on its prototype that
              // points back to the constructor.
              // If this is not the same as Function.[[Prototype]], then this is definately inherited.
              // This is the case when in ES6 or when using __proto__ in a compatible browser.
              if (proto !== functionPrototype)
                  return proto;
              // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
              var prototype = O.prototype;
              var prototypeProto = prototype && Object.getPrototypeOf(prototype);
              if (prototypeProto == null || prototypeProto === Object.prototype)
                  return proto;
              // If the constructor was not a function, then we cannot determine the heritage.
              var constructor = prototypeProto.constructor;
              if (typeof constructor !== "function")
                  return proto;
              // If we have some kind of self-reference, then we cannot determine the heritage.
              if (constructor === O)
                  return proto;
              // we have a pretty good guess at the heritage.
              return constructor;
          }
          // naive Map shim
          function CreateMapPolyfill() {
              var cacheSentinel = {};
              var arraySentinel = [];
              var MapIterator = /** @class */ (function () {
                  function MapIterator(keys, values, selector) {
                      this._index = 0;
                      this._keys = keys;
                      this._values = values;
                      this._selector = selector;
                  }
                  MapIterator.prototype["@@iterator"] = function () { return this; };
                  MapIterator.prototype[iteratorSymbol] = function () { return this; };
                  MapIterator.prototype.next = function () {
                      var index = this._index;
                      if (index >= 0 && index < this._keys.length) {
                          var result = this._selector(this._keys[index], this._values[index]);
                          if (index + 1 >= this._keys.length) {
                              this._index = -1;
                              this._keys = arraySentinel;
                              this._values = arraySentinel;
                          }
                          else {
                              this._index++;
                          }
                          return { value: result, done: false };
                      }
                      return { value: undefined, done: true };
                  };
                  MapIterator.prototype.throw = function (error) {
                      if (this._index >= 0) {
                          this._index = -1;
                          this._keys = arraySentinel;
                          this._values = arraySentinel;
                      }
                      throw error;
                  };
                  MapIterator.prototype.return = function (value) {
                      if (this._index >= 0) {
                          this._index = -1;
                          this._keys = arraySentinel;
                          this._values = arraySentinel;
                      }
                      return { value: value, done: true };
                  };
                  return MapIterator;
              }());
              return /** @class */ (function () {
                  function Map() {
                      this._keys = [];
                      this._values = [];
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                  }
                  Object.defineProperty(Map.prototype, "size", {
                      get: function () { return this._keys.length; },
                      enumerable: true,
                      configurable: true
                  });
                  Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                  Map.prototype.get = function (key) {
                      var index = this._find(key, /*insert*/ false);
                      return index >= 0 ? this._values[index] : undefined;
                  };
                  Map.prototype.set = function (key, value) {
                      var index = this._find(key, /*insert*/ true);
                      this._values[index] = value;
                      return this;
                  };
                  Map.prototype.delete = function (key) {
                      var index = this._find(key, /*insert*/ false);
                      if (index >= 0) {
                          var size = this._keys.length;
                          for (var i = index + 1; i < size; i++) {
                              this._keys[i - 1] = this._keys[i];
                              this._values[i - 1] = this._values[i];
                          }
                          this._keys.length--;
                          this._values.length--;
                          if (key === this._cacheKey) {
                              this._cacheKey = cacheSentinel;
                              this._cacheIndex = -2;
                          }
                          return true;
                      }
                      return false;
                  };
                  Map.prototype.clear = function () {
                      this._keys.length = 0;
                      this._values.length = 0;
                      this._cacheKey = cacheSentinel;
                      this._cacheIndex = -2;
                  };
                  Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                  Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                  Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                  Map.prototype["@@iterator"] = function () { return this.entries(); };
                  Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                  Map.prototype._find = function (key, insert) {
                      if (this._cacheKey !== key) {
                          this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                      }
                      if (this._cacheIndex < 0 && insert) {
                          this._cacheIndex = this._keys.length;
                          this._keys.push(key);
                          this._values.push(undefined);
                      }
                      return this._cacheIndex;
                  };
                  return Map;
              }());
              function getKey(key, _) {
                  return key;
              }
              function getValue(_, value) {
                  return value;
              }
              function getEntry(key, value) {
                  return [key, value];
              }
          }
          // naive Set shim
          function CreateSetPolyfill() {
              return /** @class */ (function () {
                  function Set() {
                      this._map = new _Map();
                  }
                  Object.defineProperty(Set.prototype, "size", {
                      get: function () { return this._map.size; },
                      enumerable: true,
                      configurable: true
                  });
                  Set.prototype.has = function (value) { return this._map.has(value); };
                  Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                  Set.prototype.delete = function (value) { return this._map.delete(value); };
                  Set.prototype.clear = function () { this._map.clear(); };
                  Set.prototype.keys = function () { return this._map.keys(); };
                  Set.prototype.values = function () { return this._map.values(); };
                  Set.prototype.entries = function () { return this._map.entries(); };
                  Set.prototype["@@iterator"] = function () { return this.keys(); };
                  Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                  return Set;
              }());
          }
          // naive WeakMap shim
          function CreateWeakMapPolyfill() {
              var UUID_SIZE = 16;
              var keys = HashMap.create();
              var rootKey = CreateUniqueKey();
              return /** @class */ (function () {
                  function WeakMap() {
                      this._key = CreateUniqueKey();
                  }
                  WeakMap.prototype.has = function (target) {
                      var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                      return table !== undefined ? HashMap.has(table, this._key) : false;
                  };
                  WeakMap.prototype.get = function (target) {
                      var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                      return table !== undefined ? HashMap.get(table, this._key) : undefined;
                  };
                  WeakMap.prototype.set = function (target, value) {
                      var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                      table[this._key] = value;
                      return this;
                  };
                  WeakMap.prototype.delete = function (target) {
                      var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                      return table !== undefined ? delete table[this._key] : false;
                  };
                  WeakMap.prototype.clear = function () {
                      // NOTE: not a real clear, just makes the previous data unreachable
                      this._key = CreateUniqueKey();
                  };
                  return WeakMap;
              }());
              function CreateUniqueKey() {
                  var key;
                  do
                      key = "@@WeakMap@@" + CreateUUID();
                  while (HashMap.has(keys, key));
                  keys[key] = true;
                  return key;
              }
              function GetOrCreateWeakMapTable(target, create) {
                  if (!hasOwn.call(target, rootKey)) {
                      if (!create)
                          return undefined;
                      Object.defineProperty(target, rootKey, { value: HashMap.create() });
                  }
                  return target[rootKey];
              }
              function FillRandomBytes(buffer, size) {
                  for (var i = 0; i < size; ++i)
                      buffer[i] = Math.random() * 0xff | 0;
                  return buffer;
              }
              function GenRandomBytes(size) {
                  if (typeof Uint8Array === "function") {
                      if (typeof crypto !== "undefined")
                          return crypto.getRandomValues(new Uint8Array(size));
                      if (typeof msCrypto !== "undefined")
                          return msCrypto.getRandomValues(new Uint8Array(size));
                      return FillRandomBytes(new Uint8Array(size), size);
                  }
                  return FillRandomBytes(new Array(size), size);
              }
              function CreateUUID() {
                  var data = GenRandomBytes(UUID_SIZE);
                  // mark as random - RFC 4122 § 4.4
                  data[6] = data[6] & 0x4f | 0x40;
                  data[8] = data[8] & 0xbf | 0x80;
                  var result = "";
                  for (var offset = 0; offset < UUID_SIZE; ++offset) {
                      var byte = data[offset];
                      if (offset === 4 || offset === 6 || offset === 8)
                          result += "-";
                      if (byte < 16)
                          result += "0";
                      result += byte.toString(16).toLowerCase();
                  }
                  return result;
              }
          }
          // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
          function MakeDictionary(obj) {
              obj.__ = undefined;
              delete obj.__;
              return obj;
          }
      });
  })(Reflect$1 || (Reflect$1 = {}));

  (function (Syringe) {
    /**
     * 定义注入标识，默认允许多重注入
     */
    Syringe.defineToken = function (name) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        multiple: true
      };
      return new Syringe.DefinedToken(name, option);
    };

    var DefinedToken =
    /**
     * 兼容 inversify identifier
     */
    function DefinedToken(name) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, DefinedToken);

      this.prototype = {};
      this.name = void 0;
      this.multiple = void 0;
      this.symbol = void 0;
      var _option$multiple = option.multiple,
          multiple = _option$multiple === void 0 ? false : _option$multiple;
      this.name = name;
      this.symbol = Symbol(this.name);
      this.multiple = multiple;
    };

    Syringe.DefinedToken = DefinedToken;

    function isModule(data) {
      return !!data && _typeof(data) === 'object' && 'id' in data && 'registry' in data;
    }

    Syringe.isModule = isModule;
    var Lifecycle;

    (function (Lifecycle) {
      Lifecycle["singleton"] = "singleton";
      Lifecycle["transient"] = "transient";
    })(Lifecycle = Syringe.Lifecycle || (Syringe.Lifecycle = {}));

    Syringe.ClassOptionSymbol = Symbol('SyringeClassOptionSymbol');
    Syringe.DefaultOption = {
      lifecycle: Lifecycle.transient
    };
  })(exports.Syringe || (exports.Syringe = {})); // eslint-disable-next-line @typescript-eslint/no-explicit-any

  (function (Utils) {
    function maybeArrayToArray(maybeArray) {
      if (!(maybeArray instanceof Array)) {
        if (maybeArray !== undefined) {
          return [maybeArray];
        }

        return [];
      }

      return maybeArray;
    }

    Utils.maybeArrayToArray = maybeArrayToArray;

    function isClass(data) {
      return !!(data && typeof data === 'function' && 'prototype' in data);
    }

    Utils.isClass = isClass;

    function isDefinedToken(data) {
      return !!(data && _typeof(data) === 'object' && 'symbol' in data && 'multiple' in data);
    }

    Utils.isDefinedToken = isDefinedToken;

    function isInjectOption(data) {
      return !!(data && _typeof(data) === 'object' && 'token' in data);
    }

    Utils.isInjectOption = isInjectOption;

    function isNamedToken(data) {
      return !!(data && _typeof(data) === 'object' && 'token' in data && 'named' in data);
    }

    Utils.isNamedToken = isNamedToken;

    function isMultipleEnabled(token) {
      return Utils.isDefinedToken(token) && token.multiple;
    }

    Utils.isMultipleEnabled = isMultipleEnabled;
  })(exports.Utils || (exports.Utils = {}));

  function bindSingleton(toBind) {
    return toBind.inSingletonScope();
  }
  function bindTransient(toBind) {
    return toBind.inTransientScope();
  }
  function bindLifecycle(toBind, option) {
    if (option.lifecycle === exports.Syringe.Lifecycle.singleton) {
      return bindSingleton(toBind);
    }

    return bindTransient(toBind);
  }
  function bindNamed(toBind, named) {
    toBind.whenTargetNamed(namedToIdentifier(named));
  }
  function bindGeneralToken(token, context) {
    return context.container.bind(tokenToIdentifier(token));
  }
  function bindMonoToken(token, context) {
    var parent = context.container.parent;
    var bindFromParent = parent && parent.isBound(tokenToIdentifier(token));

    if (context.container.isBound(tokenToIdentifier(token)) && !bindFromParent) {
      return context.container.rebind(tokenToIdentifier(token));
    }

    return context.container.bind(tokenToIdentifier(token));
  }
  function isInversifyContext(data) {
    return data && _typeof(data) === 'object' && 'container' in data && 'inversify' in data;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  function namedToIdentifier(named) {
    if (exports.Utils.isDefinedToken(named)) {
      return named.symbol;
    }

    return named;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  function tokenToIdentifier(token) {
    if (exports.Utils.isDefinedToken(token)) {
      return token.symbol;
    }

    return token;
  }
  var GlobalContainer = new Container();

  function injectable$1() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var decorator = injectable();
    return function (target) {
      Reflect.defineMetadata(exports.Syringe.ClassOptionSymbol, _objectSpread2(_objectSpread2({}, option), {}, {
        target: target
      }), target);
      decorator(target);
    };
  }
  function singleton() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return injectable$1(_objectSpread2(_objectSpread2({}, option), {}, {
      lifecycle: exports.Syringe.Lifecycle.singleton
    }));
  }
  function transient() {
    var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return injectable$1(_objectSpread2(_objectSpread2({}, option), {}, {
      lifecycle: exports.Syringe.Lifecycle.transient
    }));
  }
  function inject$1(token) {
    return inject(tokenToIdentifier(token));
  }
  function named$1(name) {
    return named(namedToIdentifier(name));
  }

  var OptionSymbol = Symbol('SyringeOptionSymbol');
  var registerSideOption = function registerSideOption(option, target) {
    Reflect.defineMetadata(OptionSymbol, option, target);
  };

  function toRegistryOption(options) {
    var token = exports.Utils.maybeArrayToArray(options.token);
    var useClass = exports.Utils.maybeArrayToArray(options.useClass);
    var useDynamic = exports.Utils.maybeArrayToArray(options.useDynamic);
    var useFactory = exports.Utils.maybeArrayToArray(options.useFactory);
    var contrib = exports.Utils.maybeArrayToArray(options.contrib);
    var lifecycle = options.lifecycle || exports.Syringe.Lifecycle.transient;
    var generalOption = {
      token: token,
      useClass: useClass,
      lifecycle: contrib.length > 0 ? exports.Syringe.Lifecycle.singleton : lifecycle,
      contrib: contrib,
      useDynamic: useDynamic,
      useFactory: useFactory
    };

    if ('useValue' in options) {
      generalOption.useValue = options.useValue;
    }

    return generalOption;
  }
  var Register = /*#__PURE__*/function () {
    function Register(context, token, option) {
      _classCallCheck(this, Register);

      this.token = void 0;
      this.rawToken = void 0;
      this.named = void 0;
      this.generalToken = void 0;
      this.option = void 0;
      this.context = void 0;
      this.mutiple = void 0;
      this.context = context;
      this.token = token;
      this.option = option;
      this.rawToken = exports.Utils.isNamedToken(token) ? token.token : token;
      this.named = exports.Utils.isNamedToken(token) ? token.named : undefined;
      this.mutiple = !!this.named || exports.Utils.isMultipleEnabled(this.rawToken);
      this.generalToken = this.rawToken;
    }
    /**
     * multi or mono register
     * mono bind 优先级 useValue > useDynamic > useFactory > useClass
     */


    _createClass(Register, [{
      key: "resolve",
      value: function resolve() {
        var _this = this;

        var context = this.context;

        if (!isInversifyContext(context)) {
          return;
        }

        if (this.mutiple) {
          this.resolveMutilple(context);
        } else {
          this.resolveMono(context);

          if (!this.named && this.option.contrib.length > 0) {
            this.option.contrib.forEach(function (contribution) {
              if (exports.Utils.isMultipleEnabled(contribution)) {
                bindGeneralToken(contribution, context).toService(_this.generalToken);
              } else {
                bindMonoToken(contribution, context).toService(_this.generalToken);
              }
            });
          }
        }
      } // eslint-disable-next-line consistent-return

    }, {
      key: "resolveMono",
      value: function resolveMono(context) {
        var _this2 = this;

        if ('useValue' in this.option) {
          return bindMonoToken(this.generalToken, context).toConstantValue(this.option.useValue);
        }

        if (this.option.useDynamic.length > 0) {
          var dynamic = this.option.useDynamic[this.option.useDynamic.length - 1];
          return bindLifecycle(bindMonoToken(this.generalToken, context).toDynamicValue(function () {
            return dynamic({
              container: _this2.context
            });
          }), this.option);
        }

        if (this.option.useFactory.length > 0) {
          var factrory = this.option.useFactory[this.option.useFactory.length - 1];
          return bindMonoToken(this.generalToken, context).toFactory(function () {
            return factrory({
              container: _this2.context
            });
          });
        }

        if (this.option.useClass.length > 0) {
          var newable = this.option.useClass[this.option.useClass.length - 1];
          return bindLifecycle(bindMonoToken(this.generalToken, context).to(newable), this.option);
        }
      }
    }, {
      key: "resolveMutilple",
      value: function resolveMutilple(context) {
        var _this3 = this;

        var classesList = this.option.useClass.map(function (newable) {
          return bindLifecycle(bindGeneralToken(_this3.generalToken, context).to(newable), _this3.option);
        });
        var dynamicList = this.option.useDynamic.map(function (dynamic) {
          return bindLifecycle(bindGeneralToken(_this3.generalToken, context).toDynamicValue(function () {
            return dynamic({
              container: _this3.context
            });
          }), _this3.option);
        });
        var factoryList = this.option.useFactory.map(function (factrory) {
          return bindGeneralToken(_this3.generalToken, context).toFactory(function () {
            return factrory({
              container: _this3.context
            });
          });
        });
        var valueToBind = 'useValue' in this.option ? bindGeneralToken(this.generalToken, context).toConstantValue(this.option.useValue) : undefined;

        if (this.named) {
          classesList.forEach(function (tobind) {
            return _this3.named && bindNamed(tobind, _this3.named);
          });
          dynamicList.forEach(function (tobind) {
            return _this3.named && bindNamed(tobind, _this3.named);
          });
          factoryList.forEach(function (tobind) {
            return _this3.named && bindNamed(tobind, _this3.named);
          });

          if (valueToBind) {
            bindNamed(valueToBind, this.named);
          }
        }
      }
    }], [{
      key: "resolveTarget",
      value: // eslint-disable-next-line @typescript-eslint/no-explicit-any

      /**
       * 注册目标 token，合并 token 配置后基于配置注册
       */
      function resolveTarget(context, target) {
        var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        try {
          try {
            var sideOption = Reflect.getMetadata(OptionSymbol, target);

            if (sideOption) {
              Register.resolveOption(context, sideOption);
            }
          } catch (ex) {// noop
          } // 当 target 为类时，将其插入 useClass 配置中


          if (exports.Utils.isClass(target)) {
            if (!option.useClass) {
              option.useClass = [target];
            } else {
              var classes = exports.Utils.maybeArrayToArray(option.useClass);
              classes.unshift(target);
              option.useClass = classes;
            }
          }

          var mixedOption;

          try {
            mixedOption = Reflect.getMetadata(exports.Syringe.ClassOptionSymbol, target);
          } catch (ex) {// noop
          }

          mixedOption = _objectSpread2(_objectSpread2({}, mixedOption || {}), option);

          if (!mixedOption.token) {
            mixedOption.token = [target];
          } else {
            var tokens = exports.Utils.maybeArrayToArray(mixedOption.token);
            tokens.unshift(target);
            mixedOption.token = tokens;
          }

          Register.resolveOption(context, mixedOption);
        } catch (ex) {// noop
        }
      }
      /**
       * 基于配置注册
       */

    }, {
      key: "resolveOption",
      value: function resolveOption(context, baseOption) {
        var parsedOption = toRegistryOption(_objectSpread2(_objectSpread2({}, Register.globalConfig), baseOption));

        if (parsedOption.useClass.length === 0 && parsedOption.useDynamic.length === 0 && parsedOption.useFactory.length === 0 && !('useValue' in parsedOption)) {
          return;
        }

        parsedOption.token.forEach(function (token) {
          var register = new Register(context, token, _objectSpread2({}, parsedOption));
          register.resolve();
        });
      }
    }]);

    return Register;
  }();
  Register.globalConfig = exports.Syringe.DefaultOption;

  /* eslint-disable @typescript-eslint/no-explicit-any */

  var Container$1 = /*#__PURE__*/function () {
    function Container$1(inversifyContainer) {
      _classCallCheck(this, Container$1);

      this.loadedModules = [];
      this.container = void 0;
      this.inversify = true;
      this.parent = void 0;

      if (inversifyContainer) {
        this.container = inversifyContainer;
      } else {
        this.container = new Container();
      }
    }

    _createClass(Container$1, [{
      key: "load",
      value: function load(module, force) {
        if (force || !this.loadedModules.includes(module.id)) {
          module.registry(this.register.bind(this), this.resolveContext());
          this.loadedModules.push(module.id);
        }
      }
    }, {
      key: "remove",
      value: function remove(token) {
        return this.container.unbind(tokenToIdentifier(token));
      }
    }, {
      key: "get",
      value: function get(token) {
        return this.container.get(tokenToIdentifier(token));
      }
    }, {
      key: "getNamed",
      value: function getNamed(token, named) {
        return this.container.getNamed(tokenToIdentifier(token), namedToIdentifier(named));
      }
    }, {
      key: "getAll",
      value: function getAll(token) {
        return this.container.getAll(tokenToIdentifier(token));
      }
    }, {
      key: "getAllNamed",
      value: function getAllNamed(token, named) {
        return this.container.getAllNamed(tokenToIdentifier(token), namedToIdentifier(named));
      }
    }, {
      key: "isBound",
      value: function isBound(token) {
        return this.container.isBound(tokenToIdentifier(token));
      }
    }, {
      key: "isBoundNamed",
      value: function isBoundNamed(token, named) {
        return this.container.isBoundNamed(tokenToIdentifier(token), namedToIdentifier(named));
      }
    }, {
      key: "createChild",
      value: function createChild() {
        var childContainer = this.container.createChild();
        var child = new Container$1(childContainer);
        child.parent = this;
        return child;
      }
    }, {
      key: "register",
      value: function register(token) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (exports.Utils.isInjectOption(token)) {
          Register.resolveOption(this, token);
        } else {
          Register.resolveTarget(this, token, options);
        }
      }
    }, {
      key: "resolveContext",
      value: function resolveContext() {
        return {
          container: this
        };
      }
    }], [{
      key: "config",
      value: function config(option) {
        Register.globalConfig = option;
      }
    }]);

    return Container$1;
  }();
  var GlobalContainer$1 = new Container$1(GlobalContainer);
  var register = GlobalContainer$1.register.bind(GlobalContainer$1);

  var Provider = exports.Syringe.defineToken('ContributionProvider');

  var DefaultContributionProvider = /*#__PURE__*/function () {
    function DefaultContributionProvider(serviceIdentifier, container, option) {
      _classCallCheck(this, DefaultContributionProvider);

      this.option = {
        recursive: false,
        cache: true
      };
      this.services = void 0;
      this.serviceIdentifier = void 0;
      this.container = void 0;
      this.container = container;
      this.serviceIdentifier = serviceIdentifier;

      if (option) {
        this.option = _objectSpread2(_objectSpread2({}, this.option), option);
      }
    }

    _createClass(DefaultContributionProvider, [{
      key: "setServices",
      value: function setServices(recursive) {
        var currentServices = [];
        var currentContainer = this.container;

        while (currentContainer) {
          if (currentContainer.isBound(this.serviceIdentifier)) {
            var list = currentContainer.getAll(this.serviceIdentifier);
            currentServices.push.apply(currentServices, _toConsumableArray(list));
          }

          currentContainer = recursive ? currentContainer.parent : undefined;
        }

        return currentServices;
      }
    }, {
      key: "getContributions",
      value: function getContributions() {
        var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var _this$option$option = _objectSpread2(_objectSpread2({}, this.option), option),
            cache = _this$option$option.cache,
            recursive = _this$option$option.recursive;

        if (!cache || this.services === undefined) {
          this.services = this.setServices(!!recursive);
        }

        return this.services;
      }
    }]);

    return DefaultContributionProvider;
  }();

  function contributionInjectOption(token, option) {
    return {
      token: {
        token: Provider,
        named: token
      },
      useDynamic: function useDynamic(ctx) {
        return new DefaultContributionProvider(token, ctx.container, option);
      },
      lifecycle: exports.Syringe.Lifecycle.singleton
    };
  }
  function contributionRegister(registerMethod, identifier, option) {
    registerMethod({
      token: {
        token: Provider,
        named: identifier
      },
      useDynamic: function useDynamic(ctx) {
        return new DefaultContributionProvider(identifier, ctx.container, option);
      },
      lifecycle: exports.Syringe.Lifecycle.singleton
    });
  }

  var SyringeModule = /*#__PURE__*/function () {
    function SyringeModule(registry) {
      _classCallCheck(this, SyringeModule);

      this.id = void 0;
      this.baseRegistry = void 0;
      this.optionCollection = void 0;
      SyringeModule.moduleId += 1;
      this.id = SyringeModule.moduleId;
      this.baseRegistry = registry;
    }

    _createClass(SyringeModule, [{
      key: "registry",
      get:
      /**
       * @readonly
       * module unique id
       */

      /**
       * Exposed registration function
       */
      function get() {
        var _this = this;

        return function (register, ctx) {
          if (_this.baseRegistry) {
            _this.baseRegistry(register, ctx);
          }

          if (_this.optionCollection) {
            _this.optionCollection.forEach(function (option) {
              return register(option);
            });
          }
        };
      }
    }, {
      key: "options",
      get: function get() {
        if (!this.optionCollection) {
          this.optionCollection = [];
        }

        return this.optionCollection;
      }
    }, {
      key: "register",
      value: function register() {
        var _this2 = this;

        for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
          options[_key] = arguments[_key];
        }

        options.forEach(function (option) {
          return _this2.options.push(option);
        });
        return this;
      }
    }, {
      key: "contribution",
      value: function contribution() {
        var _this3 = this;

        for (var _len2 = arguments.length, tokens = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          tokens[_key2] = arguments[_key2];
        }

        tokens.forEach(function (token) {
          return _this3.options.push(contributionInjectOption(token));
        });
        return this;
      }
    }]);

    return SyringeModule;
  }();
  SyringeModule.moduleId = 0;

  function Module(register) {
    return new SyringeModule(register);
  }

  var contrib = function contrib(token) {
    return function ( // eslint-disable-next-line @typescript-eslint/no-explicit-any
    target, targetKey, index) {
      named$1(token)(target, targetKey, index);
      inject$1(Provider)(target, targetKey, index);
    };
  };

  (function (Contribution) {
    Contribution.Provider = Provider;
    Contribution.register = contributionRegister;
  })(exports.Contribution || (exports.Contribution = {}));

  exports.Container = Container$1;
  exports.DefaultContributionProvider = DefaultContributionProvider;
  exports.GlobalContainer = GlobalContainer$1;
  exports.Module = Module;
  exports.OptionSymbol = OptionSymbol;
  exports.Provider = Provider;
  exports.SyringeModule = SyringeModule;
  exports.contrib = contrib;
  exports.decorate = decorate;
  exports.inject = inject$1;
  exports.injectable = injectable$1;
  exports.named = named$1;
  exports.optional = optional;
  exports.postConstruct = postConstruct;
  exports.register = register;
  exports.registerSideOption = registerSideOption;
  exports.singleton = singleton;
  exports.transient = transient;
  exports.unmanaged = unmanaged;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
