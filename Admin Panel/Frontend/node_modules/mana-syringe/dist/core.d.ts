import 'reflect-metadata';
export declare type TokenOption = {
    multiple?: boolean;
};
export declare type Newable<T> = new (...args: any[]) => T;
export declare type Decorator<T> = (target: Newable<T> | Abstract<T>) => any;
export declare type Abstract<T> = {
    prototype: T;
};
export declare namespace Syringe {
    /**
     * 定义注入标识，默认允许多重注入
     */
    const defineToken: (name: string, option?: Partial<TokenOption>) => DefinedToken;
    class DefinedToken {
        /**
         * 兼容 inversify identifier
         */
        prototype: any;
        protected name: string;
        readonly multiple: boolean;
        readonly symbol: symbol;
        constructor(name: string, option?: Partial<TokenOption>);
    }
    type Register = <T = any>(token: Syringe.Token<T> | Syringe.InjectOption<T>, options?: Syringe.InjectOption<T>) => void;
    type Token<T> = string | symbol | Newable<T> | Abstract<T> | DefinedToken;
    type Named = string | symbol | DefinedToken;
    type NamedToken<T> = {
        token: Token<T>;
        named: Named;
    };
    type OverrideToken<T> = {
        token: Token<T>;
        override: boolean;
    };
    type Registry = (register: Register, ctx: Context) => void;
    type Module = {
        id: number;
        registry: Registry;
    };
    function isModule(data: Record<any, any> | undefined): data is Module;
    type Container = {
        parent?: Container;
        remove: <T>(token: Syringe.Token<T>) => void;
        register: <T = any>(token: Syringe.Token<T> | Syringe.InjectOption<T>, options?: Syringe.InjectOption<T>) => void;
        load: (module: Module, force?: boolean) => void;
        get: <T>(token: Syringe.Token<T>) => T;
        getNamed: <T>(token: Syringe.Token<T>, named: Syringe.Named) => T;
        getAll: <T>(token: Syringe.Token<T>) => T[];
        getAllNamed: <T>(token: Syringe.Token<T>, named: Syringe.Named) => T[];
        isBound: <T>(token: Syringe.Token<T>) => boolean;
        isBoundNamed: <T>(token: Syringe.Token<T>, named: Syringe.Named) => boolean;
        createChild: () => Container;
    };
    type Context = {
        container: Container;
    };
    type UnionToken<T> = Token<T> | NamedToken<T>;
    type Class<T> = Newable<T>;
    type Factory<T> = (ctx: Context) => (...args: any) => T;
    type Dynamic<T> = (ctx: Context) => T;
    type MaybeArray<T> = T | T[];
    type DecoratorOption<T> = {
        token?: MaybeArray<UnionToken<T>>;
        contrib?: MaybeArray<Token<T>>;
        lifecycle?: Lifecycle;
    };
    type TargetOption<T> = {
        contrib?: MaybeArray<Token<T>>;
    } & ValueOption<T>;
    type ValueOption<T> = {
        useClass?: MaybeArray<Class<T>>;
        useDynamic?: MaybeArray<Dynamic<T>>;
        useFactory?: MaybeArray<Factory<T>>;
        useValue?: T;
    };
    type InjectOption<T> = DecoratorOption<T> & ValueOption<T>;
    enum Lifecycle {
        singleton = "singleton",
        transient = "transient"
    }
    const ClassOptionSymbol: unique symbol;
    type FormattedInjectOption<T> = {
        token: UnionToken<T>[];
        contrib: Token<T>[];
        useClass: Class<T>[];
        lifecycle: Lifecycle;
        useDynamic: Dynamic<T>[];
        useFactory: Factory<T>[];
        useValue?: T;
    } & InjectOption<T>;
    const DefaultOption: Syringe.InjectOption<any>;
}
export declare namespace Utils {
    function maybeArrayToArray<T>(maybeArray: Syringe.MaybeArray<T> | undefined): T[];
    function isClass(data?: string | symbol | Record<string, any>): data is Syringe.Class<any>;
    function isDefinedToken(data: Record<string, any> | undefined | symbol | string | number): data is Syringe.DefinedToken;
    function isInjectOption<T>(data: Syringe.Token<T> | Syringe.InjectOption<T> | undefined): data is Syringe.InjectOption<T>;
    function isNamedToken<T>(data: Syringe.UnionToken<T> | undefined): data is Syringe.NamedToken<T>;
    function isMultipleEnabled<T>(token: Syringe.Token<T>): boolean;
}
