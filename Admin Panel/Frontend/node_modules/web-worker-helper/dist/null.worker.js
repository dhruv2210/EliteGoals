(function () {
    'use strict';

    // From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license
    // http://2ality.com/2016/10/asynchronous-iteration.html
    /**
     * Async Queue
     * - AsyncIterable: An async iterator can be
     * - Values can be pushed onto the queue
     * @example
     *   const asyncQueue = new AsyncQueue();
     *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);
     *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);
     *   for await (const value of asyncQueue) {
     *     console.log(value); // tick
     *   }
     */
    class AsyncQueue {
        _values;
        _settlers;
        _closed;
        constructor() {
            this._values = []; // enqueues > dequeues
            this._settlers = []; // dequeues > enqueues
            this._closed = false;
        }
        /** Return an async iterator for this queue */
        [Symbol.asyncIterator]() {
            return this;
        }
        /** Push a new value - the async iterator will yield a promise resolved to this value */
        push(value) {
            return this.enqueue(value);
        }
        /**
         * Push a new value - the async iterator will yield a promise resolved to this value
         * Add an error - the async iterator will yield a promise rejected with this value
         */
        enqueue(value) {
            if (this._closed) {
                throw new Error('Closed');
            }
            if (this._settlers.length > 0) {
                if (this._values.length > 0) {
                    throw new Error('Illegal internal state');
                }
                const settler = this._settlers.shift();
                if (value instanceof Error) {
                    settler.reject(value);
                }
                else {
                    settler.resolve({ value });
                }
            }
            else {
                this._values.push(value);
            }
        }
        /** Indicate that we not waiting for more values - The async iterator will be done */
        close() {
            while (this._settlers.length > 0) {
                const settler = this._settlers.shift();
                settler.resolve({ done: true });
            }
            this._closed = true;
        }
        // ITERATOR IMPLEMENTATION
        /** @returns a Promise for an IteratorResult */
        next() {
            // If values in queue, yield the first value
            if (this._values.length > 0) {
                const value = this._values.shift();
                if (value instanceof Error) {
                    return Promise.reject(value);
                }
                return Promise.resolve({ done: false, value });
            }
            // If queue is closed, the iterator is done
            if (this._closed) {
                if (this._settlers.length > 0) {
                    throw new Error('Illegal internal state');
                }
                return Promise.resolve({ done: true, value: undefined });
            }
            // Yield a promise that waits for new values to be enqueued
            return new Promise((resolve, reject) => {
                this._settlers.push({ resolve, reject });
            });
        }
    }

    // NOTE - there is a copy of this function is both in core and loader-utils
    // core does not need all the utils in loader-utils, just this one.
    /**
     * Returns an array of Transferrable objects that can be used with postMessage
     * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
     * @param object data to be sent via postMessage
     * @param recursive - not for application use
     * @param transfers - not for application use
     * @returns a transfer list that can be passed to postMessage
     */
    function getTransferList(object, recursive = true, transfers) {
        // Make sure that items in the transfer list is unique
        const transfersSet = transfers || new Set();
        if (!object) ;
        else if (isTransferable(object)) {
            transfersSet.add(object);
        }
        else if (isTransferable(object.buffer)) {
            // Typed array
            transfersSet.add(object.buffer);
        }
        else if (ArrayBuffer.isView(object)) ;
        else if (recursive && typeof object === 'object') {
            for (const key in object) {
                // Avoid perf hit - only go one level deep
                getTransferList(object[key], recursive, transfersSet);
            }
        }
        // If transfers is defined, is internal recursive call
        // Otherwise it's called by the user
        return transfers === undefined ? Array.from(transfersSet) : [];
    }
    // https://developer.mozilla.org/en-US/docs/Web/API/Transferable
    function isTransferable(object) {
        if (!object) {
            return false;
        }
        if (object instanceof ArrayBuffer) {
            return true;
        }
        if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
            return true;
        }
        if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
            return true;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
            return true;
        }
        return false;
    }

    const onMessageWrapperMap = new Map();
    /**
     * Type safe wrapper for worker code
     */
    class WorkerBody {
        /*
         * (type: WorkerMessageType, payload: WorkerMessagePayload) => any
         */
        static set onmessage(onMessage) {
            self.onmessage = (message) => {
                if (!isKnownMessage(message)) {
                    return;
                }
                // Confusingly the message itself also has a 'type' field which is always set to 'message'
                const { type, payload } = message.data;
                onMessage(type, payload);
            };
        }
        static addEventListener(onMessage) {
            let onMessageWrapper = onMessageWrapperMap.get(onMessage);
            if (!onMessageWrapper) {
                onMessageWrapper = (message) => {
                    if (!isKnownMessage(message)) {
                        return;
                    }
                    // Confusingly the message itself also has a 'type' field which is always set to 'message'
                    const { type, payload } = message.data;
                    onMessage(type, payload);
                };
            }
            self.addEventListener('message', onMessageWrapper);
        }
        static removeEventListener(onMessage) {
            const onMessageWrapper = onMessageWrapperMap.get(onMessage);
            onMessageWrapperMap.delete(onMessage);
            self.removeEventListener('message', onMessageWrapper);
        }
        /**
         * Send a message from a worker to creating thread (main thread)
         * 从 worker 线程发送消息到主线程
         * @param type
         * @param payload
         */
        static postMessage(type, payload) {
            if (self) {
                const data = { source: 'Worker thread', type, payload };
                const transferList = getTransferList(payload);
                // TODO: targetOrigin, transferList
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                self.postMessage(data, transferList);
            }
        }
    }
    // Filter out noise messages sent to workers
    function isKnownMessage(message) {
        const { type, data } = message;
        return type === 'message' && data && typeof data.source === 'string' && data.source === 'Main thread';
    }

    /** Counter for jobs */
    let requestId = 0;
    // 异步队列
    let inputBatches;
    let options;
    /**
     * Set up a WebWorkerGlobalScope to talk with the main thread
     */
    function createWorker(process, processInBatches) {
        // 检查是否在 worker 线程中
        if (typeof self === 'undefined') {
            return;
        }
        const context = {
            process: processOnMainThread,
        };
        WorkerBody.onmessage = async (type, payload) => {
            try {
                switch (type) {
                    case 'process':
                        if (!process) {
                            throw new Error('Worker does not support atomic processing');
                        }
                        // eslint-disable-next-line no-case-declarations
                        const result = await process(payload.input, payload.options || {}, context);
                        WorkerBody.postMessage('done', { result });
                        break;
                    case 'process-in-batches':
                        if (!processInBatches) {
                            throw new Error('Worker does not support batched processing');
                        }
                        inputBatches = new AsyncQueue();
                        options = payload.options || {};
                        // eslint-disable-next-line no-case-declarations
                        const resultIterator = processInBatches(inputBatches, options, context);
                        for await (const batch of resultIterator) {
                            WorkerBody.postMessage('output-batch', { result: batch });
                        }
                        WorkerBody.postMessage('done', {});
                        break;
                    case 'input-batch':
                        inputBatches.push(payload.input);
                        break;
                    case 'input-done':
                        inputBatches.close();
                        break;
                    default:
                }
            }
            catch (error) {
                const message = error instanceof Error ? error.message : '';
                WorkerBody.postMessage('error', { error: message });
            }
        };
    }
    function processOnMainThread(arrayBuffer, options = {}) {
        return new Promise((resolve, reject) => {
            const id = requestId++;
            /**
             */
            const onMessage = (type, payload) => {
                if (payload.id !== id) {
                    // not ours
                    return;
                }
                switch (type) {
                    case 'done':
                        WorkerBody.removeEventListener(onMessage);
                        resolve(payload.result);
                        break;
                    case 'error':
                        WorkerBody.removeEventListener(onMessage);
                        reject(payload.error);
                        break;
                    // ignore
                }
            };
            WorkerBody.addEventListener(onMessage);
            // Ask the main thread to decode data
            const payload = { id, input: arrayBuffer, options };
            WorkerBody.postMessage('process', payload);
        });
    }

    createWorker(async (data, options) => {
        return data;
    });

})();
//# sourceMappingURL=null.worker.js.map
