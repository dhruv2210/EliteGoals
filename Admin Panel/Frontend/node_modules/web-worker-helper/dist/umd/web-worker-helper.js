(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.webWorkerHelper = {}));
})(this, (function (exports) { 'use strict';

    // Replacement for the external assert method to reduce bundle size
    // Note: We don't use the second "message" argument in calling code,
    // so no need to support it here
    /** Throws an `Error` with the optional `message` if `condition` is falsy */
    function assert(condition, message) {
        if (!condition) {
            throw new Error(message || 'web worker helper assertion failed.');
        }
    }

    // Purpose: include this in your module to avoids adding dependencies on
    // micro modules like 'global' and 'is-browser';
    /* eslint-disable no-restricted-globals */
    const globals = {
        self: typeof self !== 'undefined' && self,
        window: typeof window !== 'undefined' && window,
        document: typeof document !== 'undefined' && document,
    };
    const global_ = globals.self || globals.window || {};
    /** true if running on a worker thread */
    const isWorker = typeof importScripts === 'function';
    /** true if running on a mobile device */
    const isMobile = typeof window !== 'undefined' && typeof window.orientation !== 'undefined';

    /**
     * Represents one Job handled by a WorkerPool or WorkerFarm
     */
    class WorkerJob {
        name;
        workerThread;
        isRunning;
        /** Promise that resolves when Job is done */
        result;
        resolve;
        reject;
        constructor(jobName, workerThread) {
            this.name = jobName;
            this.workerThread = workerThread;
            this.isRunning = true;
            this.resolve = () => { };
            this.reject = () => { };
            this.result = new Promise((resolve, reject) => {
                this.resolve = resolve;
                this.reject = reject;
            });
        }
        /**
         * Send a message to the job's worker thread
         * @param data any data structure, ideally consisting mostly of transferrable objects
         */
        postMessage(type, payload) {
            this.workerThread.postMessage({
                source: 'Main thread',
                type,
                payload,
            });
        }
        /**
         * Call to resolve the `result` Promise with the supplied value
         */
        done(value) {
            assert(this.isRunning, 'WorkerJob isRunning false.');
            this.isRunning = false;
            this.resolve(value);
        }
        /**
         * Call to reject the `result` Promise with the supplied error
         */
        error(error) {
            assert(this.isRunning, 'WorkerJob isRunning false.');
            this.isRunning = false;
            this.reject(error);
        }
    }

    const workerURLCache = new Map();
    /**
     * Creates a loadable URL from worker source or URL
     * that can be used to create `Worker` instances.
     * Due to CORS issues it may be necessary to wrap a URL in a small importScripts
     * @param props
     * @param props.source Worker source
     * @param props.url Worker URL
     * @returns loadable url
     */
    function getLoadableWorkerURL(props) {
        assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined
        let workerURL = workerURLCache.get(props.source || props.url);
        if (!workerURL) {
            // Differentiate worker urls from worker source code
            if (props.url) {
                workerURL = getLoadableWorkerURLFromURL(props.url);
                workerURLCache.set(props.url, workerURL);
            }
            if (props.source) {
                workerURL = getLoadableWorkerURLFromSource(props.source);
                workerURLCache.set(props.source, workerURL);
            }
        }
        assert(workerURL);
        return workerURL;
    }
    /**
     * Build a loadable worker URL from worker URL
     * @param url
     * @returns loadable URL
     */
    function getLoadableWorkerURLFromURL(url) {
        // A local script url, we can use it to initialize a Worker directly
        if (!url.startsWith('http')) {
            return url;
        }
        // A remote script, we need to use `importScripts` to load from different origin
        const workerSource = buildScriptSource(url);
        return getLoadableWorkerURLFromSource(workerSource);
    }
    /**
     * Build a loadable worker URL from worker source
     * @param workerSource
     * @returns loadable url
     */
    function getLoadableWorkerURLFromSource(workerSource) {
        // NOTE: webworkify was previously used
        // const blob = webworkify(workerSource, {bare: true});
        const blob = new Blob([workerSource], { type: 'application/javascript' });
        return URL.createObjectURL(blob);
    }
    /**
     * Per spec, worker cannot be initialized with a script from a different origin
     * However a local worker script can still import scripts from other origins,
     * so we simply build a wrapper script.
     *
     * @param workerUrl
     * @returns source
     */
    function buildScriptSource(workerUrl) {
        return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
    }

    // NOTE - there is a copy of this function is both in core and loader-utils
    // core does not need all the utils in loader-utils, just this one.
    /**
     * Returns an array of Transferrable objects that can be used with postMessage
     * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
     * @param object data to be sent via postMessage
     * @param recursive - not for application use
     * @param transfers - not for application use
     * @returns a transfer list that can be passed to postMessage
     */
    function getTransferList(object, recursive = true, transfers) {
        // Make sure that items in the transfer list is unique
        const transfersSet = transfers || new Set();
        if (!object) ;
        else if (isTransferable(object)) {
            transfersSet.add(object);
        }
        else if (isTransferable(object.buffer)) {
            // Typed array
            transfersSet.add(object.buffer);
        }
        else if (ArrayBuffer.isView(object)) ;
        else if (recursive && typeof object === 'object') {
            for (const key in object) {
                // Avoid perf hit - only go one level deep
                getTransferList(object[key], recursive, transfersSet);
            }
        }
        // If transfers is defined, is internal recursive call
        // Otherwise it's called by the user
        return transfers === undefined ? Array.from(transfersSet) : [];
    }
    // https://developer.mozilla.org/en-US/docs/Web/API/Transferable
    function isTransferable(object) {
        if (!object) {
            return false;
        }
        if (object instanceof ArrayBuffer) {
            return true;
        }
        if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
            return true;
        }
        if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
            return true;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
            return true;
        }
        return false;
    }

    const NOOP = () => { };
    /**
     * Represents one worker thread
     */
    class WorkerThread {
        name;
        source;
        url;
        terminated = false;
        worker;
        onMessage;
        onError;
        loadableURL = '';
        constructor(props) {
            const { name, source, url } = props;
            assert(source || url); // Either source or url must be defined
            this.name = name;
            this.source = source;
            this.url = url;
            this.onMessage = NOOP;
            this.onError = (error) => console.log(error);
            this.worker = this.createBrowserWorker();
        }
        static isSupported() {
            return typeof Worker !== 'undefined';
        }
        /**
         * Terminate this worker thread
         * @note Can free up significant memory
         */
        destroy() {
            this.onMessage = NOOP;
            this.onError = NOOP;
            this.worker.terminate();
            this.terminated = true;
        }
        get isRunning() {
            // TODO: isRunning
            return Boolean(this.onMessage);
        }
        /**
         * Send a message to this worker thread
         * @param data any data structure, ideally consisting mostly of transferrable objects
         * @param transferList If not supplied, calculated automatically by traversing data
         */
        postMessage(data, transferList) {
            transferList = transferList || getTransferList(data);
            this.worker.postMessage(data, transferList);
        }
        /**
         * Generate a standard Error from an ErrorEvent
         * @param {ErrorEvent} event
         */
        getErrorFromErrorEvent(event) {
            // Note Error object does not have the expected fields if loading failed completely
            // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers
            // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
            let message = 'Failed to load ';
            message += `worker ${this.name} from ${this.url}. `;
            if (event.message) {
                message += `${event.message} in `;
            }
            // const hasFilename = event.filename && !event.filename.startsWith('blob:');
            // message += hasFilename ? event.filename : this.source.slice(0, 100);
            if (event.lineno) {
                message += `:${event.lineno}:${event.colno}`;
            }
            return new Error(message);
        }
        /**
         * Creates a worker thread on the browser
         */
        createBrowserWorker() {
            this.loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
            const worker = new Worker(this.loadableURL, { name: this.name });
            worker.onmessage = (event) => {
                if (!event.data) {
                    this.onError(new Error('No data received'));
                }
                else {
                    this.onMessage(event.data);
                }
            };
            // This callback represents an uncaught exception in the worker thread
            worker.onerror = (error) => {
                this.onError(this.getErrorFromErrorEvent(error));
                this.terminated = true;
            };
            worker.onmessageerror = (event) => console.error(`worker ${this.name}, message error: ${event}`);
            return worker;
        }
    }

    /**
     * Process multiple data messages with small pool of identical workers
     */
    class WorkerPool {
        name = 'unnamed';
        source;
        url;
        maxConcurrency = 1;
        maxMobileConcurrency = 1;
        onDebug = () => { };
        reuseWorkers = true;
        props = {};
        jobQueue = [];
        idleQueue = [];
        count = 0;
        isDestroyed = false;
        constructor(props) {
            this.source = props.source;
            this.url = props.url;
            this.setProps(props);
        }
        /**
         * Terminates all workers in the pool
         * @note Can free up significant memory
         */
        destroy() {
            // Destroy idle workers, active Workers will be destroyed on completion
            this.idleQueue.forEach((worker) => worker.destroy());
            this.isDestroyed = true;
        }
        setProps(props) {
            this.props = { ...this.props, ...props };
            if (props.name !== undefined) {
                this.name = props.name;
            }
            if (props.maxConcurrency !== undefined) {
                this.maxConcurrency = props.maxConcurrency;
            }
            if (props.maxMobileConcurrency !== undefined) {
                this.maxMobileConcurrency = props.maxMobileConcurrency;
            }
            if (props.reuseWorkers !== undefined) {
                this.reuseWorkers = props.reuseWorkers;
            }
            if (props.onDebug !== undefined) {
                this.onDebug = props.onDebug;
            }
        }
        async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
            // Promise resolves when thread starts working on this job
            const startPromise = new Promise((onStart) => {
                // Promise resolves when thread completes or fails working on this job
                this.jobQueue.push({ name, onMessage, onError, onStart });
                return this;
            });
            this.startQueuedJob();
            return await startPromise;
        }
        /**
         * Starts first queued job if worker is available or can be created
         * Called when job is started and whenever a worker returns to the idleQueue
         */
        async startQueuedJob() {
            if (!this.jobQueue.length) {
                return;
            }
            const workerThread = this.getAvailableWorker();
            if (!workerThread) {
                return;
            }
            // We have a worker, dequeue and start the job
            const queuedJob = this.jobQueue.shift();
            if (queuedJob) {
                this.onDebug({
                    message: 'Starting job',
                    name: queuedJob.name,
                    backlog: this.jobQueue.length,
                    workerThread,
                });
                // Create a worker job to let the app access thread and manage job completion
                const job = new WorkerJob(queuedJob.name, workerThread);
                // Set the worker thread's message handlers
                workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
                workerThread.onError = (error) => queuedJob.onError(job, error);
                // Resolve the start promise so that the app can start sending messages to worker
                queuedJob.onStart(job);
                // Wait for the app to signal that the job is complete, then return worker to queue
                try {
                    await job.result;
                }
                finally {
                    this.returnWorkerToQueue(workerThread);
                }
            }
        }
        /**
         * Returns a worker to the idle queue
         * Destroys the worker if
         *  - pool is destroyed
         *  - if this pool doesn't reuse workers
         *  - if maxConcurrency has been lowered
         */
        returnWorkerToQueue(worker) {
            const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this.getMaxConcurrency();
            if (shouldDestroyWorker) {
                worker.destroy();
                this.count--;
            }
            else {
                this.idleQueue.push(worker);
            }
            if (!this.isDestroyed) {
                this.startQueuedJob();
            }
        }
        /**
         * Returns idle worker or creates new worker if maxConcurrency has not been reached
         */
        getAvailableWorker() {
            // If a worker has completed and returned to the queue, it can be used
            if (this.idleQueue.length > 0) {
                return this.idleQueue.shift() || null;
            }
            // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
            if (this.count < this.getMaxConcurrency()) {
                this.count++;
                const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
                return new WorkerThread({ name, source: this.source, url: this.url });
            }
            // No worker available, have to wait
            return null;
        }
        getMaxConcurrency() {
            return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
        }
    }

    const DEFAULT_PROPS = {
        maxConcurrency: 3,
        maxMobileConcurrency: 1,
        onDebug: () => { },
        reuseWorkers: true,
    };
    /**
     * Process multiple jobs with a "farm" of different workers in worker pools.
     */
    class WorkerFarm {
        props;
        workerPools = new Map();
        // singleton
        static workerFarm;
        /** Check if Workers are supported */
        static isSupported() {
            return WorkerThread.isSupported();
        }
        /** Get the singleton instance of the global worker farm */
        static getWorkerFarm(props = {}) {
            WorkerFarm.workerFarm = WorkerFarm.workerFarm || new WorkerFarm({});
            WorkerFarm.workerFarm.setProps(props);
            return WorkerFarm.workerFarm;
        }
        /** get global instance with WorkerFarm.getWorkerFarm() */
        constructor(props) {
            this.props = { ...DEFAULT_PROPS };
            this.setProps(props);
            this.workerPools = new Map();
        }
        /**
         * Terminate all workers in the farm
         * @note Can free up significant memory
         */
        destroy() {
            for (const workerPool of this.workerPools.values()) {
                workerPool.destroy();
            }
        }
        /**
         * Set props used when initializing worker pools
         * @param props
         */
        setProps(props) {
            this.props = { ...this.props, ...props };
            // Update worker pool props
            for (const workerPool of this.workerPools.values()) {
                workerPool.setProps(this.getWorkerPoolProps());
            }
        }
        /**
         * Returns a worker pool for the specified worker
         * @param options - only used first time for a specific worker name
         * @param options.name - the name of the worker - used to identify worker pool
         * @param options.url -
         * @param options.source -
         * @example
         *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
         */
        getWorkerPool(options) {
            const { name, source, url } = options;
            let workerPool = this.workerPools.get(name);
            if (!workerPool) {
                workerPool = new WorkerPool({
                    name,
                    source,
                    url,
                });
                workerPool.setProps(this.getWorkerPoolProps());
                this.workerPools.set(name, workerPool);
            }
            return workerPool;
        }
        getWorkerPoolProps() {
            return {
                maxConcurrency: this.props.maxConcurrency,
                maxMobileConcurrency: this.props.maxMobileConcurrency,
                reuseWorkers: this.props.reuseWorkers,
                onDebug: this.props.onDebug,
            };
        }
    }

    const onMessageWrapperMap = new Map();
    /**
     * Type safe wrapper for worker code
     */
    class WorkerBody {
        /*
         * (type: WorkerMessageType, payload: WorkerMessagePayload) => any
         */
        static set onmessage(onMessage) {
            self.onmessage = (message) => {
                if (!isKnownMessage(message)) {
                    return;
                }
                // Confusingly the message itself also has a 'type' field which is always set to 'message'
                const { type, payload } = message.data;
                onMessage(type, payload);
            };
        }
        static addEventListener(onMessage) {
            let onMessageWrapper = onMessageWrapperMap.get(onMessage);
            if (!onMessageWrapper) {
                onMessageWrapper = (message) => {
                    if (!isKnownMessage(message)) {
                        return;
                    }
                    // Confusingly the message itself also has a 'type' field which is always set to 'message'
                    const { type, payload } = message.data;
                    onMessage(type, payload);
                };
            }
            self.addEventListener('message', onMessageWrapper);
        }
        static removeEventListener(onMessage) {
            const onMessageWrapper = onMessageWrapperMap.get(onMessage);
            onMessageWrapperMap.delete(onMessage);
            self.removeEventListener('message', onMessageWrapper);
        }
        /**
         * Send a message from a worker to creating thread (main thread)
         * 从 worker 线程发送消息到主线程
         * @param type
         * @param payload
         */
        static postMessage(type, payload) {
            if (self) {
                const data = { source: 'Worker thread', type, payload };
                const transferList = getTransferList(payload);
                // TODO: targetOrigin, transferList
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                self.postMessage(data, transferList);
            }
        }
    }
    // Filter out noise messages sent to workers
    function isKnownMessage(message) {
        const { type, data } = message;
        return type === 'message' && data && typeof data.source === 'string' && data.source === 'Main thread';
    }

    /**
     * Safely stringify JSON (drop non serializable values like functions and regexps)
     * @param value
     */
    function removeNontransferableOptions(object) {
        // options.log object contains functions which cannot be transferred
        // TODO - decide how to handle logging on workers
        // TODO - warn if options stringification is long
        return JSON.parse(stringifyJSON(object));
    }
    function stringifyJSON(v) {
        const cache = new Set();
        return JSON.stringify(v, (key, value) => {
            if (typeof value === 'object' && value !== null) {
                if (cache.has(value)) {
                    // Circular reference found
                    try {
                        // If this value does not reference a parent it can be deduped
                        return JSON.parse(JSON.stringify(value));
                    }
                    catch (err) {
                        // discard key if value cannot be deduped
                        return undefined;
                    }
                }
                // Store value in our set
                cache.add(value);
            }
            return value;
        });
    }

    /**
     * Gets worker object's name (for debugging in Chrome thread inspector window)
     */
    function getWorkerName(worker) {
        return `${worker.name}`;
    }
    /**
     * Generate a worker URL based on worker object and options
     * @returns A URL to one of the following:
     * - a published worker on unpkg CDN
     * - a local test worker
     * - a URL provided by the user in options
     */
    function getWorkerURL(worker, options = {}) {
        const workerOptions = options[worker.id] || {};
        const workerFileName = `${worker.name}.worker.js`;
        let url = workerOptions.workerUrl;
        // If URL is test
        if (options._workerType === 'test') {
            url = `${worker.module}/dist/${workerFileName}`;
        }
        // If url override is not provided, generate a URL to published version on npm CDN unpkg.com
        if (!url) {
            url = `https://unpkg.com/${worker.module}/dist/${workerFileName}`;
        }
        assert(url);
        return url;
    }

    /**
     * Determines if we can parse with worker
     * @param loader
     * @param data
     * @param options
     */
    function canProcessOnWorker(worker, options) {
        if (!WorkerFarm.isSupported()) {
            return false;
        }
        return worker.worker && options?.worker;
    }
    /**
     * This function expects that the worker thread sends certain messages,
     * Creating such a worker can be automated if the worker is wrapper by a call to createWorker
     */
    async function processOnWorker(worker, data, options = {}, context = {}) {
        const name = getWorkerName(worker);
        const url = getWorkerURL(worker, options);
        const workerFarm = WorkerFarm.getWorkerFarm(options);
        const workerPool = workerFarm.getWorkerPool({ name, url });
        const jobName = options.jobName || worker.name;
        const job = await workerPool.startJob(jobName, onMessage.bind(null, context));
        // Kick off the processing in the worker
        const transferableOptions = removeNontransferableOptions(options);
        job.postMessage('process', { input: data, options: transferableOptions });
        const result = await job.result;
        return result.result;
    }
    /**
     * Job completes when we receive the result
     * @param job
     * @param message
     */
    async function onMessage(context, job, type, payload) {
        switch (type) {
            case 'done':
                // Worker is done
                job.done(payload);
                break;
            case 'error':
                // Worker encountered an error
                job.error(new Error(payload.error));
                break;
            case 'process':
                // Worker is asking for us (main thread) to process something
                // eslint-disable-next-line no-case-declarations
                const { id, input, options } = payload;
                try {
                    if (!context.process) {
                        job.postMessage('error', { id, error: 'Worker not set up to process on main thread' });
                        return;
                    }
                    const result = await context.process(input, options);
                    job.postMessage('done', { id, result });
                }
                catch (error) {
                    const message = error instanceof Error ? error.message : 'unknown error';
                    job.postMessage('error', { id, error: message });
                }
                break;
            default:
                console.warn(`process-on-worker: unknown message ${type}`);
        }
    }

    // From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license
    // http://2ality.com/2016/10/asynchronous-iteration.html
    /**
     * Async Queue
     * - AsyncIterable: An async iterator can be
     * - Values can be pushed onto the queue
     * @example
     *   const asyncQueue = new AsyncQueue();
     *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);
     *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);
     *   for await (const value of asyncQueue) {
     *     console.log(value); // tick
     *   }
     */
    class AsyncQueue {
        _values;
        _settlers;
        _closed;
        constructor() {
            this._values = []; // enqueues > dequeues
            this._settlers = []; // dequeues > enqueues
            this._closed = false;
        }
        /** Return an async iterator for this queue */
        [Symbol.asyncIterator]() {
            return this;
        }
        /** Push a new value - the async iterator will yield a promise resolved to this value */
        push(value) {
            return this.enqueue(value);
        }
        /**
         * Push a new value - the async iterator will yield a promise resolved to this value
         * Add an error - the async iterator will yield a promise rejected with this value
         */
        enqueue(value) {
            if (this._closed) {
                throw new Error('Closed');
            }
            if (this._settlers.length > 0) {
                if (this._values.length > 0) {
                    throw new Error('Illegal internal state');
                }
                const settler = this._settlers.shift();
                if (value instanceof Error) {
                    settler.reject(value);
                }
                else {
                    settler.resolve({ value });
                }
            }
            else {
                this._values.push(value);
            }
        }
        /** Indicate that we not waiting for more values - The async iterator will be done */
        close() {
            while (this._settlers.length > 0) {
                const settler = this._settlers.shift();
                settler.resolve({ done: true });
            }
            this._closed = true;
        }
        // ITERATOR IMPLEMENTATION
        /** @returns a Promise for an IteratorResult */
        next() {
            // If values in queue, yield the first value
            if (this._values.length > 0) {
                const value = this._values.shift();
                if (value instanceof Error) {
                    return Promise.reject(value);
                }
                return Promise.resolve({ done: false, value });
            }
            // If queue is closed, the iterator is done
            if (this._closed) {
                if (this._settlers.length > 0) {
                    throw new Error('Illegal internal state');
                }
                return Promise.resolve({ done: true, value: undefined });
            }
            // Yield a promise that waits for new values to be enqueued
            return new Promise((resolve, reject) => {
                this._settlers.push({ resolve, reject });
            });
        }
    }

    /** Counter for jobs */
    let requestId = 0;
    // 异步队列
    let inputBatches;
    let options;
    /**
     * Set up a WebWorkerGlobalScope to talk with the main thread
     */
    function createWorker(process, processInBatches) {
        // 检查是否在 worker 线程中
        if (typeof self === 'undefined') {
            return;
        }
        const context = {
            process: processOnMainThread,
        };
        WorkerBody.onmessage = async (type, payload) => {
            try {
                switch (type) {
                    case 'process':
                        if (!process) {
                            throw new Error('Worker does not support atomic processing');
                        }
                        // eslint-disable-next-line no-case-declarations
                        const result = await process(payload.input, payload.options || {}, context);
                        WorkerBody.postMessage('done', { result });
                        break;
                    case 'process-in-batches':
                        if (!processInBatches) {
                            throw new Error('Worker does not support batched processing');
                        }
                        inputBatches = new AsyncQueue();
                        options = payload.options || {};
                        // eslint-disable-next-line no-case-declarations
                        const resultIterator = processInBatches(inputBatches, options, context);
                        for await (const batch of resultIterator) {
                            WorkerBody.postMessage('output-batch', { result: batch });
                        }
                        WorkerBody.postMessage('done', {});
                        break;
                    case 'input-batch':
                        inputBatches.push(payload.input);
                        break;
                    case 'input-done':
                        inputBatches.close();
                        break;
                    default:
                }
            }
            catch (error) {
                const message = error instanceof Error ? error.message : '';
                WorkerBody.postMessage('error', { error: message });
            }
        };
    }
    function processOnMainThread(arrayBuffer, options = {}) {
        return new Promise((resolve, reject) => {
            const id = requestId++;
            /**
             */
            const onMessage = (type, payload) => {
                if (payload.id !== id) {
                    // not ours
                    return;
                }
                switch (type) {
                    case 'done':
                        WorkerBody.removeEventListener(onMessage);
                        resolve(payload.result);
                        break;
                    case 'error':
                        WorkerBody.removeEventListener(onMessage);
                        reject(payload.error);
                        break;
                    // ignore
                }
            };
            WorkerBody.addEventListener(onMessage);
            // Ask the main thread to decode data
            const payload = { id, input: arrayBuffer, options };
            WorkerBody.postMessage('process', payload);
        });
    }

    /* global importScripts */
    const loadLibraryPromises = {}; // promises
    /**
     * Dynamically loads a library ("module")
     *
     * - wasm library: Array buffer is returned
     * - js library: Parse JS is returned
     *
     * Method depends on environment
     * - browser - script element is created and installed on document
     * - worker - eval is called on global context
     * - node - file is required
     *
     * @param libraryUrl
     * @param moduleName
     * @param options
     */
    async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
        if (moduleName) {
            libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
        }
        // Ensure libraries are only loaded once
        loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
        return await loadLibraryPromises[libraryUrl];
    }
    // TODO - sort out how to resolve paths for main/worker and dev/prod
    function getLibraryUrl(library, moduleName, options) {
        // Check if already a URL
        if (library.startsWith('http')) {
            return library;
        }
        // Allow application to import and supply libraries through `options.modules`
        const modules = options.modules || {};
        if (modules[library]) {
            return modules[library];
        }
        // load from external scripts
        if (options.CDN) {
            assert(options.CDN.startsWith('http'));
            return `${options.CDN}/${moduleName}/dist/libs/${library}`;
        }
        // TODO - loading inside workers requires paths relative to worker script location...
        if (isWorker) {
            return `../src/libs/${library}`;
        }
        return `modules/${moduleName}/src/libs/${library}`;
    }
    async function loadLibraryFromFile(libraryUrl) {
        if (libraryUrl.endsWith('wasm')) {
            const response = await fetch(libraryUrl);
            return await response.arrayBuffer();
        }
        if (isWorker) {
            return importScripts(libraryUrl);
        }
        // TODO - fix - should be more secure than string parsing since observes CORS
        // if (isBrowser) {
        //   return await loadScriptFromFile(libraryUrl);
        // }
        const response = await fetch(libraryUrl);
        const scriptSource = await response.text();
        return loadLibraryFromString(scriptSource, libraryUrl);
    }
    /*
    async function loadScriptFromFile(libraryUrl) {
      const script = document.createElement('script');
      script.src = libraryUrl;
      return await new Promise((resolve, reject) => {
        script.onload = data => {
          resolve(data);
        };
        script.onerror = reject;
      });
    }
    */
    // TODO - Needs security audit...
    //  - Raw eval call
    //  - Potentially bypasses CORS
    // Upside is that this separates fetching and parsing
    // we could create a`LibraryLoader` or`ModuleLoader`
    function loadLibraryFromString(scriptSource, id) {
        if (isWorker) {
            // Use lvalue trick to make eval run in global scope
            eval.call(global_, scriptSource); // eslint-disable-line no-eval
            // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript
            return null;
        }
        const script = document.createElement('script');
        script.id = id;
        // most browsers like a separate text node but some throw an error. The second method covers those.
        try {
            script.appendChild(document.createTextNode(scriptSource));
        }
        catch (e) {
            script.text = scriptSource;
        }
        document.body.appendChild(script);
        return null;
    }
    // TODO - technique for module injection into worker, from THREE.DracoLoader...
    /*
    function combineWorkerWithLibrary(worker, jsContent) {
      var fn = wWorker.toString();
      var body = [
        '// injected',
        jsContent,
        '',
        '// worker',
        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
      ].join('\n');
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    }
    */

    const version = '0.0.3';
    // WORKER OBJECTS
    /** A null worker to test that worker processing is functional */
    const NullWorker = {
        id: 'null',
        name: 'null',
        module: 'web-worker-helper',
        options: {},
    };

    exports.AsyncQueue = AsyncQueue;
    exports.NullWorker = NullWorker;
    exports.WorkerBody = WorkerBody;
    exports.WorkerFarm = WorkerFarm;
    exports.WorkerJob = WorkerJob;
    exports.WorkerPool = WorkerPool;
    exports.WorkerThread = WorkerThread;
    exports.assert = assert;
    exports.canProcessOnWorker = canProcessOnWorker;
    exports.createWorker = createWorker;
    exports.getLibraryUrl = getLibraryUrl;
    exports.getTransferList = getTransferList;
    exports.getWorkerURL = getWorkerURL;
    exports.isWorker = isWorker;
    exports.loadLibrary = loadLibrary;
    exports.processOnWorker = processOnWorker;
    exports.version = version;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=web-worker-helper.js.map
