import { Disposable } from './disposable';
import type { MaybePromise } from './types';
export declare type Event<T> = {
    /**
     *
     * @param listener The listener function will be call when the event happens.
     * @param context The 'this' which will be used when calling the event listener.
     * @return a disposable to remove the listener again.
     */
    (listener: (e: T) => any, context?: any): Disposable;
};
export declare namespace Event {
    const None: Event<void>;
    function map<I, O>(event: Event<I>, mapFunc: (i: I) => O): Event<O>;
}
declare type Callback = (...args: any[]) => any;
declare class CallbackList implements Iterable<Callback> {
    protected mono: boolean;
    constructor(mono?: boolean);
    private _callbacks;
    get callbacks(): [Function, any][];
    get length(): number;
    add(callback: Function, context?: any): void;
    remove(callback: Function, context?: any): void;
    [Symbol.iterator](): IterableIterator<(...args: any[]) => any>;
    invoke(...args: any[]): any[];
    isEmpty(): boolean;
    dispose(): void;
}
export declare type EmitterOptions = {
    onFirstListenerAdd?: Function;
    onLastListenerRemove?: Function;
};
export declare class Emitter<T = any> {
    protected options: EmitterOptions;
    private static noop;
    protected _event?: Event<T>;
    protected _callbacks: CallbackList | undefined;
    disposed: boolean;
    constructor(options?: EmitterOptions);
    get callbacks(): CallbackList;
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event(): Event<T>;
    fire(event: T): any;
    /**
     * Process each listener one by one.
     * Return `false` to stop iterating over the listeners, `true` to continue.
     */
    sequence(processor: (listener: (e: T) => any) => MaybePromise<boolean>): Promise<void>;
    dispose(): void;
}
export {};
