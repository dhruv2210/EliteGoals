import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import geojsonvt from 'geojson-vt';
import VtSource from "../source/geojsonvt";
var DEFAULT_CONFIG = {
  tileSize: 256,
  minZoom: 0,
  maxZoom: Infinity,
  zoomOffset: 0
};
function signedArea(ring) {
  var sum = 0;
  for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2.x - p1.x) * (p1.y + p2.y);
  }
  return sum;
}
function classifyRings(rings) {
  var len = rings.length;
  if (len <= 1) {
    return [rings];
  }
  var polygons = [];
  var polygon;
  var ccw;
  for (var i = 0; i < len; i++) {
    var area = signedArea(rings[i]);
    if (area === 0) {
      continue;
    }
    if (ccw === undefined) {
      ccw = area < 0;
    }
    if (ccw === area < 0) {
      if (polygon) {
        polygons.push(polygon);
      }
      polygon = [rings[i]];
    } else {
      polygon.push(rings[i]);
    }
  }
  if (polygon) {
    polygons.push(polygon);
  }
  return polygons;
}
var VectorTileFeatureTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];
function GetGeoJSON(extent, x, y, z, vectorTileFeature) {
  var coords = vectorTileFeature.geometry;
  var currenType = vectorTileFeature.type;
  var currentProperties = vectorTileFeature.tags;
  var currentId = vectorTileFeature.id;
  var size = extent * Math.pow(2, z);
  var x0 = extent * x;
  var y0 = extent * y;
  var type = VectorTileFeatureTypes[currenType];
  var i;
  var j;
  function project(line) {
    for (var index = 0; index < line.length; index++) {
      var p = line[index];
      if (p[3]) {
        // 避免重复计算
        break;
      }
      var y2 = 180 - (p[1] + y0) * 360 / size;
      var lng = (p[0] + x0) * 360 / size - 180;
      var lat = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
      line[index] = [lng, lat, 0, 1];
    }
  }
  switch (currenType) {
    case 1:
      var points = [];
      for (i = 0; i < coords.length; i++) {
        points[i] = coords[i][0];
      }
      coords = points;
      project(coords);
      break;
    case 2:
      for (i = 0; i < coords.length; i++) {
        project(coords[i]);
      }
      break;
    case 3:
      coords = classifyRings(coords);
      for (i = 0; i < coords.length; i++) {
        for (j = 0; j < coords[i].length; j++) {
          project(coords[i][j]);
        }
      }
      break;
  }
  if (coords.length === 1) {
    coords = coords[0];
  } else {
    type = 'Multi' + type;
  }
  var result = {
    type: 'Feature',
    geometry: {
      type: type,
      coordinates: coords
    },
    properties: currentProperties,
    id: currentId,
    tileOrigin: [0, 0],
    coord: ''
  };
  return result;
}
var getVectorTile = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tile, tileIndex, tileParams, extent) {
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", new Promise(function (resolve) {
            var tileData = tileIndex.getTile(tile.z, tile.x, tile.y);
            // tileData
            var features = tileData ? tileData.features.map(function (vectorTileFeature) {
              return GetGeoJSON(extent, tileParams.x, tileParams.y, tileParams.z, vectorTileFeature);
            }) : [];
            var vectorTile = {
              layers: {
                defaultLayer: {
                  // @ts-ignore
                  features: features
                }
              }
            };
            var vectorSource = new VtSource(vectorTile, tile.x, tile.y, tile.z);
            resolve(vectorSource);
          }));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getVectorTile(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
function getOption(cfg) {
  var defaultOptions = {
    // geojson-vt default options
    maxZoom: 14,
    // max zoom to preserve detail on
    indexMaxZoom: 5,
    // max zoom in the tile index
    indexMaxPoints: 100000,
    // max number of points per tile in the tile index
    tolerance: 3,
    // simplification tolerance (higher means simpler)
    extent: 4096,
    // tile extent
    buffer: 64,
    // tile buffer on each side
    lineMetrics: false,
    // whether to calculate line metrics
    promoteId: null,
    // name of a feature property to be promoted to feature.id
    generateId: true,
    // whether to generate feature ids. Cannot be used with promoteId
    debug: 0 // logging level (0, 1 or 2)
  };

  if (cfg === undefined || typeof cfg.geojsonvtOptions === 'undefined') {
    return defaultOptions;
  } else {
    return _objectSpread(_objectSpread({}, defaultOptions), cfg.geojsonvtOptions);
  }
}
export default function geojsonVTTile(data, cfg) {
  var geojsonOptions = getOption(cfg);
  var extent = geojsonOptions.extent || 4096;
  var tileIndex = geojsonvt(data, geojsonOptions);
  var getTileData = function getTileData(tileParams, tile) {
    return getVectorTile(tile, tileIndex, tileParams, extent);
  };
  var tilesetOptions = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CONFIG), cfg), {}, {
    getTileData: getTileData
  });
  return {
    data: data,
    dataArray: [],
    tilesetOptions: tilesetOptions,
    isTile: true
  };
}