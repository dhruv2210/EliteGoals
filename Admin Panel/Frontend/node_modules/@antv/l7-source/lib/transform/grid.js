var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/transform/grid.ts
var grid_exports = {};
__export(grid_exports, {
  aggregatorToGrid: () => aggregatorToGrid
});
module.exports = __toCommonJS(grid_exports);
var import_l7_utils = require("@antv/l7-utils");
var R_EARTH = 6378e3;
function aggregatorToGrid(data, option) {
  const dataArray = data.dataArray;
  const { size = 10 } = option;
  const pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;
  const { gridHash, gridOffset } = _pointsGridHash(dataArray, size);
  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset, option);
  return {
    yOffset: pixlSize,
    xOffset: pixlSize,
    radius: pixlSize,
    type: "grid",
    dataArray: layerData
  };
}
function _pointsGridHash(dataArray, size) {
  let latMin = Infinity;
  let latMax = -Infinity;
  let pLat;
  for (const point of dataArray) {
    pLat = point.coordinates[1];
    if (Number.isFinite(pLat)) {
      latMin = pLat < latMin ? pLat : latMin;
      latMax = pLat > latMax ? pLat : latMax;
    }
  }
  const centerLat = (latMin + latMax) / 2;
  const gridOffset = _calculateGridLatLonOffset(size, centerLat);
  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset };
  }
  const gridHash = {};
  for (const point of dataArray) {
    const lat = point.coordinates[1];
    const lng = point.coordinates[0];
    if (Number.isFinite(lat) && Number.isFinite(lng)) {
      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);
      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);
      const key = `${latIdx}-${lonIdx}`;
      gridHash[key] = gridHash[key] || { count: 0, points: [] };
      gridHash[key].count += 1;
      gridHash[key].points.push(point);
    }
  }
  return { gridHash, gridOffset };
}
function _calculateGridLatLonOffset(cellSize, latitude) {
  const yOffset = _calculateLatOffset(cellSize);
  const xOffset = _calculateLonOffset(latitude, cellSize);
  return { yOffset, xOffset };
}
function _calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}
function _calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}
function _getGridLayerDataFromGridHash(gridHash, gridOffset, option) {
  return Object.keys(gridHash).reduce((accu, key, i) => {
    const idxs = key.split("-");
    const latIdx = parseInt(idxs[0], 10);
    const lonIdx = parseInt(idxs[1], 10);
    const item = {};
    if (option.field && option.method) {
      const columns = import_l7_utils.Satistics.getColumn(gridHash[key].points, option.field);
      item[option.method] = import_l7_utils.Satistics.statMap[option.method](columns);
    }
    Object.assign(item, {
      _id: i,
      coordinates: (0, import_l7_utils.aProjectFlat)([
        -180 + gridOffset.xOffset * (lonIdx + 0.5),
        -90 + gridOffset.yOffset * (latIdx + 0.5)
      ]),
      rawData: gridHash[key].points,
      count: gridHash[key].count
    });
    accu.push(item);
    return accu;
  }, []);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  aggregatorToGrid
});
