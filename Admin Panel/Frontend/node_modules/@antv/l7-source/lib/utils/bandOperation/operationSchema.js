var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/bandOperation/operationSchema.ts
var operationSchema_exports = {};
__export(operationSchema_exports, {
  operationsSchema: () => operationsSchema
});
module.exports = __toCommonJS(operationSchema_exports);
var operationsSchema = {
  nd: {
    type: "operation",
    expression: [
      "/",
      ["-", ["band", 1], ["band", 0]],
      // R > NIR
      ["+", ["band", 1], ["band", 0]]
    ]
  },
  rgb: {
    type: "function",
    method: strethRgb2minMax
  }
};
function strethRgb2minMax(bandsData, options) {
  const channelR = bandsData[0].rasterData;
  const channelG = bandsData[1].rasterData;
  const channelB = bandsData[2].rasterData;
  const data = [];
  const [low, high] = (options == null ? void 0 : options.countCut) || [2, 98];
  const minMaxR = (options == null ? void 0 : options.RMinMax) || percentile(channelR, low, high);
  const minMaxG = (options == null ? void 0 : options.GMinMax) || percentile(channelG, low, high);
  const minMaxB = (options == null ? void 0 : options.BMinMax) || percentile(channelB, low, high);
  for (let i = 0; i < channelR.length; i++) {
    data.push(Math.max(0, channelR[i] - minMaxR[0]));
    data.push(Math.max(0, channelG[i] - minMaxG[0]));
    data.push(Math.max(0, channelB[i] - minMaxB[0]));
  }
  return {
    rasterData: data,
    rMinMax: minMaxR,
    gMinMax: minMaxG,
    bMinMax: minMaxB
  };
}
function percentile(data, minPercent, maxPercent) {
  const sortData = data.slice().sort((a, b) => a - b);
  const dataLength = sortData.length;
  const min = sortData[Math.ceil(dataLength * minPercent / 100)];
  const max = sortData[Math.ceil(dataLength * maxPercent / 100)];
  return [min, max];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  operationsSchema
});
