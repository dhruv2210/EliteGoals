var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/source.ts
var source_exports = {};
__export(source_exports, {
  default: () => Source
});
module.exports = __toCommonJS(source_exports);
var import_async_hook = require("@antv/async-hook");
var import_l7_utils = require("@antv/l7-utils");
var import_eventemitter3 = require("eventemitter3");
var import_lodash = require("lodash");
var import_factory = require("./factory");
var import_cluster = require("./transform/cluster");
var import_statistics = require("./utils/statistics");
var import_util = require("./utils/util");
function mergeCustomizer(objValue, srcValue) {
  if (Array.isArray(srcValue)) {
    return srcValue;
  }
}
var Source = class extends import_eventemitter3.EventEmitter {
  constructor(data, cfg) {
    super();
    this.type = "source";
    this.isTile = false;
    this.inited = false;
    // 生命周期钩子
    this.hooks = {
      init: new import_async_hook.SyncHook()
    };
    this.parser = { type: "geojson" };
    this.transforms = [];
    this.cluster = false;
    this.clusterOptions = {
      enable: false,
      radius: 40,
      maxZoom: 20,
      zoom: -99,
      method: "count"
    };
    // 是否有效范围
    this.invalidExtent = false;
    this.dataArrayChanged = false;
    this.cfg = {
      autoRender: true
    };
    this.originData = data;
    this.initCfg(cfg);
    this.init().then(() => {
      this.inited = true;
      this.emit("update", {
        type: "inited"
      });
    });
  }
  getSourceCfg() {
    return this.cfg;
  }
  getClusters(zoom) {
    return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);
  }
  getClustersLeaves(id) {
    return this.clusterIndex.getLeaves(id, Infinity);
  }
  getParserType() {
    return this.parser.type;
  }
  updateClusterData(zoom) {
    const { method = "sum", field } = this.clusterOptions;
    let data = this.clusterIndex.getClusters(
      this.caculClusterExtent(2),
      Math.floor(zoom)
    );
    this.clusterOptions.zoom = zoom;
    data.forEach((p) => {
      if (!p.id) {
        p.properties.point_count = 1;
      }
    });
    if (field || (0, import_lodash.isFunction)(method)) {
      data = data.map((item) => {
        const id = item.id;
        if (id) {
          const points = this.clusterIndex.getLeaves(id, Infinity);
          const properties = points.map((d) => d.properties);
          let statNum;
          if ((0, import_lodash.isString)(method) && field) {
            const column = (0, import_util.getColumn)(properties, field);
            statNum = import_statistics.statMap[method](column);
          }
          if ((0, import_lodash.isFunction)(method)) {
            statNum = method(properties);
          }
          item.properties.stat = statNum;
        } else {
          item.properties.point_count = 1;
        }
        return item;
      });
    }
    this.data = (0, import_factory.getParser)("geojson")({
      type: "FeatureCollection",
      features: data
    });
    this.executeTrans();
  }
  getFeatureById(id) {
    const { type = "geojson", geometry } = this.parser;
    if (type === "geojson" && !this.cluster) {
      const feature = id < this.originData.features.length ? this.originData.features[id] : "null";
      const newFeature = (0, import_lodash.cloneDeep)(feature);
      if ((newFeature == null ? void 0 : newFeature.properties) && (this.transforms.length !== 0 || this.dataArrayChanged)) {
        const item = this.data.dataArray.find((dataItem) => {
          return dataItem._id === id;
        });
        newFeature.properties = item;
      }
      return newFeature;
    } else if (type === "json" && geometry) {
      return this.data.dataArray.find((dataItem) => dataItem._id === id);
    } else {
      return id < this.data.dataArray.length ? this.data.dataArray[id] : "null";
    }
  }
  updateFeaturePropertiesById(id, properties) {
    this.data.dataArray = this.data.dataArray.map(
      (dataItem) => {
        if (dataItem._id === id) {
          return {
            ...dataItem,
            ...properties
          };
        }
        return dataItem;
      }
    );
    this.dataArrayChanged = true;
    this.emit("update", {
      type: "update"
    });
  }
  getFeatureId(field, value) {
    const feature = this.data.dataArray.find((dataItem) => {
      return dataItem[field] === value;
    });
    return feature == null ? void 0 : feature._id;
  }
  setData(data, options) {
    this.originData = data;
    this.dataArrayChanged = false;
    this.initCfg(options);
    this.init().then(() => {
      this.emit("update", {
        type: "update"
      });
    });
  }
  destroy() {
    var _a;
    this.removeAllListeners();
    this.originData = null;
    this.clusterIndex = null;
    this.data = null;
    (_a = this.tileset) == null ? void 0 : _a.destroy();
  }
  async processData() {
    return new Promise((resolve, reject) => {
      try {
        this.excuteParser();
        this.initCluster();
        this.executeTrans();
        resolve({});
      } catch (err) {
        reject(err);
      }
    });
  }
  initCfg(option) {
    this.cfg = (0, import_lodash.mergeWith)(this.cfg, option, mergeCustomizer);
    const cfg = this.cfg;
    if (cfg) {
      if (cfg.parser) {
        this.parser = cfg.parser;
      }
      if (cfg.transforms) {
        this.transforms = cfg.transforms;
      }
      this.cluster = cfg.cluster || false;
      if (cfg.clusterOptions) {
        this.cluster = true;
        this.clusterOptions = {
          ...this.clusterOptions,
          ...cfg.clusterOptions
        };
      }
    }
  }
  async init() {
    this.inited = false;
    await this.processData();
    this.inited = true;
  }
  /**
   * 数据解析
   */
  excuteParser() {
    const parser = this.parser;
    const type = parser.type || "geojson";
    const sourceParser = (0, import_factory.getParser)(type);
    this.data = sourceParser(this.originData, parser);
    this.tileset = this.initTileset();
    if (parser.cancelExtent) {
      return;
    }
    this.extent = (0, import_l7_utils.extent)(this.data.dataArray);
    this.setCenter(this.extent);
    this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];
  }
  setCenter(bbox) {
    this.center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];
    if (isNaN(this.center[0]) || isNaN(this.center[1])) {
      this.center = [108.92361111111111, 34.54083333333333];
    }
  }
  /**
   * 瓦片数据管理器
   */
  initTileset() {
    const { tilesetOptions } = this.data;
    if (!tilesetOptions) {
      return;
    }
    this.isTile = true;
    if (this.tileset) {
      this.tileset.updateOptions(tilesetOptions);
      return this.tileset;
    }
    const tileset = new import_l7_utils.TilesetManager({
      ...tilesetOptions
    });
    return tileset;
  }
  /**
   * 数据统计
   */
  executeTrans() {
    const trans = this.transforms;
    trans.forEach((tran) => {
      const { type } = tran;
      const data = (0, import_factory.getTransform)(type)(this.data, tran);
      Object.assign(this.data, data);
    });
  }
  /**
   * 数据聚合
   */
  initCluster() {
    if (!this.cluster) {
      return;
    }
    const clusterOptions = this.clusterOptions || {};
    this.clusterIndex = (0, import_cluster.cluster)(this.data, clusterOptions);
  }
  caculClusterExtent(bufferRatio) {
    let newBounds = [
      [-Infinity, -Infinity],
      [Infinity, Infinity]
    ];
    if (!this.invalidExtent) {
      newBounds = (0, import_l7_utils.padBounds)((0, import_l7_utils.bBoxToBounds)(this.extent), bufferRatio);
    }
    return newBounds[0].concat(newBounds[1]);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
