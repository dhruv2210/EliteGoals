import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { encodePickingColor } from "../color";
import { a_Color, a_filter, a_Position, a_vertexId } from "./commonFeatureFunc";
import { LineTriangulation as triangulation } from "./triangulation";
export var lineModel = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var descriptors, features, enablePicking, iconMap, updateFuncs, featureLayout, verticesNum, indices, size;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          descriptors = _ref.descriptors, features = _ref.features, enablePicking = _ref.enablePicking, iconMap = _ref.iconMap;
          updateFuncs = {
            // fixed feature func
            a_Color: a_Color,
            a_Position: a_Position,
            filter: a_filter,
            a_vertexId: a_vertexId,
            a_PickingColor: function a_PickingColor(feature) {
              var id = feature.id;
              return enablePicking ? encodePickingColor(id) : [0, 0, 0];
            },
            // pointFill feature func
            a_DistanceAndIndex: function a_DistanceAndIndex(feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) {
              return vertexIndex === undefined ? [vertex[3], 10] : [vertex[3], vertexIndex];
            },
            a_Total_Distance: function a_Total_Distance(feature, featureIdx, vertex) {
              return [vertex[5]];
            },
            a_Size: function a_Size(feature) {
              var _feature$size = feature.size,
                pointSize = _feature$size === void 0 ? 1 : _feature$size;
              return Array.isArray(pointSize) ? [pointSize[0], pointSize[1]] : [pointSize, 0];
            },
            a_Normal: function a_Normal(feature, featureIdx, vertex, attributeIdx, normal) {
              return normal;
            },
            a_Miter: function a_Miter(feature, featureIdx, vertex) {
              return [vertex[4]];
            },
            a_iconMapUV: function a_iconMapUV(feature) {
              var texture = feature.texture;
              var _ref3 = iconMap[texture] || {
                  x: 0,
                  y: 0
                },
                x = _ref3.x,
                y = _ref3.y;
              return [x, y];
            }
          };
          featureLayout = {
            sizePerElement: 0,
            elements: []
          };
          verticesNum = 0;
          indices = [];
          size = 3;
          features.forEach(function (feature, featureIdx) {
            var _triangulation = triangulation(feature),
              indicesForCurrentFeature = _triangulation.indices,
              verticesForCurrentFeature = _triangulation.vertices,
              normalsForCurrentFeature = _triangulation.normals,
              vertexSize = _triangulation.size,
              indexes = _triangulation.indexes;
            indicesForCurrentFeature.forEach(function (i) {
              indices.push(i + verticesNum);
            });
            size = vertexSize;
            var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
            featureLayout.sizePerElement = size;
            featureLayout.elements.push({
              featureIdx: featureIdx,
              vertices: verticesForCurrentFeature,
              normals: normalsForCurrentFeature,
              offset: verticesNum
            });
            verticesNum += verticesNumForCurrentFeature;
            var _loop = function _loop(vertexIdx) {
              var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
              var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
              var vertexIndex = 0;
              if (indexes && indexes[vertexIdx] !== undefined) {
                vertexIndex = indexes[vertexIdx];
              }
              descriptors.forEach(function (descriptor) {
                // @ts-ignore
                if (descriptor && updateFuncs[descriptor.name]) {
                  var _descriptor$buffer$da;
                  // @ts-ignore
                  (_descriptor$buffer$da = descriptor.buffer.data).push.apply(_descriptor$buffer$da, _toConsumableArray(updateFuncs[descriptor.name](feature, featureIdx, vertice, vertexIdx, normal, vertexIndex)));
                }
              });
            };
            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
              _loop(vertexIdx);
            }
          });
          return _context.abrupt("return", {
            descriptors: descriptors,
            featureLayout: featureLayout,
            indices: indices
          });
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function lineModel(_x) {
    return _ref2.apply(this, arguments);
  };
}();