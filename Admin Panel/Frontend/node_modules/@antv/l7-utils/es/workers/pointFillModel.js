import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { encodePickingColor } from "../color";
import { a_Color, a_filter, a_Position, a_vertexId } from "./commonFeatureFunc";
import { PointFillTriangulation as triangulation } from "./triangulation";
export var pointFillModel = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var descriptors, features, enablePicking, shape2d, updateFuncs, featureLayout, verticesNum, indices, size;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          descriptors = _ref.descriptors, features = _ref.features, enablePicking = _ref.enablePicking, shape2d = _ref.shape2d;
          updateFuncs = {
            // fixed feature func
            a_Color: a_Color,
            a_Position: a_Position,
            filter: a_filter,
            a_vertexId: a_vertexId,
            a_PickingColor: function a_PickingColor(feature) {
              var id = feature.id;
              return enablePicking ? encodePickingColor(id) : [0, 0, 0];
            },
            // pointFill feature func
            a_Shape: function a_Shape(feature) {
              var _feature$shape = feature.shape,
                shape = _feature$shape === void 0 ? 2 : _feature$shape;
              var shapeIndex = shape2d.indexOf(shape);
              return [shapeIndex];
            },
            a_Extrude: function a_Extrude(feature, featureIdx, vertex, attributeIdx) {
              var extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
              var extrudeIndex = attributeIdx % 4 * 3;
              return [extrude[extrudeIndex], extrude[extrudeIndex + 1], extrude[extrudeIndex + 2]];
            },
            a_Size: function a_Size(feature) {
              var _feature$size = feature.size,
                pointSize = _feature$size === void 0 ? 5 : _feature$size;
              return Array.isArray(pointSize) ? [pointSize[0]] : [pointSize];
            }
          };
          featureLayout = {
            sizePerElement: 0,
            elements: []
          };
          verticesNum = 0;
          indices = [];
          size = 3;
          features.forEach(function (feature, featureIdx) {
            var _triangulation = triangulation(feature),
              indicesForCurrentFeature = _triangulation.indices,
              verticesForCurrentFeature = _triangulation.vertices,
              normalsForCurrentFeature = _triangulation.normals,
              vertexSize = _triangulation.size,
              indexes = _triangulation.indexes;
            indicesForCurrentFeature.forEach(function (i) {
              indices.push(i + verticesNum);
            });
            size = vertexSize;
            var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
            featureLayout.sizePerElement = size;
            featureLayout.elements.push({
              featureIdx: featureIdx,
              vertices: verticesForCurrentFeature,
              normals: normalsForCurrentFeature,
              offset: verticesNum
            });
            verticesNum += verticesNumForCurrentFeature;
            var _loop = function _loop(vertexIdx) {
              var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
              var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
              var vertexIndex = 0;
              if (indexes && indexes[vertexIdx] !== undefined) {
                vertexIndex = indexes[vertexIdx];
              }
              descriptors.forEach(function (descriptor) {
                // @ts-ignore
                if (descriptor && updateFuncs[descriptor.name]) {
                  var _descriptor$buffer$da;
                  // @ts-ignore
                  (_descriptor$buffer$da = descriptor.buffer.data).push.apply(_descriptor$buffer$da, _toConsumableArray(updateFuncs[descriptor.name](feature, featureIdx, vertice, vertexIdx, normal, vertexIndex)));
                }
              });
            };
            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
              _loop(vertexIdx);
            }
          });
          return _context.abrupt("return", {
            descriptors: descriptors,
            featureLayout: featureLayout,
            indices: indices
          });
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function pointFillModel(_x) {
    return _ref2.apply(this, arguments);
  };
}();