import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import bbox from '@turf/bbox';
import { degreesToRadians, featureCollection, lineString, radiansToLength } from '@turf/helpers';
import { isNumber } from "./math";
var originShift = 2 * Math.PI * 6378137 / 2.0;
export function lngLatInExtent(lngLat, bounds) {
  var _bounds = _slicedToArray(bounds, 4),
    minLng = _bounds[0],
    minLat = _bounds[1],
    maxLng = _bounds[2],
    maxLat = _bounds[3];
  return lngLat.lng > minLng && lngLat.lng <= maxLng && lngLat.lat > minLat && lngLat.lat <= maxLat;
}
/**
 * 计算地理数据范围
 * @param {dataArray} data 地理坐标数据
 * @return {Array} dataExtent
 */
export function extent(data) {
  var dataExtent = [Infinity, Infinity, -Infinity, -Infinity];
  data.forEach(function (item) {
    var coordinates = item.coordinates;
    caculExtent(dataExtent, coordinates);
  });
  return dataExtent;
}
function caculExtent(dataExtent, coords) {
  if (Array.isArray(coords[0])) {
    coords.forEach(function (coord) {
      caculExtent(dataExtent, coord);
    });
  } else {
    if (dataExtent[0] > coords[0]) {
      dataExtent[0] = coords[0];
    }
    if (dataExtent[1] > coords[1]) {
      dataExtent[1] = coords[1];
    }
    if (dataExtent[2] < coords[0]) {
      dataExtent[2] = coords[0];
    }
    if (dataExtent[3] < coords[1]) {
      dataExtent[3] = coords[1];
    }
  }
  return dataExtent;
}
export function tranfrormCoord(data, cb) {
  return transform(data, cb);
}
function transform(item, cb) {
  if (Array.isArray(item[0])) {
    return item.map(function (coord) {
      return transform(coord, cb);
    });
  }
  return cb(item);
}
export function lngLatToMeters(lnglat) {
  var validate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var accuracy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    enable: true,
    decimal: 1
  };
  lnglat = validateLngLat(lnglat, validate);
  var lng = lnglat[0];
  var lat = lnglat[1];
  var x = lng * originShift / 180.0;
  var y = Math.log(Math.tan((90 + lat) * Math.PI / 360.0)) / (Math.PI / 180.0);
  y = y * originShift / 180.0;
  if (accuracy.enable) {
    x = Number(x.toFixed(accuracy.decimal));
    y = Number(y.toFixed(accuracy.decimal));
  }
  return lnglat.length === 3 ? [x, y, lnglat[2]] : [x, y];
}
export function metersToLngLat(meters) {
  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;
  var x = meters[0];
  var y = meters[1];
  var lng = x / originShift * 180.0;
  var lat = y / originShift * 180.0;
  lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180.0)) - Math.PI / 2.0);
  if (decimal !== undefined && decimal !== null) {
    lng = Number(lng.toFixed(decimal));
    lat = Number(lat.toFixed(decimal));
  }
  return meters.length === 3 ? [lng, lat, meters[2]] : [lng, lat];
}
export function longitude(lng) {
  if (lng === undefined || lng === null) {
    throw new Error('lng is required');
  }

  // lngitudes cannot extends beyond +/-90 degrees
  if (lng > 180 || lng < -180) {
    lng = lng % 360;
    if (lng > 180) {
      lng = -360 + lng;
    }
    if (lng < -180) {
      lng = 360 + lng;
    }
    if (lng === 0) {
      lng = 0;
    }
  }
  return lng;
}
export function latitude(lat) {
  if (lat === undefined || lat === null) {
    throw new Error('lat is required');
  }
  if (lat > 90 || lat < -90) {
    lat = lat % 180;
    if (lat > 90) {
      lat = -180 + lat;
    }
    if (lat < -90) {
      lat = 180 + lat;
    }
    if (lat === 0) {
      lat = 0;
    }
  }
  return lat;
}
export function validateLngLat(lnglat, validate) {
  if (validate === false) {
    return lnglat;
  }
  var lng = longitude(lnglat[0]);
  var lat = latitude(lnglat[1]);

  // Global Mercator does not support latitudes within 85 to 90 degrees
  if (lat > 85) {
    lat = 85;
  }
  if (lat < -85) {
    lat = -85;
  }
  return lnglat.length === 3 ? [lng, lat, lnglat[2]] : [lng, lat];
}
export function aProjectFlat(lnglat) {
  var maxs = 85.0511287798;
  var lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
  var scale = 256 << 20;
  var d = Math.PI / 180;
  var x = lnglat[0] * d;
  var y = lat * d;
  y = Math.log(Math.tan(Math.PI / 4 + y / 2));
  var a = 0.5 / Math.PI;
  var b = 0.5;
  var c = -0.5 / Math.PI;
  d = 0.5;
  x = scale * (a * x + b);
  y = scale * (c * y + d);
  return [Math.floor(x), Math.floor(y)];
}
export function unProjectFlat(px) {
  var a = 0.5 / Math.PI;
  var b = 0.5;
  var c = -0.5 / Math.PI;
  var d = 0.5;
  var scale = 256 << 20;
  var _px = _slicedToArray(px, 2),
    x = _px[0],
    y = _px[1];
  x = (x / scale - b) / a;
  y = (y / scale - d) / c;
  y = (Math.atan(Math.pow(Math.E, y)) - Math.PI / 4) * 2;
  d = Math.PI / 180;
  var lat = y / d;
  var lng = x / d;
  return [lng, lat];
}
export function amap2Project(lng, lat) {
  var r = 85.0511287798;
  var Rg = Math.PI / 180;
  var Tg = 6378137;
  lat = Math.max(Math.min(r, lat), -r);
  lng *= Rg;
  lat *= Rg;
  lat = Math.log(Math.tan(Math.PI / 4 + lat / 2));
  return [lng * Tg, lat * Tg];
}
export function amap2UnProject(x, y) {
  var Rg = Math.PI / 180;
  var Tg = 6378137;
  var lng = x / Tg / Rg;
  var lat = 2 * (Math.atan(Math.exp(y / Tg)) - Math.PI / 4) / Rg;
  return [lng, lat];
}
export function lnglatDistance(coordinates1, coordinates2, units) {
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  units = 'meters');
}
export function project(lnglat) {
  var d = Math.PI / 180;
  var max = 85.0511287798;
  var earthRadius = 6378137;
  var lat = Math.max(Math.min(max, lnglat[1]), -max);
  var sin = Math.sin(lat * d);
  var x = earthRadius * lnglat[0] * d;
  var y = earthRadius * Math.log((1 + sin) / (1 - sin)) / 2;
  return [x, y];
}
export function padBounds(b, bufferRatio) {
  var heightBuffer = Math.abs(b[1][1] - b[0][1]) * bufferRatio;
  var widthBuffer = Math.abs(b[1][0] - b[0][0]) * bufferRatio;
  return [[b[0][0] - widthBuffer, b[0][1] - heightBuffer], [b[1][0] + widthBuffer, b[1][1] + heightBuffer]];
}
/**
 * b1 包含 b2 返回 true 否则false
 * @param b1 bounds1
 * @param b2 bounds2
 */
export function boundsContains(b1, b2) {
  return b1[0][0] <= b2[0][0] && b1[0][1] <= b2[0][1] && b1[1][0] >= b2[1][0] && b1[1][1] >= b2[1][1];
}
/**
 * bbox转换为Bounds
 * @param b1 bbox
 *
 */
export function bBoxToBounds(b1) {
  return [[b1[0], b1[1]], [b1[2], b1[3]]];
}
export function normalize(v) {
  var len = calDistance(v, [0, 0]);
  return [v[0] / len, v[1] / len];
}
export function calDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}
function dotMul(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function getMod(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
export function calAngle(v1, v2) {
  return Math.acos(dotMul(v1, v2) / (getMod(v1) * getMod(v2))) * 180 / Math.PI;
}
export function getAngle(v1, v2) {
  // if(v2[0] < 0) {
  //   return calAngle(v1, v2) + 180
  // } else {
  //   return calAngle(v1, v2)
  // }

  if (v2[0] > 0) {
    if (v2[1] > 0) {
      // 1
      return 90 - Math.atan(v2[1] / v2[0]) * 180 / Math.PI;
    } else {
      // 2
      return 90 + Math.atan(-v2[1] / v2[0]) * 180 / Math.PI;
    }
  } else {
    if (v2[1] < 0) {
      // 3
      return 180 + (90 - Math.atan(v2[1] / v2[0]) * 180 / Math.PI);
    } else {
      // 4
      return 270 + Math.atan(v2[1] / -v2[0]) * 180 / Math.PI;
    }
  }
}
export function flow(coords) {
  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  if (!coords || coords.length < 2) {
    return;
  }
  var originVec2 = [0, 1];
  var totalDis = 0;
  var path = [];
  for (var i = 0; i < coords.length - 1; i++) {
    var p1 = coords[i];
    var p2 = coords[i + 1];
    var dis = calDistance(p1, p2);
    totalDis += dis;
    var direct = [p1[0] - p2[0], p1[1] - p2[1]];
    // const direct: Point = [p2[0] - p1[0], p2[1] - p1[1]];

    var rotation = getAngle(originVec2, direct);
    if (i > 0) {
      var lastRotation = path[i - 1].rotation;
      if (lastRotation - rotation > 360 - lastRotation + rotation) {
        rotation = rotation + 360;
      }
    }
    path.push({
      start: p1,
      end: p2,
      dis: dis,
      rotation: rotation,
      duration: 0
    });
  }
  path.map(function (point) {
    point.duration = time * (point.dis / totalDis);
  });
  return path;
}
export function calculateCentroid(coord) {
  // let pos = coord as Position;
  if (isNumber(coord[0])) {
    return coord;
    // @ts-ignore
  } else if (isNumber(coord[0][0])) {
    throw new Error('当前数据不支持标注');
    // @ts-ignore
  } else if (isNumber(coord[0][0][0])) {
    var coords = coord;
    var xSum = 0;
    var ySum = 0;
    var len = 0;
    coords.forEach(function (coor) {
      coor.forEach(function (pos) {
        xSum += pos[0];
        ySum += pos[1];
        len++;
      });
    });
    return [xSum / len, ySum / len, 0];
  } else {
    throw new Error('当前数据不支持标注');
  }
}

/**
 * 计算
 * @param points
 * @returns
 */
export function calculatePointsCenterAndRadius(points) {
  var maxX = points[0];
  var maxY = points[1];
  var minX = points[0];
  var minY = points[1];
  var xCount = 0;
  var yCount = 0;
  var pCount = 0;
  for (var i = 0; i < points.length; i += 2) {
    var x = points[i];
    var y = points[i + 1];
    if (x && y) {
      maxX = Math.max(x, maxX);
      maxY = Math.max(y, maxY);
      minX = Math.min(x, minX);
      minY = Math.min(y, minY);
      xCount += x;
      yCount += y;
      pCount++;
    }
  }
  return {
    center: [xCount / pCount, yCount / pCount],
    radius: Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2)) / 2
  };
}

/**
 * 获取经纬度点集对应的 bbox
 * @param pointList
 */
export function getBBoxFromPoints(pointList) {
  return bbox(featureCollection([lineString(pointList)]));
}