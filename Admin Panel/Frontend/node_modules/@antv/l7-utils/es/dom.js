import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { pull } from 'lodash';
import { $window } from "./mini-adapter";
export function getContainer(domId) {
  var $dom = domId;
  if (typeof domId === 'string') {
    $dom = $window.document.getElementById(domId);
  }
  return $dom;
}
export function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
export function splitWords(str) {
  return trim(str).split(/\s+/);
}
function testProp(props) {
  var _$window$document, _$window$document$doc;
  var docStyle = $window === null || $window === void 0 ? void 0 : (_$window$document = $window.document) === null || _$window$document === void 0 ? void 0 : (_$window$document$doc = _$window$document.documentElement) === null || _$window$document$doc === void 0 ? void 0 : _$window$document$doc.style;
  if (!docStyle) {
    return props[0];
  }
  for (var i in props) {
    if (props[i] && props[i] in docStyle) {
      return props[i];
    }
  }
  return props[0];
}
export function create(tagName, className, container) {
  var el = $window.document.createElement(tagName);
  if (className) {
    el.className = className || '';
  }
  if (container) {
    container.appendChild(el);
  }
  return el;
}
// @function remove(el: HTMLElement)
// Removes `el` from its parent element
export function remove(el) {
  var parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
export function addClass(el, name) {
  if (el.classList !== undefined) {
    var classes = splitWords(name);
    for (var i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    var className = getClass(el);
    setClass(el, (className ? className + ' ' : '') + name);
  }
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
export function removeClass(el, name) {
  if (el.classList !== undefined) {
    var classes = splitWords(name);
    classes.forEach(function (className) {
      el.classList.remove(className);
    });
  } else {
    setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
  }
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
export function hasClass(el, name) {
  if (el.classList !== undefined) {
    return el.classList.contains(name);
  }
  var className = getClass(el);
  return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
export function setClass(el, name) {
  if (el instanceof HTMLElement) {
    el.className = name;
  } else {
    // in case of SVG element
    el.className.baseVal = name;
  }
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
export function getClass(el) {
  // Check if the element is an SVGElementInstance and use the correspondingElement instead
  // (Required for linked SVG elements in IE11.)
  if (el instanceof SVGElement) {
    // @ts-ignore
    el = el.correspondingElement;
  }
  return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}
export function empty(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var transformProp = testProp(['transform', 'WebkitTransform']);
export function setTransform(el, value) {
  // @ts-ignore
  el.style[transformProp] = value;
}
export function triggerResize() {
  if (typeof Event === 'function') {
    // modern browsers
    $window.dispatchEvent(new Event('resize'));
  } else {
    // for IE and other old browsers
    // causes deprecation warning on modern browsers
    var evt = $window.document.createEvent('UIEvents');
    // @ts-ignore
    evt.initUIEvent('resize', true, false, $window, 0);
    $window.dispatchEvent(evt);
  }
}
export function printCanvas(canvas) {
  var css = ['padding: ' + (canvas.height / 2 - 8) + 'px ' + canvas.width / 2 + 'px;', 'line-height: ' + canvas.height + 'px;', 'background-image: url(' + canvas.toDataURL() + ');'];
  // tslint:disable-next-line:no-console
  console.log('%c\n', css.join(''));
}
export function getViewPortScale() {
  var _content;
  var meta = $window.document.querySelector('meta[name="viewport"]');
  if (!meta) {
    return 1;
  }
  var contentItems = (_content = meta.content) === null || _content === void 0 ? void 0 : _content.split(',');
  var scale = contentItems.find(function (item) {
    var _item$split = item.split('='),
      _item$split2 = _slicedToArray(_item$split, 1),
      key = _item$split2[0];
    return key === 'initial-scale';
  });
  return scale ? scale.split('=')[1] * 1 : 1;
}
export var DPR = getViewPortScale() < 1 ? 1 : $window.devicePixelRatio;
export function addStyle(el, style) {
  el.setAttribute('style', "".concat(el.style.cssText).concat(style));
}
export function getStyleList(style) {
  return style.split(';').map(function (item) {
    return item.trim();
  }).filter(function (item) {
    return item;
  });
}
export function removeStyle(el, style) {
  var _el$getAttribute;
  var oldStyleList = getStyleList((_el$getAttribute = el.getAttribute('style')) !== null && _el$getAttribute !== void 0 ? _el$getAttribute : '');
  var targetStyleList = getStyleList(style);
  var newStyleList = pull.apply(void 0, [oldStyleList].concat(_toConsumableArray(targetStyleList)));
  el.setAttribute('style', newStyleList.join(';'));
}
export function css2Style(obj) {
  return Object.entries(obj).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    return "".concat(key, ": ").concat(value);
  }).join(';');
}
export function getDiffRect(dom1Rect, dom2Rect) {
  return {
    left: dom1Rect.left - dom2Rect.left,
    top: dom1Rect.top - dom2Rect.top,
    right: dom2Rect.left + dom2Rect.width - dom1Rect.left - dom1Rect.width,
    bottom: dom2Rect.top + dom2Rect.height - dom1Rect.top - dom1Rect.height
  };
}
export function setChecked(el, value) {
  // @ts-ignore
  el.checked = value;
  if (value) {
    el.setAttribute('checked', 'true');
  } else {
    el.removeAttribute('checked');
  }
}
export function clearChildren(el) {
  el.innerHTML = '';
}
export function setUnDraggable(el) {
  el.setAttribute('draggable', 'false');
}
export function appendElementType(container, children) {
  if (typeof children === 'string') {
    var div = document.createElement('div');
    div.innerHTML = children;
    while (div.firstChild) {
      container.append(div.firstChild);
    }
  } else if (Array.isArray(children)) {
    container.append.apply(container, _toConsumableArray(children));
  } else {
    container.append(children);
  }
}