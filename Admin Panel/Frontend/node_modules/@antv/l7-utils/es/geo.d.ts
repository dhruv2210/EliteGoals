import { BBox, Units } from '@turf/helpers';
export type IBounds = [[number, number], [number, number]];
interface ILngLat {
    lng: number;
    lat: number;
}
type Point = number[];
export declare function lngLatInExtent(lngLat: ILngLat, bounds: number[]): boolean;
/**
 * 计算地理数据范围
 * @param {dataArray} data 地理坐标数据
 * @return {Array} dataExtent
 */
export declare function extent(data: any[]): BBox;
export declare function tranfrormCoord(data: any[], cb: (item: any[]) => any): any;
export declare function lngLatToMeters(lnglat: Point): Point;
export declare function metersToLngLat(meters: Point, decimal?: number): number[];
export declare function longitude(lng: number): number;
export declare function latitude(lat: number): number;
export declare function validateLngLat(lnglat: Point, validate: boolean): Point;
export declare function aProjectFlat(lnglat: number[]): number[];
export declare function unProjectFlat(px: number[]): [number, number];
export declare function amap2Project(lng: number, lat: number): [number, number];
export declare function amap2UnProject(x: number, y: number): [number, number];
export declare function lnglatDistance(coordinates1: [number, number], coordinates2: [number, number], units?: Units): number;
export declare function project(lnglat: [number, number]): number[];
export declare function padBounds(b: IBounds, bufferRatio: number): IBounds;
/**
 * b1 包含 b2 返回 true 否则false
 * @param b1 bounds1
 * @param b2 bounds2
 */
export declare function boundsContains(b1: IBounds, b2: IBounds): boolean;
/**
 * bbox转换为Bounds
 * @param b1 bbox
 *
 */
export declare function bBoxToBounds(b1: BBox): IBounds;
export declare function normalize(v: Point): number[];
export declare function calDistance(p1: Point, p2: Point): number;
export declare function calAngle(v1: Point, v2: Point): number;
export declare function getAngle(v1: Point, v2: Point): number;
interface IPathPoint {
    start: Point;
    end: Point;
    dis: number;
    rotation: number;
    duration: number;
}
export declare function flow(coords: Point[], time?: number): IPathPoint[] | undefined;
type Position = number[];
export declare function calculateCentroid(coord: Position | Position[] | Position[][]): Position;
/**
 * 计算
 * @param points
 * @returns
 */
export declare function calculatePointsCenterAndRadius(points: number[]): {
    center: number[];
    radius: number;
};
/**
 * 获取经纬度点集对应的 bbox
 * @param pointList
 */
export declare function getBBoxFromPoints(pointList: Position[]): BBox;
export {};
