import { degreesToRadians, radiansToDegrees } from '@turf/helpers';
import { calDistance } from "../geo";
// arc
export function greatCircleLineAtOffset(source, target, offset, thetaOffset, mapVersion) {
  var segmentNumber = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 30;
  var autoFit = arguments.length > 6 ? arguments[6] : undefined;
  var pointOffset = offset;
  if (autoFit) {
    // Tip: 自动偏移到线的节点位置
    // greatcircle 暂时不支持配置 segmentNumber 和 thetaOffset
    pointOffset = Math.round(offset * 29) / 29;
  }
  return interpolate(source, target, pointOffset, mapVersion);
}
function midPoint(source, target) {
  var center = [target[0] - source[0], target[1] - source[1]]; // target - source;
  var r = calDistance(center, [0, 0]);
  var theta = Math.atan2(center[1], center[0]);
  var thetaOffset = 0.314;
  var r2 = r / 2.0 / Math.cos(thetaOffset);
  var theta2 = theta + thetaOffset;
  var mid = [r2 * Math.cos(theta2) + source[0], r2 * Math.sin(theta2) + source[1]];
  return mid;
}
function bezier3(arr, t) {
  var ut = 1 - t;
  return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t;
}
function getAngularDist(source, target) {
  var delta = [source[0] - target[0], source[1] - target[1]];
  var sinHalfDelta = [Math.sin(delta[0] / 2.0), Math.sin(delta[1] / 2.0)]; // Math.sin(delta / 2.0);
  var a = sinHalfDelta[1] * sinHalfDelta[1] + Math.cos(source[1]) * Math.cos(target[1]) * sinHalfDelta[0] * sinHalfDelta[0];
  return 2.0 * Math.atan2(Math.sqrt(a), Math.sqrt(1.0 - a));
}
export function interpolate(s, t, offset, mapVersion) {
  var source = [degreesToRadians(s[0]), degreesToRadians(s[1])];
  var target = [degreesToRadians(t[0]), degreesToRadians(t[1])];
  if (mapVersion === 'GAODE2.x') {
    // gaode2.x
    var mid = midPoint(source, target);
    var x = [source[0], mid[0], target[0]];
    var y = [source[1], mid[1], target[1]];
    return [bezier3(x, offset), bezier3(y, offset), 0];
  } else {
    var angularDist = getAngularDist(source, target);
    if (Math.abs(angularDist - Math.PI) < 0.001) {
      return [(1.0 - offset) * source[0] + offset * target[0], (1.0 - offset) * source[1] + offset * target[1]];
    }
    var a = Math.sin((1.0 - offset) * angularDist) / Math.sin(angularDist);
    var b = Math.sin(offset * angularDist) / Math.sin(angularDist);
    var sinSource = [Math.sin(source[0]), Math.sin(source[1])];
    var cosSource = [Math.cos(source[0]), Math.cos(source[1])];
    var sinTarget = [Math.sin(target[0]), Math.sin(target[1])];
    var cosTarget = [Math.cos(target[0]), Math.cos(target[1])];
    var _x = a * cosSource[1] * cosSource[0] + b * cosTarget[1] * cosTarget[0];
    var _y = a * cosSource[1] * sinSource[0] + b * cosTarget[1] * sinTarget[0];
    var z = a * sinSource[1] + b * sinTarget[1];
    return [radiansToDegrees(Math.atan2(_y, _x)), radiansToDegrees(Math.atan2(z, Math.sqrt(_x * _x + _y * _y)))];
  }
}