var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/geo.ts
var geo_exports = {};
__export(geo_exports, {
  aProjectFlat: () => aProjectFlat,
  amap2Project: () => amap2Project,
  amap2UnProject: () => amap2UnProject,
  bBoxToBounds: () => bBoxToBounds,
  boundsContains: () => boundsContains,
  calAngle: () => calAngle,
  calDistance: () => calDistance,
  calculateCentroid: () => calculateCentroid,
  calculatePointsCenterAndRadius: () => calculatePointsCenterAndRadius,
  extent: () => extent,
  flow: () => flow,
  getAngle: () => getAngle,
  getBBoxFromPoints: () => getBBoxFromPoints,
  latitude: () => latitude,
  lngLatInExtent: () => lngLatInExtent,
  lngLatToMeters: () => lngLatToMeters,
  lnglatDistance: () => lnglatDistance,
  longitude: () => longitude,
  metersToLngLat: () => metersToLngLat,
  normalize: () => normalize,
  padBounds: () => padBounds,
  project: () => project,
  tranfrormCoord: () => tranfrormCoord,
  unProjectFlat: () => unProjectFlat,
  validateLngLat: () => validateLngLat
});
module.exports = __toCommonJS(geo_exports);
var import_bbox = __toESM(require("@turf/bbox"));
var import_helpers = require("@turf/helpers");
var import_math = require("./math");
var originShift = 2 * Math.PI * 6378137 / 2;
function lngLatInExtent(lngLat, bounds) {
  const [minLng, minLat, maxLng, maxLat] = bounds;
  return lngLat.lng > minLng && lngLat.lng <= maxLng && lngLat.lat > minLat && lngLat.lat <= maxLat;
}
function extent(data) {
  const dataExtent = [Infinity, Infinity, -Infinity, -Infinity];
  data.forEach((item) => {
    const { coordinates } = item;
    caculExtent(dataExtent, coordinates);
  });
  return dataExtent;
}
function caculExtent(dataExtent, coords) {
  if (Array.isArray(coords[0])) {
    coords.forEach((coord) => {
      caculExtent(dataExtent, coord);
    });
  } else {
    if (dataExtent[0] > coords[0]) {
      dataExtent[0] = coords[0];
    }
    if (dataExtent[1] > coords[1]) {
      dataExtent[1] = coords[1];
    }
    if (dataExtent[2] < coords[0]) {
      dataExtent[2] = coords[0];
    }
    if (dataExtent[3] < coords[1]) {
      dataExtent[3] = coords[1];
    }
  }
  return dataExtent;
}
function tranfrormCoord(data, cb) {
  return transform(data, cb);
}
function transform(item, cb) {
  if (Array.isArray(item[0])) {
    return item.map((coord) => {
      return transform(coord, cb);
    });
  }
  return cb(item);
}
function lngLatToMeters(lnglat, validate = true, accuracy = { enable: true, decimal: 1 }) {
  lnglat = validateLngLat(lnglat, validate);
  const lng = lnglat[0];
  const lat = lnglat[1];
  let x = lng * originShift / 180;
  let y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
  y = y * originShift / 180;
  if (accuracy.enable) {
    x = Number(x.toFixed(accuracy.decimal));
    y = Number(y.toFixed(accuracy.decimal));
  }
  return lnglat.length === 3 ? [x, y, lnglat[2]] : [x, y];
}
function metersToLngLat(meters, decimal = 6) {
  const x = meters[0];
  const y = meters[1];
  let lng = x / originShift * 180;
  let lat = y / originShift * 180;
  lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);
  if (decimal !== void 0 && decimal !== null) {
    lng = Number(lng.toFixed(decimal));
    lat = Number(lat.toFixed(decimal));
  }
  return meters.length === 3 ? [lng, lat, meters[2]] : [lng, lat];
}
function longitude(lng) {
  if (lng === void 0 || lng === null) {
    throw new Error("lng is required");
  }
  if (lng > 180 || lng < -180) {
    lng = lng % 360;
    if (lng > 180) {
      lng = -360 + lng;
    }
    if (lng < -180) {
      lng = 360 + lng;
    }
    if (lng === 0) {
      lng = 0;
    }
  }
  return lng;
}
function latitude(lat) {
  if (lat === void 0 || lat === null) {
    throw new Error("lat is required");
  }
  if (lat > 90 || lat < -90) {
    lat = lat % 180;
    if (lat > 90) {
      lat = -180 + lat;
    }
    if (lat < -90) {
      lat = 180 + lat;
    }
    if (lat === 0) {
      lat = 0;
    }
  }
  return lat;
}
function validateLngLat(lnglat, validate) {
  if (validate === false) {
    return lnglat;
  }
  const lng = longitude(lnglat[0]);
  let lat = latitude(lnglat[1]);
  if (lat > 85) {
    lat = 85;
  }
  if (lat < -85) {
    lat = -85;
  }
  return lnglat.length === 3 ? [lng, lat, lnglat[2]] : [lng, lat];
}
function aProjectFlat(lnglat) {
  const maxs = 85.0511287798;
  const lat = Math.max(Math.min(maxs, lnglat[1]), -maxs);
  const scale = 256 << 20;
  let d = Math.PI / 180;
  let x = lnglat[0] * d;
  let y = lat * d;
  y = Math.log(Math.tan(Math.PI / 4 + y / 2));
  const a = 0.5 / Math.PI;
  const b = 0.5;
  const c = -0.5 / Math.PI;
  d = 0.5;
  x = scale * (a * x + b);
  y = scale * (c * y + d);
  return [Math.floor(x), Math.floor(y)];
}
function unProjectFlat(px) {
  const a = 0.5 / Math.PI;
  const b = 0.5;
  const c = -0.5 / Math.PI;
  let d = 0.5;
  const scale = 256 << 20;
  let [x, y] = px;
  x = (x / scale - b) / a;
  y = (y / scale - d) / c;
  y = (Math.atan(Math.pow(Math.E, y)) - Math.PI / 4) * 2;
  d = Math.PI / 180;
  const lat = y / d;
  const lng = x / d;
  return [lng, lat];
}
function amap2Project(lng, lat) {
  const r = 85.0511287798;
  const Rg = Math.PI / 180;
  const Tg = 6378137;
  lat = Math.max(Math.min(r, lat), -r);
  lng *= Rg;
  lat *= Rg;
  lat = Math.log(Math.tan(Math.PI / 4 + lat / 2));
  return [lng * Tg, lat * Tg];
}
function amap2UnProject(x, y) {
  const Rg = Math.PI / 180;
  const Tg = 6378137;
  const lng = x / Tg / Rg;
  const lat = 2 * (Math.atan(Math.exp(y / Tg)) - Math.PI / 4) / Rg;
  return [lng, lat];
}
function lnglatDistance(coordinates1, coordinates2, units) {
  const dLat = (0, import_helpers.degreesToRadians)(coordinates2[1] - coordinates1[1]);
  const dLon = (0, import_helpers.degreesToRadians)(coordinates2[0] - coordinates1[0]);
  const lat1 = (0, import_helpers.degreesToRadians)(coordinates1[1]);
  const lat2 = (0, import_helpers.degreesToRadians)(coordinates2[1]);
  const a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return (0, import_helpers.radiansToLength)(
    2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    units = "meters"
  );
}
function project(lnglat) {
  const d = Math.PI / 180;
  const max = 85.0511287798;
  const earthRadius = 6378137;
  const lat = Math.max(Math.min(max, lnglat[1]), -max);
  const sin = Math.sin(lat * d);
  const x = earthRadius * lnglat[0] * d;
  const y = earthRadius * Math.log((1 + sin) / (1 - sin)) / 2;
  return [x, y];
}
function padBounds(b, bufferRatio) {
  const heightBuffer = Math.abs(b[1][1] - b[0][1]) * bufferRatio;
  const widthBuffer = Math.abs(b[1][0] - b[0][0]) * bufferRatio;
  return [
    [b[0][0] - widthBuffer, b[0][1] - heightBuffer],
    [b[1][0] + widthBuffer, b[1][1] + heightBuffer]
  ];
}
function boundsContains(b1, b2) {
  return b1[0][0] <= b2[0][0] && b1[0][1] <= b2[0][1] && b1[1][0] >= b2[1][0] && b1[1][1] >= b2[1][1];
}
function bBoxToBounds(b1) {
  return [
    [b1[0], b1[1]],
    [b1[2], b1[3]]
  ];
}
function normalize(v) {
  const len = calDistance(v, [0, 0]);
  return [v[0] / len, v[1] / len];
}
function calDistance(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}
function dotMul(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function getMod(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function calAngle(v1, v2) {
  return Math.acos(dotMul(v1, v2) / (getMod(v1) * getMod(v2))) * 180 / Math.PI;
}
function getAngle(v1, v2) {
  if (v2[0] > 0) {
    if (v2[1] > 0) {
      return 90 - Math.atan(v2[1] / v2[0]) * 180 / Math.PI;
    } else {
      return 90 + Math.atan(-v2[1] / v2[0]) * 180 / Math.PI;
    }
  } else {
    if (v2[1] < 0) {
      return 180 + (90 - Math.atan(v2[1] / v2[0]) * 180 / Math.PI);
    } else {
      return 270 + Math.atan(v2[1] / -v2[0]) * 180 / Math.PI;
    }
  }
}
function flow(coords, time = 100) {
  if (!coords || coords.length < 2) {
    return;
  }
  const originVec2 = [0, 1];
  let totalDis = 0;
  const path = [];
  for (let i = 0; i < coords.length - 1; i++) {
    const p1 = coords[i];
    const p2 = coords[i + 1];
    const dis = calDistance(p1, p2);
    totalDis += dis;
    const direct = [p1[0] - p2[0], p1[1] - p2[1]];
    let rotation = getAngle(originVec2, direct);
    if (i > 0) {
      const lastRotation = path[i - 1].rotation;
      if (lastRotation - rotation > 360 - lastRotation + rotation) {
        rotation = rotation + 360;
      }
    }
    path.push({
      start: p1,
      end: p2,
      dis,
      rotation,
      duration: 0
    });
  }
  path.map((point) => {
    point.duration = time * (point.dis / totalDis);
  });
  return path;
}
function calculateCentroid(coord) {
  if ((0, import_math.isNumber)(coord[0])) {
    return coord;
  } else if ((0, import_math.isNumber)(coord[0][0])) {
    throw new Error("当前数据不支持标注");
  } else if ((0, import_math.isNumber)(coord[0][0][0])) {
    const coords = coord;
    let xSum = 0;
    let ySum = 0;
    let len = 0;
    coords.forEach((coor) => {
      coor.forEach((pos) => {
        xSum += pos[0];
        ySum += pos[1];
        len++;
      });
    });
    return [xSum / len, ySum / len, 0];
  } else {
    throw new Error("当前数据不支持标注");
  }
}
function calculatePointsCenterAndRadius(points) {
  let maxX = points[0];
  let maxY = points[1];
  let minX = points[0];
  let minY = points[1];
  let xCount = 0;
  let yCount = 0;
  let pCount = 0;
  for (let i = 0; i < points.length; i += 2) {
    const x = points[i];
    const y = points[i + 1];
    if (x && y) {
      maxX = Math.max(x, maxX);
      maxY = Math.max(y, maxY);
      minX = Math.min(x, minX);
      minY = Math.min(y, minY);
      xCount += x;
      yCount += y;
      pCount++;
    }
  }
  return {
    center: [xCount / pCount, yCount / pCount],
    radius: Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2)) / 2
  };
}
function getBBoxFromPoints(pointList) {
  return (0, import_bbox.default)((0, import_helpers.featureCollection)([(0, import_helpers.lineString)(pointList)]));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  aProjectFlat,
  amap2Project,
  amap2UnProject,
  bBoxToBounds,
  boundsContains,
  calAngle,
  calDistance,
  calculateCentroid,
  calculatePointsCenterAndRadius,
  extent,
  flow,
  getAngle,
  getBBoxFromPoints,
  latitude,
  lngLatInExtent,
  lngLatToMeters,
  lnglatDistance,
  longitude,
  metersToLngLat,
  normalize,
  padBounds,
  project,
  tranfrormCoord,
  unProjectFlat,
  validateLngLat
});
