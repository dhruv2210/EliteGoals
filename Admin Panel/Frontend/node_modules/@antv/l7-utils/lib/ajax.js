var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ajax.ts
var ajax_exports = {};
__export(ajax_exports, {
  AJAXError: () => AJAXError,
  formatImage: () => formatImage,
  getArrayBuffer: () => getArrayBuffer,
  getImage: () => getImage,
  getJSON: () => getJSON,
  makeXMLHttpRequestPromise: () => makeXMLHttpRequestPromise,
  postData: () => postData,
  sameOrigin: () => sameOrigin
});
module.exports = __toCommonJS(ajax_exports);
var import_mini_adapter = require("./mini-adapter");
var AJAXError = class extends Error {
  constructor(status, statusText, url, body) {
    super(`AJAXError: ${statusText} (${status}): ${url}`);
    this.status = status;
    this.statusText = statusText;
    this.url = url;
    this.body = body;
  }
};
function makeXMLHttpRequest(requestParameters, callback) {
  const xhr = new import_mini_adapter.$XMLHttpRequest();
  const url = Array.isArray(requestParameters.url) ? requestParameters.url[0] : requestParameters.url;
  xhr.open(requestParameters.method || "GET", url, true);
  if (requestParameters.type === "arrayBuffer") {
    xhr.responseType = "arraybuffer";
  }
  for (const k in requestParameters.headers) {
    if (requestParameters.headers.hasOwnProperty(k)) {
      xhr.setRequestHeader(k, requestParameters.headers[k]);
    }
  }
  if (requestParameters.type === "json") {
    xhr.responseType = "text";
    xhr.setRequestHeader("Accept", "application/json");
  }
  xhr.withCredentials = requestParameters.credentials === "include";
  xhr.onerror = () => {
    callback(new Error(xhr.statusText));
  };
  xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) && xhr.response !== null) {
      let data = xhr.response;
      if (requestParameters.type === "json") {
        try {
          data = JSON.parse(xhr.response);
        } catch (err) {
          return callback(err);
        }
      }
      callback(
        null,
        data,
        xhr.getResponseHeader("Cache-Control"),
        xhr.getResponseHeader("Expires"),
        xhr
      );
    } else {
      const body = new Blob([xhr.response], {
        type: xhr.getResponseHeader("Content-Type")
      });
      callback(new AJAXError(xhr.status, xhr.statusText, url.toString(), body));
    }
  };
  xhr.send(requestParameters.body);
  return xhr;
}
function makeXMLHttpRequestPromise(requestParameters) {
  return new Promise((resolve, reject) => {
    makeXMLHttpRequest(
      requestParameters,
      (error, data, cacheControl, expires, xhr) => {
        if (error) {
          reject({
            err: error,
            data: null,
            xhr
          });
        } else {
          resolve({
            err: null,
            data,
            cacheControl,
            expires,
            xhr
          });
        }
      }
    );
  });
}
function makeRequest(requestParameters, callback) {
  return makeXMLHttpRequest(requestParameters, callback);
}
var getJSON = (requestParameters, callback) => {
  return makeRequest({ ...requestParameters, type: "json" }, callback);
};
var getArrayBuffer = (requestParameters, callback) => {
  return makeRequest({ ...requestParameters, type: "arrayBuffer" }, callback);
};
var postData = (requestParameters, callback) => {
  return makeRequest({ ...requestParameters, method: "POST" }, callback);
};
function sameOrigin(url) {
  const a = import_mini_adapter.$window.document.createElement("a");
  a.href = url;
  return a.protocol === import_mini_adapter.$window.document.location.protocol && a.host === import_mini_adapter.$window.document.location.host;
}
var transparentPngUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
function arrayBufferToImage(data, callback) {
  const img = new import_mini_adapter.$window.Image();
  const URL = import_mini_adapter.$window.URL || import_mini_adapter.$window.webkitURL;
  img.crossOrigin = "anonymous";
  img.onload = () => {
    callback(null, img);
    URL.revokeObjectURL(img.src);
    img.onload = null;
    window.requestAnimationFrame(() => {
      img.src = transparentPngUrl;
    });
  };
  img.onerror = () => callback(
    new Error(
      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."
    )
  );
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  img.src = data.byteLength ? URL.createObjectURL(blob) : transparentPngUrl;
}
function arrayBufferToImageBitmap(data, callback) {
  const blob = new Blob([new Uint8Array(data)], { type: "image/png" });
  createImageBitmap(blob).then((imgBitmap) => {
    callback(null, imgBitmap);
  }).catch((e) => {
    callback(
      new Error(
        `Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`
      )
    );
  });
}
var getImage = (requestParameters, callback, transformResponse) => {
  const optionFunc = (err, imgData) => {
    if (err) {
      callback(err);
    } else if (imgData) {
      const imageBitmapSupported = typeof createImageBitmap === "function";
      const transformImgData = transformResponse ? transformResponse(imgData) : imgData;
      if (imageBitmapSupported) {
        arrayBufferToImageBitmap(transformImgData, callback);
      } else {
        arrayBufferToImage(transformImgData, callback);
      }
    }
  };
  if (requestParameters.type === "json") {
    return getJSON(requestParameters, optionFunc);
  } else {
    return getArrayBuffer(requestParameters, optionFunc);
  }
};
var formatImage = (imgData, callback) => {
  const imageBitmapSupported = typeof createImageBitmap === "function";
  if (imageBitmapSupported) {
    arrayBufferToImageBitmap(imgData, callback);
  } else {
    arrayBufferToImage(imgData, callback);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AJAXError,
  formatImage,
  getArrayBuffer,
  getImage,
  getJSON,
  makeXMLHttpRequestPromise,
  postData,
  sameOrigin
});
