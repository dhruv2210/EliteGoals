var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lineAtOffset/greatCircle.ts
var greatCircle_exports = {};
__export(greatCircle_exports, {
  greatCircleLineAtOffset: () => greatCircleLineAtOffset,
  interpolate: () => interpolate
});
module.exports = __toCommonJS(greatCircle_exports);
var import_helpers = require("@turf/helpers");
var import_geo = require("../geo");
function greatCircleLineAtOffset(source, target, offset, thetaOffset, mapVersion, segmentNumber = 30, autoFit) {
  let pointOffset = offset;
  if (autoFit) {
    pointOffset = Math.round(offset * 29) / 29;
  }
  return interpolate(source, target, pointOffset, mapVersion);
}
function midPoint(source, target) {
  const center = [target[0] - source[0], target[1] - source[1]];
  const r = (0, import_geo.calDistance)(center, [0, 0]);
  const theta = Math.atan2(center[1], center[0]);
  const thetaOffset = 0.314;
  const r2 = r / 2 / Math.cos(thetaOffset);
  const theta2 = theta + thetaOffset;
  const mid = [
    r2 * Math.cos(theta2) + source[0],
    r2 * Math.sin(theta2) + source[1]
  ];
  return mid;
}
function bezier3(arr, t) {
  const ut = 1 - t;
  return (arr[0] * ut + arr[1] * t) * ut + (arr[1] * ut + arr[2] * t) * t;
}
function getAngularDist(source, target) {
  const delta = [source[0] - target[0], source[1] - target[1]];
  const sinHalfDelta = [Math.sin(delta[0] / 2), Math.sin(delta[1] / 2)];
  const a = sinHalfDelta[1] * sinHalfDelta[1] + Math.cos(source[1]) * Math.cos(target[1]) * sinHalfDelta[0] * sinHalfDelta[0];
  return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function interpolate(s, t, offset, mapVersion) {
  const source = [(0, import_helpers.degreesToRadians)(s[0]), (0, import_helpers.degreesToRadians)(s[1])];
  const target = [(0, import_helpers.degreesToRadians)(t[0]), (0, import_helpers.degreesToRadians)(t[1])];
  if (mapVersion === "GAODE2.x") {
    const mid = midPoint(source, target);
    const x = [source[0], mid[0], target[0]];
    const y = [source[1], mid[1], target[1]];
    return [bezier3(x, offset), bezier3(y, offset), 0];
  } else {
    const angularDist = getAngularDist(source, target);
    if (Math.abs(angularDist - Math.PI) < 1e-3) {
      return [
        (1 - offset) * source[0] + offset * target[0],
        (1 - offset) * source[1] + offset * target[1]
      ];
    }
    const a = Math.sin((1 - offset) * angularDist) / Math.sin(angularDist);
    const b = Math.sin(offset * angularDist) / Math.sin(angularDist);
    const sinSource = [Math.sin(source[0]), Math.sin(source[1])];
    const cosSource = [Math.cos(source[0]), Math.cos(source[1])];
    const sinTarget = [Math.sin(target[0]), Math.sin(target[1])];
    const cosTarget = [Math.cos(target[0]), Math.cos(target[1])];
    const x = a * cosSource[1] * cosSource[0] + b * cosTarget[1] * cosTarget[0];
    const y = a * cosSource[1] * sinSource[0] + b * cosTarget[1] * sinTarget[0];
    const z = a * sinSource[1] + b * sinTarget[1];
    return [
      (0, import_helpers.radiansToDegrees)(Math.atan2(y, x)),
      (0, import_helpers.radiansToDegrees)(Math.atan2(z, Math.sqrt(x * x + y * y)))
    ];
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  greatCircleLineAtOffset,
  interpolate
});
