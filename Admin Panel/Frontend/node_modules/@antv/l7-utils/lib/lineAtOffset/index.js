var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lineAtOffset/index.ts
var lineAtOffset_exports = {};
__export(lineAtOffset_exports, {
  lineAtOffset: () => lineAtOffset,
  lineAtOffsetAsyc: () => lineAtOffsetAsyc
});
module.exports = __toCommonJS(lineAtOffset_exports);
var import_arc = require("./arc");
var import_greatCircle = require("./greatCircle");
var import_line = require("./line");
function lineAtOffset(source, option) {
  const { featureId } = option;
  let features = source.data.dataArray;
  if (typeof featureId === "number") {
    features = features.filter(({ id }) => id === featureId);
  }
  return features.map((feature) => {
    const position = getLineOffsetPosition(feature, option);
    return {
      ...feature,
      ...position
    };
  });
}
function lineAtOffsetAsyc(source, option) {
  return new Promise((resolve) => {
    if (source.inited) {
      resolve(lineAtOffset(source, option));
    } else {
      source.once("update", () => {
        resolve(lineAtOffset(source, option));
      });
    }
  });
}
function getLineOffsetPosition(feature, option) {
  const {
    offset,
    shape,
    thetaOffset,
    mapVersion,
    segmentNumber = 30,
    autoFit = true
  } = option;
  const { coordinates } = feature;
  if (shape === "line") {
    return (0, import_line.pathLineAtOffset)(coordinates, offset);
  }
  const source = coordinates[0];
  const target = coordinates[1];
  const linetheatOffset = typeof thetaOffset === "string" ? feature[thetaOffset] || 0 : thetaOffset;
  let calFunc;
  switch (shape) {
    case "arc":
      calFunc = import_arc.arcLineAtOffset;
      break;
    case "greatcircle":
      calFunc = import_greatCircle.greatCircleLineAtOffset;
      break;
    default:
      calFunc = import_arc.arcLineAtOffset;
  }
  const [lng, lat, height] = calFunc(
    source,
    target,
    offset,
    linetheatOffset,
    mapVersion,
    segmentNumber,
    autoFit
  );
  return {
    lng,
    lat,
    height
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  lineAtOffset,
  lineAtOffsetAsyc
});
