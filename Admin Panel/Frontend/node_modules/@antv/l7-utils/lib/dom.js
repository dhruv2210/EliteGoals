var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/dom.ts
var dom_exports = {};
__export(dom_exports, {
  DPR: () => DPR,
  addClass: () => addClass,
  addStyle: () => addStyle,
  appendElementType: () => appendElementType,
  clearChildren: () => clearChildren,
  create: () => create,
  css2Style: () => css2Style,
  empty: () => empty,
  getClass: () => getClass,
  getContainer: () => getContainer,
  getDiffRect: () => getDiffRect,
  getStyleList: () => getStyleList,
  getViewPortScale: () => getViewPortScale,
  hasClass: () => hasClass,
  printCanvas: () => printCanvas,
  remove: () => remove,
  removeClass: () => removeClass,
  removeStyle: () => removeStyle,
  setChecked: () => setChecked,
  setClass: () => setClass,
  setTransform: () => setTransform,
  setUnDraggable: () => setUnDraggable,
  splitWords: () => splitWords,
  triggerResize: () => triggerResize,
  trim: () => trim
});
module.exports = __toCommonJS(dom_exports);
var import_lodash = require("lodash");
var import_mini_adapter = require("./mini-adapter");
function getContainer(domId) {
  let $dom = domId;
  if (typeof domId === "string") {
    $dom = import_mini_adapter.$window.document.getElementById(domId);
  }
  return $dom;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function splitWords(str) {
  return trim(str).split(/\s+/);
}
function testProp(props) {
  var _a, _b, _c;
  const docStyle = (_c = (_b = (_a = import_mini_adapter.$window) == null ? void 0 : _a.document) == null ? void 0 : _b.documentElement) == null ? void 0 : _c.style;
  if (!docStyle) {
    return props[0];
  }
  for (const i in props) {
    if (props[i] && props[i] in docStyle) {
      return props[i];
    }
  }
  return props[0];
}
function create(tagName, className, container) {
  const el = import_mini_adapter.$window.document.createElement(tagName);
  if (className) {
    el.className = className || "";
  }
  if (container) {
    container.appendChild(el);
  }
  return el;
}
function remove(el) {
  const parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}
function addClass(el, name) {
  if (el.classList !== void 0) {
    const classes = splitWords(name);
    for (let i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    const className = getClass(el);
    setClass(el, (className ? className + " " : "") + name);
  }
}
function removeClass(el, name) {
  if (el.classList !== void 0) {
    const classes = splitWords(name);
    classes.forEach((className) => {
      el.classList.remove(className);
    });
  } else {
    setClass(
      el,
      trim((" " + getClass(el) + " ").replace(" " + name + " ", " "))
    );
  }
}
function hasClass(el, name) {
  if (el.classList !== void 0) {
    return el.classList.contains(name);
  }
  const className = getClass(el);
  return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
}
function setClass(el, name) {
  if (el instanceof HTMLElement) {
    el.className = name;
  } else {
    el.className.baseVal = name;
  }
}
function getClass(el) {
  if (el instanceof SVGElement) {
    el = el.correspondingElement;
  }
  return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
}
function empty(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
var transformProp = testProp(["transform", "WebkitTransform"]);
function setTransform(el, value) {
  el.style[transformProp] = value;
}
function triggerResize() {
  if (typeof Event === "function") {
    import_mini_adapter.$window.dispatchEvent(new Event("resize"));
  } else {
    const evt = import_mini_adapter.$window.document.createEvent("UIEvents");
    evt.initUIEvent("resize", true, false, import_mini_adapter.$window, 0);
    import_mini_adapter.$window.dispatchEvent(evt);
  }
}
function printCanvas(canvas) {
  const css = [
    "padding: " + (canvas.height / 2 - 8) + "px " + canvas.width / 2 + "px;",
    "line-height: " + canvas.height + "px;",
    "background-image: url(" + canvas.toDataURL() + ");"
  ];
  console.log("%c\n", css.join(""));
}
function getViewPortScale() {
  var _a;
  const meta = import_mini_adapter.$window.document.querySelector('meta[name="viewport"]');
  if (!meta) {
    return 1;
  }
  const contentItems = (_a = meta.content) == null ? void 0 : _a.split(",");
  const scale = contentItems.find((item) => {
    const [key] = item.split("=");
    return key === "initial-scale";
  });
  return scale ? scale.split("=")[1] * 1 : 1;
}
var DPR = getViewPortScale() < 1 ? 1 : import_mini_adapter.$window.devicePixelRatio;
function addStyle(el, style) {
  el.setAttribute("style", `${el.style.cssText}${style}`);
}
function getStyleList(style) {
  return style.split(";").map((item) => item.trim()).filter((item) => item);
}
function removeStyle(el, style) {
  const oldStyleList = getStyleList(el.getAttribute("style") ?? "");
  const targetStyleList = getStyleList(style);
  const newStyleList = (0, import_lodash.pull)(oldStyleList, ...targetStyleList);
  el.setAttribute("style", newStyleList.join(";"));
}
function css2Style(obj) {
  return Object.entries(obj).map(([key, value]) => `${key}: ${value}`).join(";");
}
function getDiffRect(dom1Rect, dom2Rect) {
  return {
    left: dom1Rect.left - dom2Rect.left,
    top: dom1Rect.top - dom2Rect.top,
    right: dom2Rect.left + dom2Rect.width - dom1Rect.left - dom1Rect.width,
    bottom: dom2Rect.top + dom2Rect.height - dom1Rect.top - dom1Rect.height
  };
}
function setChecked(el, value) {
  el.checked = value;
  if (value) {
    el.setAttribute("checked", "true");
  } else {
    el.removeAttribute("checked");
  }
}
function clearChildren(el) {
  el.innerHTML = "";
}
function setUnDraggable(el) {
  el.setAttribute("draggable", "false");
}
function appendElementType(container, children) {
  if (typeof children === "string") {
    const div = document.createElement("div");
    div.innerHTML = children;
    while (div.firstChild) {
      container.append(div.firstChild);
    }
  } else if (Array.isArray(children)) {
    container.append(...children);
  } else {
    container.append(children);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DPR,
  addClass,
  addStyle,
  appendElementType,
  clearChildren,
  create,
  css2Style,
  empty,
  getClass,
  getContainer,
  getDiffRect,
  getStyleList,
  getViewPortScale,
  hasClass,
  printCanvas,
  remove,
  removeClass,
  removeStyle,
  setChecked,
  setClass,
  setTransform,
  setUnDraggable,
  splitWords,
  triggerResize,
  trim
});
