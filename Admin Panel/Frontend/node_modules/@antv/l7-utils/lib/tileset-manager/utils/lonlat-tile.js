var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/tileset-manager/utils/lonlat-tile.ts
var lonlat_tile_exports = {};
__export(lonlat_tile_exports, {
  getTileIndices: () => getTileIndices,
  getTileWarpXY: () => getTileWarpXY,
  osmLonLat2TileXY: () => osmLonLat2TileXY,
  osmTileXY2LonLat: () => osmTileXY2LonLat,
  tileToBounds: () => tileToBounds
});
module.exports = __toCommonJS(lonlat_tile_exports);
var import_const = require("../const");
function osmLonLat2TileXY(lon, lat, zoom) {
  const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
  const y = Math.floor(
    (1 - Math.log(
      Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)
    ) / Math.PI) / 2 * Math.pow(2, zoom)
  );
  return [x, y];
}
function osmTileXY2LonLat(x, y, zoom) {
  const lon = x / Math.pow(2, zoom) * 360 - 180;
  const n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lon, lat];
}
var tileToBounds = (x, y, z) => {
  const [minLng, maxLat] = osmTileXY2LonLat(x, y, z);
  const [maxLng, minLat] = osmTileXY2LonLat(x + 1, y + 1, z);
  return [minLng, minLat, maxLng, maxLat];
};
function getTileIndices({
  zoom,
  latLonBounds,
  maxZoom = Infinity,
  minZoom = 0,
  zoomOffset = 0,
  extent = import_const.DEFAULT_EXTENT
}) {
  let z = Math.ceil(zoom) + zoomOffset;
  if (Number.isFinite(minZoom) && z < minZoom) {
    return [];
  }
  if (Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  const [minLng, minLat, maxLng, maxLat] = latLonBounds;
  const bounds = [
    Math.max(minLng, extent[0]),
    Math.max(minLat, extent[1]),
    Math.min(maxLng, extent[2]),
    Math.min(maxLat, extent[3])
  ];
  const indices = [];
  const [minX, maxY] = osmLonLat2TileXY(bounds[0], bounds[1], z);
  const [maxX, minY] = osmLonLat2TileXY(bounds[2], bounds[3], z);
  for (let x = minX; x <= maxX; x++) {
    for (let y = minY; y <= maxY; y++) {
      indices.push({ x, y, z });
    }
  }
  const centerX = (maxX + minX) / 2;
  const centerY = (maxY + minY) / 2;
  const distance = (x, y) => Math.abs(x - centerX) + Math.abs(y - centerY);
  indices.sort((a, b) => distance(a.x, a.y) - distance(b.x, b.y));
  return indices;
}
var getTileWarpXY = (x, y, z, wrap = true) => {
  const scale = Math.pow(2, z);
  const maxIndex = scale - 1;
  const distance = scale;
  let warpX = x;
  const warpY = y;
  if (wrap) {
    if (warpX < 0) {
      warpX = warpX + distance;
    } else if (warpX > maxIndex) {
      warpX = warpX % distance;
    }
  }
  return { warpX, warpY };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getTileIndices,
  getTileWarpXY,
  osmLonLat2TileXY,
  osmTileXY2LonLat,
  tileToBounds
});
