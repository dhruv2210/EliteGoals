var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/workers/lineModel.ts
var lineModel_exports = {};
__export(lineModel_exports, {
  lineModel: () => lineModel
});
module.exports = __toCommonJS(lineModel_exports);
var import_color = require("../color");
var import_commonFeatureFunc = require("./commonFeatureFunc");
var import_triangulation = require("./triangulation");
var lineModel = async ({
  descriptors,
  features,
  enablePicking,
  iconMap
}) => {
  const updateFuncs = {
    // fixed feature func
    a_Color: import_commonFeatureFunc.a_Color,
    a_Position: import_commonFeatureFunc.a_Position,
    filter: import_commonFeatureFunc.a_filter,
    a_vertexId: import_commonFeatureFunc.a_vertexId,
    a_PickingColor: (feature) => {
      const { id } = feature;
      return enablePicking ? (0, import_color.encodePickingColor)(id) : [0, 0, 0];
    },
    // pointFill feature func
    a_DistanceAndIndex: (feature, featureIdx, vertex, attributeIdx, normal, vertexIndex) => {
      return vertexIndex === void 0 ? [vertex[3], 10] : [vertex[3], vertexIndex];
    },
    a_Total_Distance: (feature, featureIdx, vertex) => {
      return [vertex[5]];
    },
    a_Size: (feature) => {
      const { size: pointSize = 1 } = feature;
      return Array.isArray(pointSize) ? [pointSize[0], pointSize[1]] : [pointSize, 0];
    },
    a_Normal: (feature, featureIdx, vertex, attributeIdx, normal) => {
      return normal;
    },
    a_Miter: (feature, featureIdx, vertex) => {
      return [vertex[4]];
    },
    a_iconMapUV: (feature) => {
      const { texture } = feature;
      const { x, y } = iconMap[texture] || { x: 0, y: 0 };
      return [x, y];
    }
  };
  const featureLayout = {
    sizePerElement: 0,
    elements: []
  };
  let verticesNum = 0;
  const indices = [];
  let size = 3;
  features.forEach((feature, featureIdx) => {
    const {
      indices: indicesForCurrentFeature,
      vertices: verticesForCurrentFeature,
      // @ts-ignore
      normals: normalsForCurrentFeature,
      size: vertexSize,
      // @ts-ignore
      indexes
    } = (0, import_triangulation.LineTriangulation)(feature);
    indicesForCurrentFeature.forEach((i) => {
      indices.push(i + verticesNum);
    });
    size = vertexSize;
    const verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
    featureLayout.sizePerElement = size;
    featureLayout.elements.push({
      featureIdx,
      vertices: verticesForCurrentFeature,
      normals: normalsForCurrentFeature,
      offset: verticesNum
    });
    verticesNum += verticesNumForCurrentFeature;
    for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
      const normal = (normalsForCurrentFeature == null ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
      const vertice = verticesForCurrentFeature.slice(
        vertexIdx * vertexSize,
        vertexIdx * vertexSize + vertexSize
      );
      let vertexIndex = 0;
      if (indexes && indexes[vertexIdx] !== void 0) {
        vertexIndex = indexes[vertexIdx];
      }
      descriptors.forEach((descriptor) => {
        if (descriptor && updateFuncs[descriptor.name]) {
          descriptor.buffer.data.push(
            ...updateFuncs[descriptor.name](
              feature,
              featureIdx,
              vertice,
              vertexIdx,
              normal,
              vertexIndex
            )
          );
        }
      });
    }
  });
  return {
    descriptors,
    featureLayout,
    indices
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  lineModel
});
