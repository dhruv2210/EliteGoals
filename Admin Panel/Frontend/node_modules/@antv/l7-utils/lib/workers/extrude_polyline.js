var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/workers/extrude_polyline.ts
var extrude_polyline_exports = {};
__export(extrude_polyline_exports, {
  computeMiter: () => computeMiter,
  computeNormal: () => computeNormal,
  default: () => ExtrudePolyline,
  direction: () => direction,
  getArrayUnique: () => getArrayUnique
});
module.exports = __toCommonJS(extrude_polyline_exports);
var import_gl_matrix = require("gl-matrix");
var import_geo = require("../geo");
var tmp = import_gl_matrix.vec2.create();
var capEnd = import_gl_matrix.vec2.create();
var lineA = import_gl_matrix.vec2.create();
var lineB = import_gl_matrix.vec2.create();
var tangent = import_gl_matrix.vec2.create();
function computeMiter(lineTangent, miter, start, end, halfThick) {
  import_gl_matrix.vec2.add(lineTangent, start, end);
  import_gl_matrix.vec2.normalize(lineTangent, lineTangent);
  miter = import_gl_matrix.vec2.fromValues(-lineTangent[1], lineTangent[0]);
  const tmpvec = import_gl_matrix.vec2.fromValues(-start[1], start[0]);
  return [halfThick / import_gl_matrix.vec2.dot(miter, tmpvec), miter];
}
function computeNormal(out, dir) {
  return import_gl_matrix.vec2.set(out, -dir[1], dir[0]);
}
function direction(out, a, b) {
  import_gl_matrix.vec2.sub(out, a, b);
  import_gl_matrix.vec2.normalize(out, out);
  return out;
}
function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function getArrayUnique(matrix) {
  const map = /* @__PURE__ */ new Map();
  for (let i = 0; i < matrix.length; i++) {
    const key = matrix[0].toString() + "-" + matrix[1].toString();
    if (map.get(key)) {
      matrix.splice(i, 1);
      i++;
    } else {
      map.set(key, key);
    }
  }
  return matrix;
}
var ExtrudePolyline = class {
  constructor(opts = {}) {
    this.lastFlip = -1;
    this.miter = import_gl_matrix.vec2.fromValues(0, 0);
    this.started = false;
    this.dash = false;
    this.totalDistance = 0;
    this.currentIndex = 0;
    this.join = opts.join || "miter";
    this.cap = opts.cap || "butt";
    this.miterLimit = opts.miterLimit || 10;
    this.thickness = opts.thickness || 1;
    this.dash = opts.dash || false;
    this.complex = {
      positions: [],
      indices: [],
      normals: [],
      startIndex: 0,
      indexes: []
    };
  }
  extrude_gaode2(points, originPoints) {
    const complex = this.complex;
    if (points.length <= 1) {
      return complex;
    }
    this.lastFlip = -1;
    this.started = false;
    this.normal = null;
    this.totalDistance = 0;
    const total = points.length;
    let count = complex.startIndex;
    for (let i = 1; i < total; i++) {
      const last = points[i - 1];
      last.push(originPoints[i - 1][2] ?? 0);
      const originLast = originPoints[i - 1];
      const cur = points[i];
      cur.push(originPoints[i][2] ?? 0);
      const originCur = originPoints[i];
      const next = i < points.length - 1 ? [...points[i + 1], originPoints[i + 1][2] ?? 0] : null;
      const originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
      const amt = this.segment_gaode2(
        complex,
        count,
        // @ts-ignore
        last,
        // @ts-ignore
        cur,
        // @ts-ignore
        next,
        // @ts-ignore
        originLast,
        originCur,
        // @ts-ignore
        originNext
      );
      count += amt;
    }
    if (this.dash) {
      for (let i = 0; i < complex.positions.length / 6; i++) {
        complex.positions[i * 6 + 5] = this.totalDistance;
      }
    }
    complex.startIndex = complex.positions.length / 6;
    return complex;
  }
  simpleExtrude_gaode2(points, originPoints) {
    const complex = this.complex;
    if (points.length <= 1) {
      return complex;
    }
    this.lastFlip = -1;
    this.started = false;
    this.normal = null;
    this.totalDistance = 0;
    const total = points.length;
    let count = complex.startIndex;
    for (let i = 1; i < total; i++) {
      const last = points[i - 1];
      last.push(originPoints[i - 1][2] ?? 0);
      const originLast = originPoints[i - 1];
      const cur = points[i];
      cur.push(originPoints[i][2] ?? 0);
      const originCur = originPoints[i];
      const next = i < points.length - 1 ? [...points[i + 1], originPoints[i + 1][2] ?? 0] : null;
      const originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
      const amt = this.simpleSegment(
        complex,
        count,
        // @ts-ignore
        last,
        // @ts-ignore
        cur,
        // @ts-ignore
        next,
        // @ts-ignore
        originLast,
        originCur,
        // @ts-ignore
        originNext
      );
      count += amt;
    }
    if (this.dash) {
      for (let i = 0; i < complex.positions.length / 6; i++) {
        complex.positions[i * 6 + 5] = this.totalDistance;
      }
    }
    complex.startIndex = complex.positions.length / 6;
    return complex;
  }
  extrude(points) {
    const complex = this.complex;
    if (points.length <= 1) {
      return complex;
    }
    this.lastFlip = -1;
    this.started = false;
    this.normal = null;
    this.totalDistance = 0;
    const total = points.length;
    let count = complex.startIndex;
    for (let i = 1; i < total; i++) {
      const last = points[i - 1];
      const cur = points[i];
      const next = i < points.length - 1 ? points[i + 1] : null;
      const amt = this.segment(complex, count, last, cur, next);
      count += amt;
    }
    if (this.dash) {
      for (let i = 0; i < complex.positions.length / 6; i++) {
        complex.positions[i * 6 + 5] = this.totalDistance;
      }
    }
    complex.startIndex = complex.positions.length / 6;
    return complex;
  }
  simpleExtrude(points) {
    const complex = this.complex;
    if (points.length <= 1) {
      return complex;
    }
    this.lastFlip = -1;
    this.started = false;
    this.normal = null;
    this.totalDistance = 0;
    const total = points.length;
    let count = complex.startIndex;
    for (let i = 1; i < total; i++) {
      const last = points[i - 1];
      const cur = points[i];
      const next = i < points.length - 1 ? points[i + 1] : null;
      const amt = this.simpleSegment(complex, count, last, cur, next);
      count += amt;
    }
    if (this.dash) {
      for (let i = 0; i < complex.positions.length / 6; i++) {
        complex.positions[i * 6 + 5] = this.totalDistance;
      }
    }
    complex.startIndex = complex.positions.length / 6;
    return complex;
  }
  segment_gaode2(complex, index, last, cur, next, originLast, originCur, originNext) {
    let count = 0;
    const indices = complex.indices;
    const positions = complex.positions;
    const normals = complex.normals;
    const capSquare = this.cap === "square";
    const joinBevel = this.join === "bevel";
    const flatCur = (0, import_geo.aProjectFlat)([originCur[0], originCur[1]]);
    const flatLast = (0, import_geo.aProjectFlat)([originLast[0], originLast[1]]);
    direction(lineA, cur, last);
    let segmentDistance = 0;
    if (this.dash) {
      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
      this.totalDistance += segmentDistance;
    }
    if (!this.normal) {
      this.normal = import_gl_matrix.vec2.create();
      computeNormal(this.normal, lineA);
    }
    if (!this.started) {
      this.started = true;
      if (capSquare) {
        const out1 = import_gl_matrix.vec2.create();
        const out2 = import_gl_matrix.vec2.create();
        import_gl_matrix.vec2.add(out1, this.normal, lineA);
        import_gl_matrix.vec2.add(out2, this.normal, lineA);
        normals.push(out2[0], out2[1], 0);
        normals.push(out1[0], out1[1], 0);
        positions.push(
          last[0],
          last[1],
          last[2] | 0,
          this.totalDistance - segmentDistance,
          -this.thickness,
          last[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        positions.push(
          last[0],
          last[1],
          last[2] | 0,
          this.totalDistance - segmentDistance,
          this.thickness,
          last[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
      } else {
        this.extrusions(
          positions,
          normals,
          last,
          this.normal,
          this.thickness,
          this.totalDistance - segmentDistance
        );
      }
    }
    indices.push(index + 0, index + 1, index + 2);
    if (!next) {
      computeNormal(this.normal, lineA);
      if (capSquare) {
        const out1 = import_gl_matrix.vec2.create();
        const out2 = import_gl_matrix.vec2.create();
        import_gl_matrix.vec2.sub(out2, lineA, this.normal);
        import_gl_matrix.vec2.add(out1, lineA, this.normal);
        normals.push(out2[0], out2[1], 0);
        normals.push(out1[0], out1[1], 0);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          this.thickness,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          this.thickness,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
      } else {
        this.extrusions(
          positions,
          normals,
          cur,
          this.normal,
          this.thickness,
          this.totalDistance
        );
      }
      indices.push(
        ...this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
      );
      count += 2;
    } else {
      if (isPointEqual(cur, next)) {
        import_gl_matrix.vec2.add(
          // @ts-ignore
          next,
          // @ts-ignore
          cur,
          import_gl_matrix.vec2.normalize(
            // @ts-ignore
            next,
            // @ts-ignore
            import_gl_matrix.vec2.subtract(next, cur, last)
          )
        );
      }
      direction(lineB, next, cur);
      const [miterLen, miter] = computeMiter(
        tangent,
        import_gl_matrix.vec2.create(),
        lineA,
        lineB,
        this.thickness
      );
      let flip = import_gl_matrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
      let bevel = joinBevel;
      if (!bevel && this.join === "miter") {
        const limit = miterLen;
        if (limit > this.miterLimit) {
          bevel = true;
        }
      }
      if (bevel) {
        normals.push(this.normal[0], this.normal[1], 0);
        normals.push(miter[0], miter[1], 0);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          -this.thickness * flip,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          this.thickness * flip,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
        indices.push(
          ...this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
        );
        indices.push(index + 2, index + 3, index + 4);
        computeNormal(tmp, lineB);
        import_gl_matrix.vec2.copy(this.normal, tmp);
        normals.push(this.normal[0], this.normal[1], 0);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          -this.thickness * flip,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
        count += 3;
      } else {
        this.extrusions(
          positions,
          normals,
          cur,
          miter,
          miterLen,
          this.totalDistance
        );
        indices.push(
          ...this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
        );
        flip = -1;
        import_gl_matrix.vec2.copy(this.normal, miter);
        count += 2;
      }
      this.lastFlip = flip;
    }
    return count;
  }
  simpleSegment(complex, index, last, cur, next) {
    let count = 0;
    const indices = complex.indices;
    const positions = complex.positions;
    const normals = complex.normals;
    const flatCur = (0, import_geo.aProjectFlat)([cur[0], cur[1]]);
    const flatLast = (0, import_geo.aProjectFlat)([last[0], last[1]]);
    direction(lineA, flatCur, flatLast);
    let segmentDistance = 0;
    if (this.dash) {
      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
      this.totalDistance += segmentDistance;
    }
    if (!this.normal) {
      this.normal = import_gl_matrix.vec2.create();
      computeNormal(this.normal, lineA);
    }
    if (!this.started) {
      this.started = true;
      this.extrusions(
        positions,
        normals,
        last,
        this.normal,
        this.thickness,
        this.totalDistance - segmentDistance
      );
    }
    indices.push(index + 0, index + 1, index + 2);
    if (!next) {
      computeNormal(this.normal, lineA);
      this.extrusions(
        positions,
        normals,
        cur,
        this.normal,
        this.thickness,
        this.totalDistance
      );
      indices.push(
        ...this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
      );
      count += 2;
    } else {
      const flatNext = (0, import_geo.aProjectFlat)([next[0], next[1]]);
      if (isPointEqual(flatCur, flatNext)) {
        import_gl_matrix.vec2.add(
          flatNext,
          flatCur,
          import_gl_matrix.vec2.normalize(flatNext, import_gl_matrix.vec2.subtract(flatNext, flatCur, flatLast))
        );
      }
      direction(lineB, flatNext, flatCur);
      const [miterLen, miter] = computeMiter(
        tangent,
        import_gl_matrix.vec2.create(),
        lineA,
        lineB,
        this.thickness
      );
      let flip = import_gl_matrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
      this.extrusions(
        positions,
        normals,
        cur,
        miter,
        miterLen,
        this.totalDistance
      );
      indices.push(
        ...this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
      );
      flip = -1;
      import_gl_matrix.vec2.copy(this.normal, miter);
      count += 2;
      this.lastFlip = flip;
    }
    return count;
  }
  segment(complex, index, last, cur, next) {
    let count = 0;
    const indices = complex.indices;
    const positions = complex.positions;
    const normals = complex.normals;
    const capSquare = this.cap === "square";
    const joinBevel = this.join === "bevel";
    const flatCur = (0, import_geo.aProjectFlat)([cur[0], cur[1]]);
    const flatLast = (0, import_geo.aProjectFlat)([last[0], last[1]]);
    direction(lineA, flatCur, flatLast);
    let segmentDistance = 0;
    if (this.dash) {
      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
      this.totalDistance += segmentDistance;
    }
    if (!this.normal) {
      this.normal = import_gl_matrix.vec2.create();
      computeNormal(this.normal, lineA);
    }
    if (!this.started) {
      this.started = true;
      if (capSquare) {
        const out1 = import_gl_matrix.vec2.create();
        const out2 = import_gl_matrix.vec2.create();
        import_gl_matrix.vec2.add(out1, this.normal, lineA);
        import_gl_matrix.vec2.add(out2, this.normal, lineA);
        normals.push(out2[0], out2[1], 0);
        normals.push(out1[0], out1[1], 0);
        positions.push(
          last[0],
          last[1],
          last[2] | 0,
          this.totalDistance - segmentDistance,
          -this.thickness,
          last[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        positions.push(
          last[0],
          last[1],
          last[2] | 0,
          this.totalDistance - segmentDistance,
          this.thickness,
          last[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
      } else {
        this.extrusions(
          positions,
          normals,
          last,
          this.normal,
          this.thickness,
          this.totalDistance - segmentDistance
        );
      }
    }
    indices.push(index + 0, index + 1, index + 2);
    if (!next) {
      computeNormal(this.normal, lineA);
      if (capSquare) {
        const out1 = import_gl_matrix.vec2.create();
        const out2 = import_gl_matrix.vec2.create();
        import_gl_matrix.vec2.sub(out2, lineA, this.normal);
        import_gl_matrix.vec2.add(out1, lineA, this.normal);
        normals.push(out2[0], out2[1], 0);
        normals.push(out1[0], out1[1], 0);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          this.thickness,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          this.thickness,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
      } else {
        this.extrusions(
          positions,
          normals,
          cur,
          this.normal,
          this.thickness,
          this.totalDistance
        );
      }
      indices.push(
        ...this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
      );
      count += 2;
    } else {
      const flatNext = (0, import_geo.aProjectFlat)([next[0], next[1]]);
      if (isPointEqual(flatCur, flatNext)) {
        import_gl_matrix.vec2.add(
          flatNext,
          flatCur,
          import_gl_matrix.vec2.normalize(flatNext, import_gl_matrix.vec2.subtract(flatNext, flatCur, flatLast))
        );
      }
      direction(lineB, flatNext, flatCur);
      const [miterLen, miter] = computeMiter(
        tangent,
        import_gl_matrix.vec2.create(),
        lineA,
        lineB,
        this.thickness
      );
      let flip = import_gl_matrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
      let bevel = joinBevel;
      if (!bevel && this.join === "miter") {
        const limit = miterLen;
        if (limit > this.miterLimit) {
          bevel = true;
        }
      }
      if (bevel) {
        normals.push(this.normal[0], this.normal[1], 0);
        normals.push(miter[0], miter[1], 0);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          -this.thickness * flip,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          this.thickness * flip,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
        indices.push(
          ...this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
        );
        indices.push(index + 2, index + 3, index + 4);
        computeNormal(tmp, lineB);
        import_gl_matrix.vec2.copy(this.normal, tmp);
        normals.push(this.normal[0], this.normal[1], 0);
        positions.push(
          cur[0],
          cur[1],
          cur[2] | 0,
          this.totalDistance,
          -this.thickness * flip,
          cur[2] | 0
        );
        this.complex.indexes.push(this.currentIndex);
        this.currentIndex++;
        count += 3;
      } else {
        this.extrusions(
          positions,
          normals,
          cur,
          miter,
          miterLen,
          this.totalDistance
        );
        indices.push(
          ...this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]
        );
        flip = -1;
        import_gl_matrix.vec2.copy(this.normal, miter);
        count += 2;
      }
      this.lastFlip = flip;
    }
    return count;
  }
  extrusions(positions, normals, point, normal, thickness, distanceRadio) {
    normals.push(normal[0], normal[1], 0);
    normals.push(normal[0], normal[1], 0);
    positions.push(
      point[0],
      point[1],
      point[2] | 0,
      distanceRadio,
      -thickness,
      point[2] | 0
    );
    this.complex.indexes.push(this.currentIndex);
    positions.push(
      point[0],
      point[1],
      point[2] | 0,
      distanceRadio,
      thickness,
      point[2] | 0
    );
    this.complex.indexes.push(this.currentIndex);
    this.currentIndex++;
  }
  lineSegmentDistance(b1, a1) {
    const dx = a1[0] - b1[0];
    const dy = a1[1] - b1[1];
    return Math.sqrt(dx * dx + dy * dy);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  computeMiter,
  computeNormal,
  direction,
  getArrayUnique
});
