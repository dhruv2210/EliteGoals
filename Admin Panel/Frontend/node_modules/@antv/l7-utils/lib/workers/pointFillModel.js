var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/workers/pointFillModel.ts
var pointFillModel_exports = {};
__export(pointFillModel_exports, {
  pointFillModel: () => pointFillModel
});
module.exports = __toCommonJS(pointFillModel_exports);
var import_color = require("../color");
var import_commonFeatureFunc = require("./commonFeatureFunc");
var import_triangulation = require("./triangulation");
var pointFillModel = async ({
  descriptors,
  features,
  enablePicking,
  shape2d
}) => {
  const updateFuncs = {
    // fixed feature func
    a_Color: import_commonFeatureFunc.a_Color,
    a_Position: import_commonFeatureFunc.a_Position,
    filter: import_commonFeatureFunc.a_filter,
    a_vertexId: import_commonFeatureFunc.a_vertexId,
    a_PickingColor: (feature) => {
      const { id } = feature;
      return enablePicking ? (0, import_color.encodePickingColor)(id) : [0, 0, 0];
    },
    // pointFill feature func
    a_Shape: (feature) => {
      const { shape = 2 } = feature;
      const shapeIndex = shape2d.indexOf(shape);
      return [shapeIndex];
    },
    a_Extrude: (feature, featureIdx, vertex, attributeIdx) => {
      const extrude = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0];
      const extrudeIndex = attributeIdx % 4 * 3;
      return [
        extrude[extrudeIndex],
        extrude[extrudeIndex + 1],
        extrude[extrudeIndex + 2]
      ];
    },
    a_Size: (feature) => {
      const { size: pointSize = 5 } = feature;
      return Array.isArray(pointSize) ? [pointSize[0]] : [pointSize];
    }
  };
  const featureLayout = {
    sizePerElement: 0,
    elements: []
  };
  let verticesNum = 0;
  const indices = [];
  let size = 3;
  features.forEach((feature, featureIdx) => {
    const {
      indices: indicesForCurrentFeature,
      vertices: verticesForCurrentFeature,
      // @ts-ignore
      normals: normalsForCurrentFeature,
      size: vertexSize,
      // @ts-ignore
      indexes
    } = (0, import_triangulation.PointFillTriangulation)(feature);
    indicesForCurrentFeature.forEach((i) => {
      indices.push(i + verticesNum);
    });
    size = vertexSize;
    const verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;
    featureLayout.sizePerElement = size;
    featureLayout.elements.push({
      featureIdx,
      vertices: verticesForCurrentFeature,
      normals: normalsForCurrentFeature,
      offset: verticesNum
    });
    verticesNum += verticesNumForCurrentFeature;
    for (let vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
      const normal = (normalsForCurrentFeature == null ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
      const vertice = verticesForCurrentFeature.slice(
        vertexIdx * vertexSize,
        vertexIdx * vertexSize + vertexSize
      );
      let vertexIndex = 0;
      if (indexes && indexes[vertexIdx] !== void 0) {
        vertexIndex = indexes[vertexIdx];
      }
      descriptors.forEach((descriptor) => {
        if (descriptor && updateFuncs[descriptor.name]) {
          descriptor.buffer.data.push(
            ...updateFuncs[descriptor.name](
              feature,
              featureIdx,
              vertice,
              vertexIdx,
              normal,
              vertexIndex
            )
          );
        }
      });
    }
  });
  return {
    descriptors,
    featureLayout,
    indices
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  pointFillModel
});
