{"version":3,"sources":["../../../src/components/mesh/System.ts"],"names":["mat3","vec3","inject","injectable","IDENTIFIER","Mask","getRotationScale","MeshSystem","MeshComponentManager","CullableComponentManager","GeometryComponentManager","HierarchyComponentManager","TransformComponentManager","planes","views","view","scene","getScene","camera","getCamera","getEntities","entity","component","mesh","getComponentByEntity","hierarchyComponent","hierarchy","cullableComponent","cullable","geometryComponent","geometry","meshTransform","transform","aabb","aabbDirty","worldTransform","center","halfExtents","transformedCenter","transformMat4","create","rotationScale","transformedHalfExtents","transformMat3","update","parentCullableComponent","parentID","visibilityPlaneMask","computeVisibilityWithPlaneMask","INDETERMINATE","getFrustum","visible","OUTSIDE","clear","parentPlaneMask","INSIDE","mask","k","len","length","flag","normal","distance","dot","getNegativeFarPoint","getPositiveFarPoint"],"mappings":"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","sourcesContent":["import { mat3, mat4, vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { ISystem } from '../..';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { AABB } from '../../shape/AABB';\nimport { Mask } from '../../shape/Frustum';\nimport { Plane } from '../../shape/Plane';\nimport { getRotationScale } from '../../utils/math';\nimport { GeometryComponent } from '../geometry/GeometryComponent';\nimport { MaterialComponent } from '../material/MaterialComponent';\nimport { IView } from '../renderer/IRendererService';\nimport { HierarchyComponent } from '../scenegraph/HierarchyComponent';\nimport { TransformComponent } from '../scenegraph/TransformComponent';\nimport { CullableComponent } from './CullableComponent';\nimport { IMeshParams } from './interface';\nimport { MeshComponent } from './MeshComponent';\n\n@injectable()\nexport class MeshSystem implements ISystem {\n  @inject(IDENTIFIER.MeshComponentManager)\n  private readonly mesh: ComponentManager<MeshComponent>;\n\n  @inject(IDENTIFIER.CullableComponentManager)\n  private readonly cullable: ComponentManager<CullableComponent>;\n\n  @inject(IDENTIFIER.GeometryComponentManager)\n  private readonly geometry: ComponentManager<GeometryComponent>;\n\n  @inject(IDENTIFIER.HierarchyComponentManager)\n  private readonly hierarchy: ComponentManager<HierarchyComponent>;\n\n  @inject(IDENTIFIER.TransformComponentManager)\n  private readonly transform: ComponentManager<TransformComponent>;\n\n  private planes: Plane[];\n\n  public setFrustumPlanes(planes: Plane[]) {\n    this.planes = planes;\n  }\n\n  public async execute(views: IView[]) {\n    for (const view of views) {\n      const scene = view.getScene();\n      const camera = view.getCamera();\n\n      // get VP matrix from camera\n      for (const entity of scene.getEntities()) {\n        const component = this.mesh.getComponentByEntity(entity);\n\n        if (component) {\n          const hierarchyComponent = this.hierarchy.getComponentByEntity(entity);\n          const cullableComponent = this.cullable.getComponentByEntity(entity);\n          const geometryComponent = component.geometry;\n          const meshTransform = this.transform.getComponentByEntity(entity);\n\n          // update mesh.aabb\n          if (\n            geometryComponent &&\n            geometryComponent.aabb &&\n            meshTransform &&\n            component.aabbDirty\n          ) {\n            const { worldTransform } = meshTransform;\n\n            // apply transform to geometry.aabb\n            const { center, halfExtents } = geometryComponent.aabb;\n            const transformedCenter = vec3.transformMat4(\n              vec3.create(),\n              center,\n              worldTransform,\n            );\n\n            const rotationScale = getRotationScale(worldTransform, mat3.create());\n            const transformedHalfExtents = vec3.transformMat3(\n              vec3.create(),\n              halfExtents,\n              rotationScale,\n            );\n\n            component.aabb.update(transformedCenter, transformedHalfExtents);\n            component.aabbDirty = false;\n          }\n\n          // culling\n          if (cullableComponent && geometryComponent) {\n            const parentCullableComponent = this.cullable.getComponentByEntity(\n              hierarchyComponent?.parentID || -1,\n            );\n            cullableComponent.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(\n              component.aabb,\n              parentCullableComponent?.visibilityPlaneMask || Mask.INDETERMINATE,\n              this.planes || camera.getFrustum().planes,\n            );\n            cullableComponent.visible =\n              cullableComponent.visibilityPlaneMask !== Mask.OUTSIDE;\n          }\n        }\n      }\n    }\n  }\n\n  public tearDown() {\n    this.cullable.clear();\n    this.mesh.clear();\n  }\n\n  /**\n   *\n   * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」\n   * @see https://github.com/antvis/GWebGPUEngine/issues/3\n   *\n   * * 基础相交测试 the basic intersection test\n   * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/\n   * * TODO: 平面一致性测试 the plane-coherency test\n   * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy\n   *\n   * @param aabb aabb\n   * @param parentPlaneMask mask of parent\n   * @param planes planes of frustum\n   */\n  public computeVisibilityWithPlaneMask(\n    aabb: AABB,\n    parentPlaneMask: Mask,\n    planes: Plane[],\n  ) {\n    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {\n      // 父节点完全位于视锥内或者外部，直接返回\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = Mask.INSIDE;\n\n    for (let k = 0, len = planes.length; k < len; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // 父节点处于当前面内部，可以跳过\n        continue;\n      }\n\n      // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测\n      const { normal, distance } = planes[k];\n      if (\n        vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance >\n        0\n      ) {\n        return Mask.OUTSIDE;\n      }\n      if (\n        vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance >\n        0\n      ) {\n        // 和当前面相交，对应位置为1，继续检测下一个面\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"],"file":"System.js"}