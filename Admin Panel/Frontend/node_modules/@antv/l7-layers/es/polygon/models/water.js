import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { AttributeType, gl } from '@antv/l7-core';
import { Version } from '@antv/l7-maps';
import { isNumber } from 'lodash';
import BaseModel from "../../core/BaseModel";
import { polygonTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/water/polygon_water_frag.glsl' */
var water_frag = "uniform sampler2D u_texture;\nuniform float u_time: 0.0;\nuniform float u_speed: 1.0;\nuniform float u_opacity: 1.0;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\n\nfloat rand(vec2 n) { return 0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453); }\n\nfloat water(vec3 p) {\n  float t = u_time * u_speed;\n  p.z += t * 2.; p.x += t * 2.;\n  vec3 c1 = texture2D(u_texture, p.xz / 30.).xyz;\n  p.z += t * 3.; p.x += t * 0.52;\n  vec3 c2 = texture2D(u_texture, p.xz / 30.).xyz;\n  p.z += t * 4.; p.x += t * 0.8;\n  vec3 c3 = texture2D(u_texture, p.xz / 30.).xyz;\n  c1 += c2 - c3;\n  float z = (c1.x + c1.y + c1.z) / 3.;\n  return p.y + z / 4.;\n}\n\nfloat map(vec3 p) {\n  float d = 100.0;\n  d = water(p);\n  return d;\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n  float d = 0.0;\n  for (int i = 0; i <= 100; i++) {\n    float h = map(ro + rd * d);\n    if (h < 0.1) return  d;\n    d += h;\n  }\n  return 0.0;\n}\n\nvec3 norm(vec3 p) {\n  float eps = .1;\n  return normalize(vec3(\n    map(p + vec3(eps, 0, 0)) - map(p + vec3(-eps, 0, 0)),\n    map(p + vec3(0, eps, 0)) - map(p + vec3(0, -eps, 0)),\n    map(p + vec3(0, 0, eps)) - map(p + vec3(0, 0, -eps))\n  ));\n} \n\nfloat calSpc() {\n  vec3 l1 = normalize(vec3(1, 1, 1));\n  vec3 ro = vec3(-3, 20, -8);\n  vec3 rc = vec3(0, 0, 0);\n  vec3 ww = normalize(rc - ro);\n  vec3 uu = normalize(cross(vec3(0,1,0), ww));\n  vec3 vv = normalize(cross(rc - ro, uu));\n  vec3 rd = normalize(uu * v_uv.x + vv * v_uv.y + ww);\n  float d = intersect(ro, rd);\n  vec3 p = ro + rd * d;\n  vec3 n = norm(p);\n  float spc = pow(max(0.0, dot(reflect(l1, n), rd)), 30.0);\n  return spc;\n}\n\nvoid main() {\n  float opacity = u_opacity;\n  gl_FragColor = v_Color;\n  gl_FragColor.a *= opacity;\n\n  float spc = calSpc();\n  gl_FragColor += spc * 0.4;\n}\n";
/* babel-plugin-inline-import '../shaders/water/polygon_water_vert.glsl' */
var water_vert = "attribute vec4 a_Color;\nattribute vec2 a_uv;\nattribute vec3 a_Position;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_Color;\nvarying vec2 v_uv;\nuniform float u_opacity: 1.0;\n\n\n#pragma include \"projection\"\n\nvoid main() {\n  v_uv = a_uv;\n\n  v_Color = a_Color;\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n    gl_Position = u_Mvp * (vec4(project_pos.xyz, 1.0));\n  } else {\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n  }\n}\n\n";
var WaterModel = /*#__PURE__*/function (_BaseModel) {
  _inherits(WaterModel, _BaseModel);
  var _super = _createSuper(WaterModel);
  function WaterModel() {
    _classCallCheck(this, WaterModel);
    return _super.apply(this, arguments);
  }
  _createClass(WaterModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref = this.layer.getLayerConfig(),
        _ref$opacity = _ref.opacity,
        opacity = _ref$opacity === void 0 ? 1 : _ref$opacity,
        _ref$speed = _ref.speed,
        speed = _ref$speed === void 0 ? 0.5 : _ref$speed;
      return {
        u_texture: this.texture,
        u_speed: speed,
        u_opacity: isNumber(opacity) ? opacity : 1.0
      };
    }
  }, {
    key: "getAnimateUniforms",
    value: function getAnimateUniforms() {
      return {
        u_time: this.layer.getLayerAnimateTime()
      };
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.loadTexture();
              return _context.abrupt("return", this.buildModels());
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var model;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.layer.buildLayerModel({
                moduleName: 'polygonWater',
                vertexShader: water_vert,
                fragmentShader: water_frag,
                triangulation: polygonTriangulation,
                primitive: gl.TRIANGLES,
                depth: {
                  enable: false
                }
              });
            case 2:
              model = _context2.sent;
              return _context2.abrupt("return", [model]);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }()
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture;
      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      var bbox = this.layer.getSource().extent;
      var _bbox = _slicedToArray(bbox, 4),
        minLng = _bbox[0],
        minLat = _bbox[1],
        maxLng = _bbox[2],
        maxLat = _bbox[3];
      var lngLen = maxLng - minLng;
      var latLen = maxLat - minLat;
      this.styleAttributeService.registerStyleAttribute({
        name: 'waterUv',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_uv',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.STATIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex, attributeIdx) {
            var v = feature.version === Version['GAODE2.x'] ? feature.originCoordinates[0][attributeIdx] : vertex;
            var _v = _slicedToArray(v, 2),
              lng = _v[0],
              lat = _v[1];
            return [(lng - minLng) / lngLen, (lat - minLat) / latLen];
          }
        }
      });
    }
  }, {
    key: "loadTexture",
    value: function loadTexture() {
      var _this = this;
      var _ref2 = this.layer.getLayerConfig(),
        waterTexture = _ref2.waterTexture;
      var createTexture2D = this.rendererService.createTexture2D;
      this.texture = createTexture2D({
        height: 0,
        width: 0
      });
      var image = new Image();
      image.crossOrigin = '';
      if (waterTexture) {
        // custom texture
        console.warn('L7 recommendï¼šhttps://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ');
        image.src = waterTexture;
      } else {
        // default texture
        image.src = 'https://gw.alipayobjects.com/mdn/rms_816329/afts/img/A*EojwT4VzSiYAAAAAAAAAAAAAARQnAQ';
      }
      image.onload = function () {
        _this.texture = createTexture2D({
          data: image,
          width: image.width,
          height: image.height,
          wrapS: gl.MIRRORED_REPEAT,
          wrapT: gl.MIRRORED_REPEAT,
          min: gl.LINEAR,
          mag: gl.LINEAR
        });
        _this.layerService.reRender();
      };
    }
  }]);
  return WaterModel;
}(BaseModel);
export { WaterModel as default };