import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import * as glUtils from "./utils";
import { drawFrag, drawVert, fullScreenFrag, fullScreenVert, updateFrag, updateVert } from "./windShader";
function getColorRamp(colors) {
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 1;
  var gradient = ctx.createLinearGradient(0, 0, 256, 0);
  for (var _i = 0, _Object$keys = Object.keys(colors); _i < _Object$keys.length; _i++) {
    var stop = _Object$keys[_i];
    gradient.addColorStop(+stop, colors[+stop]);
  }
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 256, 1);

  // @ts-ignore dispose canvas element
  canvas = null;
  return new Uint8Array(ctx.getImageData(0, 0, 256, 1).data);
}
function bindAttribute(gl, buffer, attribute, numComponents) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.enableVertexAttribArray(attribute);
  gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);
}
function bindFramebuffer(gl, framebuffer, texture) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  if (texture) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  }
}
export var Wind = /*#__PURE__*/function () {
  function Wind(options) {
    _classCallCheck(this, Wind);
    _defineProperty(this, "width", 512);
    _defineProperty(this, "height", 512);
    _defineProperty(this, "numParticles", 65536);
    this.gl = options.glContext;
    this.width = options.imageWidth;
    this.height = options.imageHeight;
    this.fadeOpacity = options.fadeOpacity;
    this.speedFactor = options.speedFactor;
    this.dropRate = options.dropRate;
    this.dropRateBump = options.dropRateBump;
    this.rampColors = options.rampColors;
    this.init();
  }
  _createClass(Wind, [{
    key: "init",
    value: function init() {
      var gl = this.gl;
      this.fadeOpacity = 0.996; // how fast the particle trails fade on each frame
      this.speedFactor = 0.25; // how fast the particles move
      this.dropRate = 0.003; // how often the particles move to a random place
      this.dropRateBump = 0.01; // drop rate increase relative to individual particle speed

      this.drawProgram = glUtils.createProgram(gl, drawVert, drawFrag);
      this.fullScreenProgram = glUtils.createProgram(gl, fullScreenVert, fullScreenFrag);
      this.updateProgram = glUtils.createProgram(gl, updateVert, updateFrag);
      this.quadBuffer = glUtils.createBuffer(gl, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]));
      this.framebuffer = gl.createFramebuffer();
      this.colorRampTexture = glUtils.createTexture(this.gl, this.gl.LINEAR, getColorRamp(this.rampColors), 16, 16);
      var emptyPixels = new Uint8Array(this.width * this.height * 4);

      // screen textures to hold the drawn screen for the previous and the current frame

      this.backgroundTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, this.width, this.height);
      this.screenTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, this.width, this.height);

      // we create a square texture where each pixel will hold a particle position encoded as RGBA
      var particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
      // particleRes size
      this.numParticlesSize = particleRes * particleRes;
      var particleState = new Uint8Array(this.numParticlesSize * 4);
      for (var i = 0; i < particleState.length; i++) {
        particleState[i] = Math.floor(Math.random() * 256); // randomize the initial particle positions
      }
      // textures to hold the particle state for the current and the next frame
      this.particleStateTexture0 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
      this.particleStateTexture1 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
      var particleIndices = new Float32Array(this.numParticlesSize);
      for (var i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
        particleIndices[i$1] = i$1;
      }
      this.particleIndexBuffer = glUtils.createBuffer(gl, particleIndices);
    }
  }, {
    key: "setWind",
    value: function setWind(windData) {
      this.windData = windData;
      this.windTexture = glUtils.createDataTexture(this.gl, this.gl.LINEAR, windData.image);
    }

    /**
     * 更新风场粒子数量
     * @param num
     */
  }, {
    key: "updateParticelNum",
    value: function updateParticelNum(num) {
      var gl = this.gl;
      if (num !== this.numParticles) {
        this.numParticles = num; // params number

        // we create a square texture where each pixel will hold a particle position encoded as RGBA
        var particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
        this.numParticlesSize = particleRes * particleRes;
        var particleState = new Uint8Array(this.numParticlesSize * 4);
        for (var i = 0; i < particleState.length; i++) {
          particleState[i] = Math.floor(Math.random() * 256); // randomize the initial particle positions
        }
        // textures to hold the particle state for the current and the next frame
        this.particleStateTexture0 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
        this.particleStateTexture1 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
        var particleIndices = new Float32Array(this.numParticlesSize);
        for (var i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
          particleIndices[i$1] = i$1;
        }
        this.particleIndexBuffer = glUtils.createBuffer(gl, particleIndices);
      }
    }

    /**
     * 更新风场风向风速
     * @param uMin
     * @param uMax
     * @param vMin
     * @param vMax
     */
  }, {
    key: "updateWindDir",
    value: function updateWindDir(uMin, uMax, vMin, vMax) {
      this.windData.uMin = uMin;
      this.windData.uMax = uMax;
      this.windData.vMin = vMin;
      this.windData.vMax = vMax;
    }

    /**
     * update rampColors
     * @param rampColors
     */
  }, {
    key: "updateColorRampTexture",
    value: function updateColorRampTexture(rampColors) {
      if (this.isColorChanged(rampColors)) {
        this.rampColors = rampColors;
        var gl = this.gl;
        gl.deleteTexture(this.colorRampTexture);
        this.colorRampTexture = glUtils.createTexture(gl, gl.LINEAR, getColorRamp(rampColors), 16, 16);
      }
    }
  }, {
    key: "isColorChanged",
    value: function isColorChanged(rampColors) {
      var keys = Object.keys(rampColors);
      for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
        var item = _keys[_i2];
        var _key = Number(item);
        // exist new key -> color need update
        if (!this.rampColors[_key]) {
          return true;
        }
        // value changed -> color need update
        if (this.rampColors[_key] && this.rampColors[_key] !== rampColors[_key]) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "reSize",
    value: function reSize(width, height) {
      if (width !== this.width || height !== this.height) {
        var gl = this.gl;
        gl.deleteTexture(this.backgroundTexture);
        gl.deleteTexture(this.screenTexture);
        this.width = width;
        this.height = height;
        var emptyPixels = new Uint8Array(width * height * 4);
        // screen textures to hold the drawn screen for the previous and the current frame
        this.backgroundTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, width, height);
        this.screenTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, width, height);
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this$windData;
      if ((_this$windData = this.windData) !== null && _this$windData !== void 0 && _this$windData.image) {
        var gl = this.gl;
        glUtils.bindTexture(gl, this.windTexture, 0);
        glUtils.bindTexture(gl, this.particleStateTexture0, 1);
        this.drawScreen(); // draw Particles into framebuffer
        this.updateParticles();
        return {
          d: this.pixels,
          w: this.width,
          h: this.height
        };
      } else {
        return {
          d: new Uint8Array([0, 0, 0, 0]),
          w: 1,
          h: 1
        };
      }
    }
  }, {
    key: "drawScreen",
    value: function drawScreen() {
      var gl = this.gl;

      // draw the screen into a temporary framebuffer to retain it as the background on the next frame
      bindFramebuffer(gl, this.framebuffer, this.screenTexture);
      gl.viewport(0, 0, this.width, this.height);
      gl.disable(gl.BLEND);
      this.drawFullTexture(this.backgroundTexture, this.fadeOpacity);
      this.drawParticles();
      this.pixels = new Uint8Array(4 * this.width * this.height);
      gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.pixels);
      bindFramebuffer(gl, null, null);
      gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);

      //   save the current screen as the background for the next frame
      var temp = this.backgroundTexture;
      this.backgroundTexture = this.screenTexture;
      this.screenTexture = temp;
    }
  }, {
    key: "drawFullTexture",
    value: function drawFullTexture(texture, opacity) {
      var gl = this.gl;
      var program = this.fullScreenProgram;
      gl.useProgram(program);

      // bindAttribute(gl, this.quadBuffer, program.a_pos, 2);

      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
      gl.vertexAttribPointer(program.a_pos, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(program.a_pos);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      glUtils.bindTexture(gl, texture, 2);
      gl.uniform1i(program.u_screen, 2);
      gl.uniform1f(program.u_opacity, opacity);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      // gl.drawArrays(gl.POINTS, 0, 6);
    }
  }, {
    key: "drawParticles",
    value: function drawParticles() {
      var gl = this.gl;
      var program = this.drawProgram;
      gl.useProgram(program);
      bindAttribute(gl, this.particleIndexBuffer, program.a_index, 1);
      glUtils.bindTexture(gl, this.colorRampTexture, 2);
      gl.uniform1i(program.u_wind, 0);
      gl.uniform1i(program.u_particles, 1);
      gl.uniform1i(program.u_color_ramp, 2);
      gl.uniform1f(program.u_particles_res, this.particleStateResolution);
      gl.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
      gl.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
      gl.drawArrays(gl.POINTS, 0, this.numParticlesSize);
    }
  }, {
    key: "updateParticles",
    value: function updateParticles() {
      var gl = this.gl;
      bindFramebuffer(gl, this.framebuffer, this.particleStateTexture1);
      gl.viewport(0, 0, this.particleStateResolution, this.particleStateResolution);
      var program = this.updateProgram;
      gl.useProgram(program);
      bindAttribute(gl, this.quadBuffer, program.a_pos, 2);
      gl.uniform1i(program.u_wind, 0);
      gl.uniform1i(program.u_particles, 1);
      gl.uniform1f(program.u_rand_seed, Math.random());
      gl.uniform2f(program.u_wind_res, this.windData.image.width * 2, this.windData.image.height * 2);
      gl.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
      gl.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
      gl.uniform1f(program.u_speed_factor, this.speedFactor);
      gl.uniform1f(program.u_drop_rate, this.dropRate);
      gl.uniform1f(program.u_drop_rate_bump, this.dropRateBump);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // swap the particle state textures so the new one becomes the current one
      var temp = this.particleStateTexture0;
      this.particleStateTexture0 = this.particleStateTexture1;
      this.particleStateTexture1 = temp;
      bindFramebuffer(gl, null, null);

      // gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // private drawProgram: WebGLProgram;
      // private fullScreenProgram: WebGLProgram;
      // private updateProgram: WebGLProgram;

      // private quadBuffer: WebGLBuffer | null;
      // private particleIndexBuffer: WebGLBuffer | null;

      // private framebuffer: WebGLFramebuffer | null;

      // private colorRampTexture: WebGLTexture | null;
      // private backgroundTexture: WebGLTexture | null;
      // private screenTexture: WebGLTexture | null;
      // private particleStateTexture0: WebGLTexture | null;
      // private particleStateTexture1: WebGLTexture | null;
      // private windTexture: WebGLTexture | null;

      this.gl.deleteBuffer(this.quadBuffer);
      this.gl.deleteBuffer(this.particleIndexBuffer);
      this.gl.deleteFramebuffer(this.framebuffer);

      // @ts-ignore
      this.gl.deleteShader(this.drawProgram.vertexShader);
      // @ts-ignore
      this.gl.deleteShader(this.drawProgram.fragmentShader);
      this.gl.deleteProgram(this.drawProgram);

      // @ts-ignore
      this.gl.deleteShader(this.fullScreenProgram.vertexShader);
      // @ts-ignore
      this.gl.deleteShader(this.fullScreenProgram.fragmentShader);
      this.gl.deleteProgram(this.fullScreenProgram);

      // @ts-ignore
      this.gl.deleteShader(this.updateProgram.vertexShader);
      // @ts-ignore
      this.gl.deleteShader(this.updateProgram.fragmentShader);
      this.gl.deleteProgram(this.updateProgram);
      this.gl.deleteTexture(this.colorRampTexture);
      this.gl.deleteTexture(this.backgroundTexture);
      this.gl.deleteTexture(this.screenTexture);
      this.gl.deleteTexture(this.particleStateTexture0);
      this.gl.deleteTexture(this.particleStateTexture1);
      this.gl.deleteTexture(this.windTexture);
    }
  }]);
  return Wind;
}();