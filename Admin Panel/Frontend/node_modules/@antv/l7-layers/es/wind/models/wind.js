import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { AttributeType, gl } from '@antv/l7-core';
import { FrequencyController } from '@antv/l7-utils';
import BaseModel from "../../core/BaseModel";
import { RasterImageTriangulation } from "../../core/triangulation";
/* babel-plugin-inline-import '../shaders/wind_frag.glsl' */
var WindFrag = "precision mediump float;\nuniform float u_opacity: 1.0;\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\nvoid main() {\n  vec4 color = texture2D(u_texture,vec2(v_texCoord.x,v_texCoord.y));\n  gl_FragColor = color;\n  gl_FragColor.a *= u_opacity;\n}\n";
/* babel-plugin-inline-import '../shaders/wind_vert.glsl' */
var WindVert = "precision highp float;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nattribute vec3 a_Position;\nattribute vec2 a_Uv;\nvarying vec2 v_texCoord;\n#pragma include \"projection\"\nvoid main() {\n   v_texCoord = a_Uv;\n   vec4 project_pos = project_position(vec4(a_Position, 1.0));\n   \n   if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n      gl_Position = u_Mvp * (vec4(project_pos.xy,0., 1.0));\n   } else {\n      gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy,0., 1.0));\n   }\n}\n";
import { Wind } from "./windRender";
var defaultRampColors = {
  0.0: '#3288bd',
  0.1: '#66c2a5',
  0.2: '#abdda4',
  0.3: '#e6f598',
  0.4: '#fee08b',
  0.5: '#fdae61',
  0.6: '#f46d43',
  1.0: '#d53e4f'
};
var WindModel = /*#__PURE__*/function (_BaseModel) {
  _inherits(WindModel, _BaseModel);
  var _super = _createSuper(WindModel);
  function WindModel() {
    var _this;
    _classCallCheck(this, WindModel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "sizeScale", 0.5);
    _defineProperty(_assertThisInitialized(_this), "frequency", new FrequencyController(7.2));
    return _this;
  }
  _createClass(WindModel, [{
    key: "render",
    value: function render(options) {
      var _this2 = this;
      this.drawColorMode(options);
      // Tip: 控制风场的平均更新频率
      this.frequency.run(function () {
        _this2.drawWind();
      });
    }
  }, {
    key: "getUninforms",
    value: function getUninforms() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _source$data,
          _source$data2,
          _source$data2$images,
          _this3 = this;
        var _ref, _ref$uMin, uMin, _ref$uMax, uMax, _ref$vMin, vMin, _ref$vMax, vMax, _ref$fadeOpacity, fadeOpacity, _ref$speedFactor, speedFactor, _ref$dropRate, dropRate, _ref$dropRateBump, dropRateBump, _ref$rampColors, rampColors, _ref$sizeScale, sizeScale, createTexture2D, source, glContext, model;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _ref = this.layer.getLayerConfig(), _ref$uMin = _ref.uMin, uMin = _ref$uMin === void 0 ? -21.32 : _ref$uMin, _ref$uMax = _ref.uMax, uMax = _ref$uMax === void 0 ? 26.8 : _ref$uMax, _ref$vMin = _ref.vMin, vMin = _ref$vMin === void 0 ? -21.57 : _ref$vMin, _ref$vMax = _ref.vMax, vMax = _ref$vMax === void 0 ? 21.42 : _ref$vMax, _ref$fadeOpacity = _ref.fadeOpacity, fadeOpacity = _ref$fadeOpacity === void 0 ? 0.996 : _ref$fadeOpacity, _ref$speedFactor = _ref.speedFactor, speedFactor = _ref$speedFactor === void 0 ? 0.25 : _ref$speedFactor, _ref$dropRate = _ref.dropRate, dropRate = _ref$dropRate === void 0 ? 0.003 : _ref$dropRate, _ref$dropRateBump = _ref.dropRateBump, dropRateBump = _ref$dropRateBump === void 0 ? 0.01 : _ref$dropRateBump, _ref$rampColors = _ref.rampColors, rampColors = _ref$rampColors === void 0 ? defaultRampColors : _ref$rampColors, _ref$sizeScale = _ref.sizeScale, sizeScale = _ref$sizeScale === void 0 ? 0.5 : _ref$sizeScale;
              createTexture2D = this.rendererService.createTexture2D;
              source = this.layer.getSource();
              this.texture = createTexture2D({
                height: 0,
                width: 0
              });
              this.cacheZoom = Math.floor(this.mapService.getZoom());
              glContext = this.rendererService.getGLContext();
              this.imageCoords = (_source$data = source.data) === null || _source$data === void 0 ? void 0 : _source$data.dataArray[0].coordinates;
              (_source$data2 = source.data) === null || _source$data2 === void 0 ? void 0 : (_source$data2$images = _source$data2.images) === null || _source$data2$images === void 0 ? void 0 : _source$data2$images.then(function (imageData) {
                var _this3$texture;
                _this3.sizeScale = sizeScale * _this3.getZoomScale();
                var _this3$getWindSize = _this3.getWindSize(),
                  imageWidth = _this3$getWindSize.imageWidth,
                  imageHeight = _this3$getWindSize.imageHeight;
                var options = {
                  glContext: glContext,
                  imageWidth: imageWidth,
                  imageHeight: imageHeight,
                  fadeOpacity: fadeOpacity,
                  speedFactor: speedFactor,
                  dropRate: dropRate,
                  dropRateBump: dropRateBump,
                  rampColors: rampColors
                };
                _this3.wind = new Wind(options);

                // imageData[0] 风场图
                _this3.wind.setWind({
                  uMin: uMin,
                  uMax: uMax,
                  vMin: vMin,
                  vMax: vMax,
                  image: imageData[0]
                });
                (_this3$texture = _this3.texture) === null || _this3$texture === void 0 ? void 0 : _this3$texture.destroy();
                _this3.texture = createTexture2D({
                  width: imageWidth,
                  height: imageHeight
                });
                _this3.layerService.reRender();
              });
              _context.next = 10;
              return this.layer.buildLayerModel({
                moduleName: 'wind',
                vertexShader: WindVert,
                fragmentShader: WindFrag,
                triangulation: RasterImageTriangulation,
                primitive: gl.TRIANGLES,
                depth: {
                  enable: false
                }
              });
            case 10:
              model = _context.sent;
              this.colorModel = model;
              return _context.abrupt("return", [model]);
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "getWindSize",
    value: function getWindSize() {
      var p1 = this.mapService.lngLatToPixel(this.imageCoords[0]);
      var p2 = this.mapService.lngLatToPixel(this.imageCoords[1]);
      var imageWidth = Math.min(Math.floor((p2.x - p1.x) * this.sizeScale), 2048);
      var imageHeight = Math.min(Math.floor((p1.y - p2.y) * this.sizeScale), 2048);
      return {
        imageWidth: imageWidth,
        imageHeight: imageHeight
      };
    }
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.initModels());
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }()
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$wind;
      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$wind = this.wind) === null || _this$wind === void 0 ? void 0 : _this$wind.destroy();
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      // point layer size;
      this.styleAttributeService.registerStyleAttribute({
        name: 'uv',
        type: AttributeType.Attribute,
        descriptor: {
          name: 'a_Uv',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: gl.DYNAMIC_DRAW,
            data: [],
            type: gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "getZoomScale",
    value: function getZoomScale() {
      return Math.min((this.cacheZoom + 4) / 30 * 2, 2);
    }
  }, {
    key: "drawWind",
    value: function drawWind() {
      if (this.wind) {
        var _ref2 = this.layer.getLayerConfig(),
          _ref2$uMin = _ref2.uMin,
          uMin = _ref2$uMin === void 0 ? -21.32 : _ref2$uMin,
          _ref2$uMax = _ref2.uMax,
          uMax = _ref2$uMax === void 0 ? 26.8 : _ref2$uMax,
          _ref2$vMin = _ref2.vMin,
          vMin = _ref2$vMin === void 0 ? -21.57 : _ref2$vMin,
          _ref2$vMax = _ref2.vMax,
          vMax = _ref2$vMax === void 0 ? 21.42 : _ref2$vMax,
          _ref2$numParticles = _ref2.numParticles,
          numParticles = _ref2$numParticles === void 0 ? 65535 : _ref2$numParticles,
          _ref2$fadeOpacity = _ref2.fadeOpacity,
          fadeOpacity = _ref2$fadeOpacity === void 0 ? 0.996 : _ref2$fadeOpacity,
          _ref2$speedFactor = _ref2.speedFactor,
          speedFactor = _ref2$speedFactor === void 0 ? 0.25 : _ref2$speedFactor,
          _ref2$dropRate = _ref2.dropRate,
          dropRate = _ref2$dropRate === void 0 ? 0.003 : _ref2$dropRate,
          _ref2$dropRateBump = _ref2.dropRateBump,
          dropRateBump = _ref2$dropRateBump === void 0 ? 0.01 : _ref2$dropRateBump,
          _ref2$rampColors = _ref2.rampColors,
          rampColors = _ref2$rampColors === void 0 ? defaultRampColors : _ref2$rampColors,
          _ref2$sizeScale = _ref2.sizeScale,
          sizeScale = _ref2$sizeScale === void 0 ? 0.5 : _ref2$sizeScale;
        var newNumParticles = numParticles;
        var currentZoom = Math.floor(this.mapService.getZoom());
        if (typeof sizeScale === 'number' && sizeScale !== this.sizeScale || currentZoom !== this.cacheZoom) {
          var zoomScale = this.getZoomScale();
          this.sizeScale = sizeScale;
          newNumParticles *= zoomScale;
          var _this$getWindSize = this.getWindSize(),
            imageWidth = _this$getWindSize.imageWidth,
            imageHeight = _this$getWindSize.imageHeight;
          this.wind.reSize(imageWidth, imageHeight);
          this.cacheZoom = currentZoom;
        }
        this.wind.updateWindDir(uMin, uMax, vMin, vMax);
        this.wind.updateParticelNum(newNumParticles);
        this.wind.updateColorRampTexture(rampColors);
        this.wind.fadeOpacity = fadeOpacity;
        this.wind.speedFactor = speedFactor;
        this.wind.dropRate = dropRate;
        this.wind.dropRateBump = dropRateBump;
        var _this$wind$draw = this.wind.draw(),
          d = _this$wind$draw.d,
          w = _this$wind$draw.w,
          h = _this$wind$draw.h;
        // 恢复 L7 渲染流程中 gl 状态
        this.rendererService.setBaseState();
        this.texture.update({
          data: d,
          width: w,
          height: h
        });
      }
    }
  }, {
    key: "drawColorMode",
    value: function drawColorMode() {
      var _this$colorModel;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _ref3 = this.layer.getLayerConfig(),
        opacity = _ref3.opacity;
      this.layerService.beforeRenderData(this.layer);
      this.layer.hooks.beforeRender.call();
      this.layerService.renderMask(this.layer.masks);
      (_this$colorModel = this.colorModel) === null || _this$colorModel === void 0 ? void 0 : _this$colorModel.draw({
        uniforms: {
          u_opacity: opacity || 1.0,
          u_texture: this.texture
        },
        blend: this.getBlend(),
        stencil: this.getStencil(options)
      });
      this.layer.hooks.afterRender.call();
    }
  }]);
  return WindModel;
}(BaseModel);
export { WindModel as default };