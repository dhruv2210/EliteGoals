import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { calculateCentroid, calculatePointsCenterAndRadius, lngLatToMeters } from '@antv/l7-utils';
import earcut from 'earcut';
// @ts-ignore
import { vec3 } from 'gl-matrix';
import { EARTH_RADIUS, EARTH_RADIUS_OUTER, EARTH_SEGMENTS, lglt2xyz, primitiveSphere } from "../earth/utils";
import ExtrudePolyline from "../utils/extrude_polyline";
import extrudePolygon, { extrude_PolygonNormal, fillPolygon } from "./shape/extrude";
import { geometryShape } from "./shape/Path";
var GeometryCache = {};

/**
 * 计算2D 填充点图顶点
 * @param feature 映射feature
 */

export function PointFillTriangulation(feature) {
  var coordinates = calculateCentroid(feature.coordinates);
  return {
    vertices: [].concat(_toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates)),
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}
/**
 * 计算2D 填充点图顶点 (地球模式)
 * @param feature 映射feature
 */
export function GlobelPointFillTriangulation(feature) {
  var coordinates = calculateCentroid(feature.coordinates);
  var xyz = lglt2xyz(coordinates);
  return {
    vertices: [].concat(_toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz)),
    indices: [0, 1, 2, 2, 3, 0],
    size: xyz.length
  };
}

/**
 * 计算3D 拉伸点图
 * @param feature 映射feature
 */
export function PointExtrudeTriangulation(feature) {
  var shape = feature.shape;
  var _getGeometry = getGeometry(shape, false),
    positions = _getGeometry.positions,
    index = _getGeometry.index,
    normals = _getGeometry.normals;
  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}

/**
 * 计算图片标注
 * @param feature 映射feature
 */
export function PointImageTriangulation(feature) {
  var coordinates = calculateCentroid(feature.coordinates);
  return {
    vertices: _toConsumableArray(coordinates),
    indices: [0],
    size: coordinates.length
  };
}

/**
 * 线三角化
 * @param feature 映射feature
 */
export function LineTriangulation(feature) {
  var coordinates = feature.coordinates,
    originCoordinates = feature.originCoordinates,
    version = feature.version;
  // let path = coordinates as number[][][] | number[][];
  // if (!Array.isArray(path[0][0])) {
  //   path = [coordinates] as number[][][];
  // }

  var line = new ExtrudePolyline({
    dash: true,
    join: 'bevel'
  });
  if (version === 'GAODE2.x') {
    // 处理高德2.0几何体构建
    var path1 = coordinates; // 计算位置
    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }
    var path2 = originCoordinates; // 计算法线
    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }
    for (var i = 0; i < path1.length; i++) {
      // 高德2.0在计算线时，需要使用经纬度计算发现，使用 customCoords.lnglatToCoords 计算的数据来计算顶点的位置
      var item1 = path1[i];
      var item2 = path2[i];
      line.extrude_gaode2(item1, item2);
    }
  } else {
    // 处理非高德2.0的几何体构建
    var path = coordinates;
    if (path[0] && !Array.isArray(path[0][0])) {
      path = [coordinates];
    }
    path.forEach(function (item) {
      line.extrude(item);
    });
  }
  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    // [ x,y,z, distance, miter,total ]
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    indexes: linebuffer.indexes,
    size: 6
  };
}
export function SimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates;
  var pos = [];
  if (!Array.isArray(coordinates[0])) {
    return {
      vertices: [],
      indices: [],
      normals: [],
      size: 6,
      count: 0
    };
  }
  var _getSimpleLineVertice = getSimpleLineVertices(coordinates),
    results = _getSimpleLineVertice.results,
    totalDistance = _getSimpleLineVertice.totalDistance;
  results.map(function (point) {
    pos.push(point[0], point[1], point[2], point[3], 0, totalDistance);
  });
  return {
    vertices: pos,
    indices: [],
    normals: [],
    size: 6,
    count: results.length
  };
}
export function TileSimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates;
  var pos = [];
  if (!Array.isArray(coordinates[0])) {
    return {
      vertices: [],
      indices: [],
      size: 4,
      count: 0
    };
  }
  var _getTileSimpleLineVer = getTileSimpleLineVertices(coordinates),
    results = _getTileSimpleLineVer.results;
  results.map(function (point) {
    pos.push(point[0], point[1], point[2], point[3]);
  });
  return {
    vertices: pos,
    indices: [],
    size: 4,
    count: results.length
  };
}
function lineSegmentDistance(b1, a1) {
  var dx = a1[0] - b1[0];
  var dy = a1[1] - b1[1];
  return Math.sqrt(dx * dx + dy * dy);
}
function pushDis(point, n) {
  if (point.length < 3) {
    point.push(0);
  }
  if (n !== undefined) {
    point.push(n);
  }
  return point;
}
function getSimpleLineVertices(coordinates) {
  var points = coordinates;
  if (Array.isArray(points) && Array.isArray(points[0]) && Array.isArray(points[0][0])) {
    // @ts-ignore
    points = coordinates.flat();
  }
  var distance = 0;
  if (points.length < 2) {
    return {
      results: points,
      totalDistance: 0
    };
  } else {
    var results = [];
    var point = pushDis(points[0], distance);
    results.push(point);
    for (var i = 1; i < points.length - 1; i++) {
      var subDistance = lineSegmentDistance(points[i - 1], points[i]);
      distance += subDistance;
      var mulPoint = pushDis(points[i], distance);
      results.push(mulPoint);
      results.push(mulPoint);
    }
    var pointDistance = lineSegmentDistance(points[points.length - 2], points[points.length - 1]);
    distance += pointDistance;
    results.push(pushDis(points[points.length - 1], distance));
    return {
      results: results,
      totalDistance: distance
    };
  }
}
function getTileSimpleLineVertices(points) {
  if (points.length < 2) {
    return {
      results: points
    };
  } else {
    var results = [];
    var point = pushDis(points[0]);
    results.push(point);
    for (var i = 1; i < points.length - 1; i++) {
      var mulPoint = pushDis(points[i]);
      results.push(mulPoint);
      results.push(mulPoint);
    }
    results.push(pushDis(points[points.length - 1]));
    return {
      results: results
    };
  }
}
export function polygonTriangulation(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = earcut.flatten(coordinates);
  var vertices = flattengeo.vertices,
    dimensions = flattengeo.dimensions,
    holes = flattengeo.holes;
  return {
    indices: earcut(vertices, holes, dimensions),
    vertices: vertices,
    size: dimensions
  };
}

// 构建几何图形（带有中心点和大小）
export function polygonTriangulationWithCenter(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = earcut.flatten(coordinates);
  var vertices = flattengeo.vertices,
    dimensions = flattengeo.dimensions,
    holes = flattengeo.holes;
  return {
    indices: earcut(vertices, holes, dimensions),
    vertices: getVerticesWithCenter(vertices),
    size: dimensions + 4
  };
}
function getVerticesWithCenter(vertices) {
  var verticesWithCenter = [];
  var _calculatePointsCente = calculatePointsCenterAndRadius(vertices),
    center = _calculatePointsCente.center,
    radius = _calculatePointsCente.radius;
  for (var i = 0; i < vertices.length; i += 2) {
    var lng = vertices[i];
    var lat = vertices[i + 1];
    verticesWithCenter.push.apply(verticesWithCenter, [lng, lat, 0].concat(_toConsumableArray(center), [radius]));
  }
  return verticesWithCenter;
}
export function PolygonExtrudeTriangulation(feature) {
  var coordinates = feature.coordinates;
  var _extrude_PolygonNorma = extrude_PolygonNormal(coordinates, true),
    positions = _extrude_PolygonNorma.positions,
    index = _extrude_PolygonNorma.index,
    normals = _extrude_PolygonNorma.normals;
  return {
    vertices: positions,
    // [ x, y, z, uv.x,uv.y ]
    indices: index,
    normals: normals,
    size: 5
  };
}
export function HeatmapGridTriangulation(feature) {
  var shape = feature.shape;
  var _getHeatmapGeometry = getHeatmapGeometry(shape),
    positions = _getHeatmapGeometry.positions,
    index = _getHeatmapGeometry.index;
  return {
    vertices: positions,
    // [ x, y, z ] 多边形顶点
    indices: index,
    size: 3
  };
}

/**
 * 图片图层顶点构造
 * @param feature 数据
 */
export function RasterImageTriangulation(feature) {
  var coordinates = feature.coordinates;
  // [ x, y, z. uv.x, uv.y]
  var positions = [].concat(_toConsumableArray(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], _toConsumableArray(coordinates[1]), [0, 1, 0], _toConsumableArray(coordinates[0]), [0, 0, 1], _toConsumableArray(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);
  var indexs = [0, 1, 2, 3, 4, 5];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}

/**
 *  计算3D弧线顶点
 * @param feature 映射数据
 * @param segNum 弧线线段数
 */
export function LineArcTriangulation(feature, segmentNumber) {
  var segNum = segmentNumber ? segmentNumber : 30;
  var coordinates = feature.coordinates;
  var positions = [];
  var indexArray = [];
  var _loop = function _loop(i) {
    // 上线两个顶点
    // [ x, y, z, sx,sy, tx,ty]
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);
    if (i !== segNum - 1) {
      indexArray.push.apply(indexArray, _toConsumableArray([0, 1, 2, 1, 3, 2].map(function (v) {
        return i * 2 + v;
      })));
    }
  };
  for (var i = 0; i < segNum; i++) {
    _loop(i);
  }
  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}

/**
 * 构建热力图密度图的顶点
 * @param feature
 * @returns
 */
export function HeatmapTriangulation(feature) {
  var coordinates = feature.coordinates;
  if (coordinates.length === 2) {
    coordinates.push(0);
  }
  var dir = addDir(-1, 1);
  var dir1 = addDir(1, 1);
  var dir2 = addDir(-1, -1);
  var dir3 = addDir(1, -1);
  // [x,y,z, dirx ,diry, weight]
  var positions = [].concat(_toConsumableArray(coordinates), _toConsumableArray(dir), _toConsumableArray(coordinates), _toConsumableArray(dir2), _toConsumableArray(coordinates), _toConsumableArray(dir3), _toConsumableArray(coordinates), _toConsumableArray(dir1));
  var indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}

/**
 * 点图层3d geomerty
 * @param shape 3D形状
 */
function getGeometry(shape) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }
  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.cylinder();
  var geometry = extrude_PolygonNormal([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}
export function computeVertexNormals(positions, indexArray) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var normals = new Float32Array(positions.length / dim * 3);
  var vA;
  var vB;
  var vC;
  var cb = vec3.create();
  var ab = vec3.create();
  var normal = vec3.create();
  for (var i = 0, li = indexArray.length; i < li; i += 3) {
    vA = indexArray[i + 0] * 3;
    vB = indexArray[i + 1] * 3;
    vC = indexArray[i + 2] * 3;
    var p1 = [positions[vA], positions[vA + 1]];
    var p2 = [positions[vB], positions[vB + 1]];
    var p3 = [positions[vC], positions[vC + 1]];
    if (needFlat) {
      p1 = lngLatToMeters(p1);
      p2 = lngLatToMeters(p2);
      p3 = lngLatToMeters(p3);
    }
    var _p = p1,
      _p2 = _slicedToArray(_p, 2),
      ax = _p2[0],
      ay = _p2[1];
    var pA = vec3.fromValues(ax, ay, positions[vA + 2]);
    var _p3 = p2,
      _p4 = _slicedToArray(_p3, 2),
      bx = _p4[0],
      by = _p4[1];
    var pB = vec3.fromValues(bx, by, positions[vB + 2]);
    var _p5 = p3,
      _p6 = _slicedToArray(_p5, 2),
      cx = _p6[0],
      cy = _p6[1];
    var pC = vec3.fromValues(cx, cy, positions[vC + 2]);
    vec3.sub(cb, pC, pB);
    vec3.sub(ab, pA, pB);
    vec3.cross(normal, cb, ab);
    normals[vA] += cb[0];
    normals[vA + 1] += cb[1];
    normals[vA + 2] += cb[2];
    normals[vB] += cb[0];
    normals[vB + 1] += cb[1];
    normals[vB + 2] += cb[2];
    normals[vC] += cb[0];
    normals[vC + 1] += cb[1];
    normals[vC + 2] += cb[2];
  }
  normalizeNormals(normals);
  return normals;
}
function normalizeNormals(normals) {
  for (var i = 0, li = normals.length; i < li; i += 3) {
    var normal = vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);
    var newNormal = vec3.create();
    vec3.normalize(newNormal, normal);
    normals.set(newNormal, i);
  }
}
export function checkIsClosed(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  return p1[0] === p2[0] && p1[1] === p2[1];
}
function getHeatmapGeometry(shape) {
  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];
  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.circle();
  var geometry = shape3d.indexOf(shape) === -1 ? fillPolygon([path]) : extrudePolygon([path]);
  // const geometry = fillPolygon([path]);
  return geometry;
}
// 热力图计算范围
function addDir(dirX, dirY) {
  var x = (dirX + 1) / 2;
  var y = (dirY + 1) / 2;
  return [x, y];
}

/**
 * 构建地球三角网格
 * @returns
 */
export function earthTriangulation() {
  var earthmesh = primitiveSphere(EARTH_RADIUS, {
    segments: EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
    indicesArr = earthmesh.indicesArr,
    normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
export function earthOuterTriangulation() {
  var earthmesh = primitiveSphere(EARTH_RADIUS + EARTH_RADIUS_OUTER, {
    segments: EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
    indicesArr = earthmesh.indicesArr,
    normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}