import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { createLayerContainer } from '@antv/l7-core';
import { updateLayersConfig } from "../style/utils";
export var Base = /*#__PURE__*/function () {
  function Base() {
    _classCallCheck(this, Base);
    _defineProperty(this, "tileCache", new Map());
    _defineProperty(this, "tileLayerCache", new Map());
  }
  _createClass(Base, [{
    key: "initTileLayers",
    value: function () {
      var _initTileLayers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(layers, tile) {
        var _this = this;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", Promise.all(layers.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(layer) {
                  var container;
                  return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        container = createLayerContainer(_this.parent.sceneContainer);
                        layer.setContainer(container, _this.parent.sceneContainer);
                        _context.next = 4;
                        return layer.init();
                      case 4:
                        _this.addChild(layer);
                        tile.layerLoad();
                        _this.render();
                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function (_x3) {
                  return _ref.apply(this, arguments);
                };
              }())));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function initTileLayers(_x, _x2) {
        return _initTileLayers.apply(this, arguments);
      }
      return initTileLayers;
    }()
  }, {
    key: "render",
    value: function render() {
      this.parent.renderLayers();
    }
  }, {
    key: "hasTile",
    value: function hasTile(tile) {
      return this.tileCache.has(tile.key);
    }

    // 添加图层
  }, {
    key: "addTile",
    value: function () {
      var _addTile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tile) {
        var layerCollections;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!this.hasTile(tile)) {
                _context3.next = 2;
                break;
              }
              return _context3.abrupt("return", {
                layers: []
              });
            case 2:
              // 存储当前 tile
              this.tileCache.set(tile.key, tile);

              // 创建 tile 对应的 layers
              layerCollections = this.tileFactory.createTile(tile, this.initOptions); // // 初始化图层
              _context3.next = 6;
              return this.initTileLayers(layerCollections.layers, tile);
            case 6:
              this.tileLayerCache.set(tile.key, layerCollections.layers);
              // const visible =  tile.parent ? tile.parent.children.every(t=>this.tileLayerCache.has(t.key)) : true
              // tile.parent?.children.forEach((t)=>{
              //   updateLayersConfig(this.getLayers(t),'visible',visible)
              // })
              return _context3.abrupt("return", layerCollections);
            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function addTile(_x4) {
        return _addTile.apply(this, arguments);
      }
      return addTile;
    }()
  }, {
    key: "removeTile",
    value: function removeTile(tile) {
      this.tileCache.delete(tile.key);
      var layers = this.tileLayerCache.get(tile.key);
      this.tileLayerCache.delete(tile.key);
      this.removeLayers(layers, false);
    }
  }, {
    key: "addChild",
    value: function addChild(layer) {
      this.children.push(layer);
    }
  }, {
    key: "addChildren",
    value: function addChildren(layers) {
      var _this$children;
      (_this$children = this.children).push.apply(_this$children, _toConsumableArray(layers));
    }
  }, {
    key: "removeLayers",
    value: function removeLayers() {
      var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var refresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.children = this.children.filter(function (child) {
        return !layers.includes(child);
      });
      layers.map(function (layer) {
        return layer.destroy(refresh);
      });
    }
  }, {
    key: "removeChild",
    value: function removeChild(layer) {
      var layerIndex = this.children.indexOf(layer);
      if (layerIndex > -1) {
        this.children.splice(layerIndex, 1);
      }
      layer.destroy();
    }
  }, {
    key: "getLayers",
    value: function getLayers(tile) {
      if (!tile) {
        return [];
      }
      return this.tileLayerCache.get(tile.key) || [];
    }
  }, {
    key: "getChild",
    value: function getChild(layerID) {
      return this.children.filter(function (child) {
        return child.id === layerID;
      })[0];
    }
  }, {
    key: "clearChild",
    value: function clearChild() {
      this.children.forEach(function (layer) {
        layer.destroy();
      });
      this.children.slice(0, this.children.length);
    }
  }, {
    key: "hasChild",
    value: function hasChild(layer) {
      return this.children.includes(layer);
    }
  }, {
    key: "initTileFactory",
    value: function initTileFactory() {
      // this.tileFactory = new TileFactory({
      //   parent: this.parent,
      //   mapService: this.mapService,
      //   rendererService: this.rendererService,
      // });
    }
  }, {
    key: "getSourceLayer",
    value: function getSourceLayer(parentParserType, sourceLayer) {
      if (parentParserType === 'geojsonvt') {
        return 'geojsonvt';
      } else if (parentParserType === 'testTile') {
        return 'testTile';
      } else {
        return sourceLayer;
      }
    }
  }, {
    key: "updateTileVisible",
    value: function updateTileVisible(tile, layerService) {
      var layers = this.getLayers(tile);
      if (layers.length === 0) {
        return;
      }
      if (tile.isVisible) {
        // 如果可见直接进行渲染，父级发
        updateLayersConfig(layers, 'visible', tile.isVisible);
      } else {
        // 如果不可见，放大，等到子瓦片渲染完成，缩小：父级渲染成功
        // console.log('updateTileVisible',`${tile.x}_${tile.y}_${tile.z}`,tile.isVisible)
        // console.log(tile);
        // console.log(`子瓦片${tile.x}/${tile.y}/${tile.z}`,tile.children.length)
        // tile.children.forEach((t)=>{
        //   console.log(`${t.x}/${t.y}/${t.z}`)
        // })
        updateLayersConfig(layers, 'visible', tile.isVisible);
      }

      // this.listenLoad(tile, () => {
      //   this.isTileAllLoad(tile) && updateLayersConfig(layers, 'visible', tile.isVisible);
      // })
    }
  }, {
    key: "listenLoad",
    value: function listenLoad(tile, callback) {
      var _tile$parent;
      tile.once('layerLoaded', function () {
        callback();
      });
      tile.children.map(function (childTile) {
        childTile.once('layerLoaded', function () {
          callback();
        });
      });
      (_tile$parent = tile.parent) === null || _tile$parent === void 0 ? void 0 : _tile$parent.once('layerLoaded', function () {
        callback();
      });
    }
  }, {
    key: "isTileLoaded",
    value: function isTileLoaded(tile) {
      if (tile.isLoad) {
        return true;
      }
      var isLoad = this.getLayers(tile).length === tile.loadedLayers;
      tile.isLoad = isLoad;
      return isLoad;
    }
  }, {
    key: "isTileChildLoaded",
    value: function isTileChildLoaded(tile) {
      var _this2 = this;
      if (tile.isChildLoad) {
        return true;
      }
      var children = tile.children;
      var isLoad = children.filter(function (child) {
        return _this2.isTileLoaded(child);
      }).length === children.length;
      tile.isChildLoad = isLoad;
      return isLoad;
    }
  }, {
    key: "isTileParentLoaded",
    value: function isTileParentLoaded(tile) {
      var parent = tile.parent;
      if (!parent) {
        return true;
      } else {
        return this.isTileLoaded(parent);
      }
    }
  }, {
    key: "isTileAllLoad",
    value: function isTileAllLoad(tile) {
      var tileLoaded = this.isTileLoaded(tile);
      var tileChildLoaded = this.isTileChildLoaded(tile);
      var tileParentLoaded = this.isTileParentLoaded(tile);
      return tileLoaded && tileChildLoaded && tileParentLoaded;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.tileCache.clear();
      this.tileLayerCache.clear();
    }
  }]);
  return Base;
}();