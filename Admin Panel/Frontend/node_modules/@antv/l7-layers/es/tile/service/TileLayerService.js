import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import 'reflect-metadata';
export var TileLayerService = /*#__PURE__*/function () {
  /**
   * tileResource 用于存储瓦片的全局资源
   */

  function TileLayerService(_ref) {
    var rendererService = _ref.rendererService,
      layerService = _ref.layerService,
      parent = _ref.parent;
    _classCallCheck(this, TileLayerService);
    _defineProperty(this, "tileResource", new Map());
    _defineProperty(this, "layerTiles", []);
    this.rendererService = rendererService;
    this.layerService = layerService;
    this.parent = parent;
  }
  _createClass(TileLayerService, [{
    key: "tiles",
    get: function get() {
      return this.layerTiles;
    }
  }, {
    key: "hasTile",
    value: function hasTile(tileKey) {
      return this.layerTiles.some(function (tile) {
        return tile.key === tileKey;
      });
    }
  }, {
    key: "addTile",
    value: function addTile(tile) {
      this.layerTiles.push(tile);
    }
  }, {
    key: "getTile",
    value: function getTile(tileKey) {
      return this.layerTiles.find(function (tile) {
        return tile.key === tileKey;
      });
    }
  }, {
    key: "getVisibleTileBylngLat",
    value: function getVisibleTileBylngLat(lngLat) {
      // 加载完成 & 可见 & 鼠标选中
      return this.layerTiles.find(function (tile) {
        return tile.isLoaded && tile.visible && tile.lnglatInBounds(lngLat);
      });
    }
  }, {
    key: "removeTile",
    value: function removeTile(tileKey) {
      var index = this.layerTiles.findIndex(function (t) {
        return t.key === tileKey;
      });
      var tile = this.layerTiles.splice(index, 1);
      if (tile[0]) {
        tile[0].destroy();
      }
    }
  }, {
    key: "updateTileVisible",
    value: function updateTileVisible(sourceTile) {
      var tile = this.getTile(sourceTile.key);
      // if(sourceTile.isVisible) {
      //   // 不可见 => 可见 兄弟节点加载完成
      //   if(sourceTile.parent) {
      //     const flag = this.isChildrenLoaded(sourceTile.parent)
      //     tile?.updateVisible(flag);
      //   } else {
      //     tile?.updateVisible(true);
      //   }

      // } else {
      //    // 可见 => 不可见 兄弟节点加载完成
      //    if(sourceTile.parent) {
      //     const flag = this.isChildrenLoaded(sourceTile.parent)
      //     tile?.updateVisible(!flag);
      //   } else {
      //     tile?.updateVisible(false);
      //   }
      // }

      tile === null || tile === void 0 ? void 0 : tile.updateVisible(sourceTile.isVisible);
    }
  }, {
    key: "isParentLoaded",
    value: function isParentLoaded(sourceTile) {
      var parentTile = sourceTile.parent;
      if (!parentTile) {
        return true;
      }
      var tile = this.getTile(parentTile === null || parentTile === void 0 ? void 0 : parentTile.key);
      if (tile !== null && tile !== void 0 && tile.isLoaded) {
        // 递归父级
        return true;
      }
      return false;
    }
  }, {
    key: "isChildrenLoaded",
    value: function isChildrenLoaded(sourceTile) {
      var _this = this;
      var childrenTile = sourceTile === null || sourceTile === void 0 ? void 0 : sourceTile.children;
      if (childrenTile.length === 0) {
        return true;
      }
      return childrenTile.some(function (tile) {
        var tileLayer = _this.getTile(tile === null || tile === void 0 ? void 0 : tile.key);
        return (tileLayer === null || tileLayer === void 0 ? void 0 : tileLayer.isLoaded) === false;
      });
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;
        var layers, renders;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              layers = this.getRenderLayers();
              renders = layers.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(layer) {
                  return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return _this2.layerService.renderTileLayer(layer);
                      case 2:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function (_x) {
                  return _ref2.apply(this, arguments);
                };
              }());
              Promise.all(renders);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function render() {
        return _render.apply(this, arguments);
      }
      return render;
    }()
  }, {
    key: "getRenderLayers",
    value: function getRenderLayers() {
      var tileList = this.layerTiles.filter(function (t) {
        return t.visible && t.isLoaded;
      });
      var layers = [];
      tileList.map(function (tile) {
        return layers.push.apply(layers, _toConsumableArray(tile.getLayers()));
      });
      return layers;
    }
  }, {
    key: "getLayers",
    value: function getLayers() {
      var tileList = this.layerTiles.filter(function (t) {
        return t.isLoaded;
      });
      var layers = [];
      tileList.map(function (tile) {
        return layers.push.apply(layers, _toConsumableArray(tile.getLayers()));
      });
      return layers;
    }
  }, {
    key: "getTiles",
    value: function getTiles() {
      return this.layerTiles;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.layerTiles.forEach(function (t) {
        return t.destroy();
      });
      this.tileResource.clear();
    }
  }]);
  return TileLayerService;
}();