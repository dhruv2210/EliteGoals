"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EARTH_SEGMENTS = exports.EARTH_RADIUS_OUTER = exports.EARTH_RADIUS = void 0;
exports.lglt2xyz = lglt2xyz;
exports.primitiveSphere = primitiveSphere;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _glMatrix = require("gl-matrix");
// 该文件专门记录地球模式的数值

// 地球网格半径
var EARTH_RADIUS = 100;
exports.EARTH_RADIUS = EARTH_RADIUS;
var EARTH_SEGMENTS = 36;
exports.EARTH_SEGMENTS = EARTH_SEGMENTS;
var EARTH_RADIUS_OUTER = 40;

/**
 * 角度转弧度
 * @param deg
 * @returns
 */
exports.EARTH_RADIUS_OUTER = EARTH_RADIUS_OUTER;
function torad(deg) {
  return deg / 180 * Math.acos(-1);
}
/**
 * 经纬度转xyz
 * @param longitude 经度
 * @param latitude 纬度
 * @param radius 半径
 */
function lglt2xyz(lnglat) {
  // TODO: + Math.PI/2 是为了对齐坐标
  var lng = torad(lnglat[0]) + Math.PI / 2;
  var lat = torad(lnglat[1]);

  // TODO: 手动增加一些偏移，减轻面的冲突
  var radius = EARTH_RADIUS + Math.random() * 0.4;
  var z = radius * Math.cos(lat) * Math.cos(lng);
  var x = radius * Math.cos(lat) * Math.sin(lng);
  var y = radius * Math.sin(lat);
  return [x, y, z];
}

/**
 * 构建地球球体网格
 * @param radius
 * @param opt
 * @returns
 */
function primitiveSphere(radius, opt) {
  var matRotY = _glMatrix.mat4.create();
  var matRotZ = _glMatrix.mat4.create();
  var up = _glMatrix.vec3.fromValues(0, 1, 0);
  var tmpVec3 = _glMatrix.vec3.fromValues(0, 0, 0);
  opt = opt || {};
  radius = typeof radius !== 'undefined' ? radius : 1;
  var segments = typeof opt.segments !== 'undefined' ? opt.segments : 32;
  var totalZRotationSteps = 2 + segments;
  var totalYRotationSteps = 2 * totalZRotationSteps;
  var indices = [];
  var indicesArr = [];
  var positions = [];
  var positionsArr = [];
  var normalArr = [];
  var uvs = [];
  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    var normalizedZ = zRotationStep / totalZRotationSteps;
    var angleZ = normalizedZ * Math.PI;
    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      var normalizedY = yRotationStep / totalYRotationSteps;
      var angleY = normalizedY * Math.PI * 2;
      _glMatrix.mat4.identity(matRotZ);
      _glMatrix.mat4.rotateZ(matRotZ, matRotZ, -angleZ);
      _glMatrix.mat4.identity(matRotY);
      _glMatrix.mat4.rotateY(matRotY, matRotY, angleY);
      _glMatrix.vec3.transformMat4(tmpVec3, up, matRotZ);
      _glMatrix.vec3.transformMat4(tmpVec3, tmpVec3, matRotY);
      _glMatrix.vec3.scale(tmpVec3, tmpVec3, -radius);
      positions.push(tmpVec3.slice());
      positionsArr.push.apply(positionsArr, (0, _toConsumableArray2.default)(tmpVec3.slice()));
      _glMatrix.vec3.normalize(tmpVec3, tmpVec3);
      normalArr.push.apply(normalArr, (0, _toConsumableArray2.default)(tmpVec3.slice()));
      uvs.push([normalizedY, 1 - normalizedZ]);

      // position 和 uv 一起存储
      positionsArr.push(normalizedY, 1 - normalizedZ);
    }
    if (zRotationStep > 0) {
      var verticesCount = positions.length;
      var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);
      for (; firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        indices.push([firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1]);
        indicesArr.push(firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1);
        indices.push([firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2]);
        indicesArr.push(firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2);
      }
    }
  }
  return {
    cells: indices,
    positions: positions,
    uvs: uvs,
    positionsArr: positionsArr,
    indicesArr: indicesArr,
    normalArr: normalArr
  };
}