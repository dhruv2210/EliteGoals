"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _l7Core = require("@antv/l7-core");
var _l7Source = _interopRequireDefault(require("@antv/l7-source"));
var _inversify = require("inversify");
require("reflect-metadata");
var _dec, _class;
var DataSourcePlugin = (_dec = (0, _inversify.injectable)(), _dec(_class = /*#__PURE__*/function () {
  function DataSourcePlugin() {
    (0, _classCallCheck2.default)(this, DataSourcePlugin);
  }
  (0, _createClass2.default)(DataSourcePlugin, [{
    key: "apply",
    value: function apply(layer) {
      var _this = this;
      this.mapService = layer.getContainer().get(_l7Core.TYPES.IMapService);
      layer.hooks.init.tapPromise('DataSourcePlugin', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var source, _ref2, data, options;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              layer.log(_l7Core.IDebugLog.SourceInitStart, _l7Core.ILayerStage.INIT);
              source = layer.getSource();
              if (!source) {
                // Tip: 用户没有传入 source 的时候使用图层的默认数据
                _ref2 = layer.sourceOption || layer.defaultSourceConfig, data = _ref2.data, options = _ref2.options;
                source = new _l7Source.default(data, options);
                layer.setSource(source);
              }
              if (!source.inited) {
                _context.next = 8;
                break;
              }
              _this.updateClusterData(layer);
              layer.log(_l7Core.IDebugLog.SourceInitEnd, _l7Core.ILayerStage.INIT);
              _context.next = 10;
              break;
            case 8:
              _context.next = 10;
              return new Promise(function (resolve) {
                source.on('update', function (e) {
                  if (e.type === 'inited') {
                    _this.updateClusterData(layer);
                    layer.log(_l7Core.IDebugLog.SourceInitEnd, _l7Core.ILayerStage.INIT);
                  }
                  resolve(null);
                });
              });
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));

      // 检测数据是否需要更新
      layer.hooks.beforeRenderData.tapPromise('DataSourcePlugin', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var neeUpdateCluster, dataSourceNeedUpdate, needScale;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              neeUpdateCluster = _this.updateClusterData(layer);
              dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;
              layer.dataState.dataSourceNeedUpdate = false;
              needScale = neeUpdateCluster || dataSourceNeedUpdate;
              return _context2.abrupt("return", needScale);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      })));
    }
  }, {
    key: "updateClusterData",
    value: function updateClusterData(layer) {
      // Tip: 矢量瓦片不需要进行聚合操作
      if (layer.isTileLayer || layer.tileLayer || !layer.getSource()) {
        return false;
      }
      var source = layer.getSource();
      var cluster = source.cluster;
      var _source$clusterOption = source.clusterOptions.zoom,
        zoom = _source$clusterOption === void 0 ? 0 : _source$clusterOption;
      var newZoom = this.mapService.getZoom() - 1;
      var dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;
      if (cluster && dataSourceNeedUpdate) {
        // 数据发生更新
        source.updateClusterData(Math.floor(newZoom));
      }
      // 如果 dataSource 有更新，跳过 zoom 的判断，直接更新一次
      if (cluster && Math.abs(layer.clusterZoom - newZoom) >= 1) {
        if (zoom !== Math.floor(newZoom)) {
          source.updateClusterData(Math.floor(newZoom));
        }
        layer.clusterZoom = newZoom;
        return true;
      }
      return false;
    }
  }]);
  return DataSourcePlugin;
}()) || _class);
exports.default = DataSourcePlugin;