"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlobelPointFillTriangulation = GlobelPointFillTriangulation;
exports.HeatmapGridTriangulation = HeatmapGridTriangulation;
exports.HeatmapTriangulation = HeatmapTriangulation;
exports.LineArcTriangulation = LineArcTriangulation;
exports.LineTriangulation = LineTriangulation;
exports.PointExtrudeTriangulation = PointExtrudeTriangulation;
exports.PointFillTriangulation = PointFillTriangulation;
exports.PointImageTriangulation = PointImageTriangulation;
exports.PolygonExtrudeTriangulation = PolygonExtrudeTriangulation;
exports.RasterImageTriangulation = RasterImageTriangulation;
exports.SimpleLineTriangulation = SimpleLineTriangulation;
exports.TileSimpleLineTriangulation = TileSimpleLineTriangulation;
exports.checkIsClosed = checkIsClosed;
exports.computeVertexNormals = computeVertexNormals;
exports.earthOuterTriangulation = earthOuterTriangulation;
exports.earthTriangulation = earthTriangulation;
exports.polygonTriangulation = polygonTriangulation;
exports.polygonTriangulationWithCenter = polygonTriangulationWithCenter;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _l7Utils = require("@antv/l7-utils");
var _earcut = _interopRequireDefault(require("earcut"));
var _glMatrix = require("gl-matrix");
var _utils = require("../earth/utils");
var _extrude_polyline = _interopRequireDefault(require("../utils/extrude_polyline"));
var _extrude = _interopRequireWildcard(require("./shape/extrude"));
var _Path = require("./shape/Path");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
// @ts-ignore

var GeometryCache = {};

/**
 * 计算2D 填充点图顶点
 * @param feature 映射feature
 */

function PointFillTriangulation(feature) {
  var coordinates = (0, _l7Utils.calculateCentroid)(feature.coordinates);
  return {
    vertices: [].concat((0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates)),
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}
/**
 * 计算2D 填充点图顶点 (地球模式)
 * @param feature 映射feature
 */
function GlobelPointFillTriangulation(feature) {
  var coordinates = (0, _l7Utils.calculateCentroid)(feature.coordinates);
  var xyz = (0, _utils.lglt2xyz)(coordinates);
  return {
    vertices: [].concat((0, _toConsumableArray2.default)(xyz), (0, _toConsumableArray2.default)(xyz), (0, _toConsumableArray2.default)(xyz), (0, _toConsumableArray2.default)(xyz)),
    indices: [0, 1, 2, 2, 3, 0],
    size: xyz.length
  };
}

/**
 * 计算3D 拉伸点图
 * @param feature 映射feature
 */
function PointExtrudeTriangulation(feature) {
  var shape = feature.shape;
  var _getGeometry = getGeometry(shape, false),
    positions = _getGeometry.positions,
    index = _getGeometry.index,
    normals = _getGeometry.normals;
  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}

/**
 * 计算图片标注
 * @param feature 映射feature
 */
function PointImageTriangulation(feature) {
  var coordinates = (0, _l7Utils.calculateCentroid)(feature.coordinates);
  return {
    vertices: (0, _toConsumableArray2.default)(coordinates),
    indices: [0],
    size: coordinates.length
  };
}

/**
 * 线三角化
 * @param feature 映射feature
 */
function LineTriangulation(feature) {
  var coordinates = feature.coordinates,
    originCoordinates = feature.originCoordinates,
    version = feature.version;
  // let path = coordinates as number[][][] | number[][];
  // if (!Array.isArray(path[0][0])) {
  //   path = [coordinates] as number[][][];
  // }

  var line = new _extrude_polyline.default({
    dash: true,
    join: 'bevel'
  });
  if (version === 'GAODE2.x') {
    // 处理高德2.0几何体构建
    var path1 = coordinates; // 计算位置
    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }
    var path2 = originCoordinates; // 计算法线
    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }
    for (var i = 0; i < path1.length; i++) {
      // 高德2.0在计算线时，需要使用经纬度计算发现，使用 customCoords.lnglatToCoords 计算的数据来计算顶点的位置
      var item1 = path1[i];
      var item2 = path2[i];
      line.extrude_gaode2(item1, item2);
    }
  } else {
    // 处理非高德2.0的几何体构建
    var path = coordinates;
    if (path[0] && !Array.isArray(path[0][0])) {
      path = [coordinates];
    }
    path.forEach(function (item) {
      line.extrude(item);
    });
  }
  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    // [ x,y,z, distance, miter,total ]
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    indexes: linebuffer.indexes,
    size: 6
  };
}
function SimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates;
  var pos = [];
  if (!Array.isArray(coordinates[0])) {
    return {
      vertices: [],
      indices: [],
      normals: [],
      size: 6,
      count: 0
    };
  }
  var _getSimpleLineVertice = getSimpleLineVertices(coordinates),
    results = _getSimpleLineVertice.results,
    totalDistance = _getSimpleLineVertice.totalDistance;
  results.map(function (point) {
    pos.push(point[0], point[1], point[2], point[3], 0, totalDistance);
  });
  return {
    vertices: pos,
    indices: [],
    normals: [],
    size: 6,
    count: results.length
  };
}
function TileSimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates;
  var pos = [];
  if (!Array.isArray(coordinates[0])) {
    return {
      vertices: [],
      indices: [],
      size: 4,
      count: 0
    };
  }
  var _getTileSimpleLineVer = getTileSimpleLineVertices(coordinates),
    results = _getTileSimpleLineVer.results;
  results.map(function (point) {
    pos.push(point[0], point[1], point[2], point[3]);
  });
  return {
    vertices: pos,
    indices: [],
    size: 4,
    count: results.length
  };
}
function lineSegmentDistance(b1, a1) {
  var dx = a1[0] - b1[0];
  var dy = a1[1] - b1[1];
  return Math.sqrt(dx * dx + dy * dy);
}
function pushDis(point, n) {
  if (point.length < 3) {
    point.push(0);
  }
  if (n !== undefined) {
    point.push(n);
  }
  return point;
}
function getSimpleLineVertices(coordinates) {
  var points = coordinates;
  if (Array.isArray(points) && Array.isArray(points[0]) && Array.isArray(points[0][0])) {
    // @ts-ignore
    points = coordinates.flat();
  }
  var distance = 0;
  if (points.length < 2) {
    return {
      results: points,
      totalDistance: 0
    };
  } else {
    var results = [];
    var point = pushDis(points[0], distance);
    results.push(point);
    for (var i = 1; i < points.length - 1; i++) {
      var subDistance = lineSegmentDistance(points[i - 1], points[i]);
      distance += subDistance;
      var mulPoint = pushDis(points[i], distance);
      results.push(mulPoint);
      results.push(mulPoint);
    }
    var pointDistance = lineSegmentDistance(points[points.length - 2], points[points.length - 1]);
    distance += pointDistance;
    results.push(pushDis(points[points.length - 1], distance));
    return {
      results: results,
      totalDistance: distance
    };
  }
}
function getTileSimpleLineVertices(points) {
  if (points.length < 2) {
    return {
      results: points
    };
  } else {
    var results = [];
    var point = pushDis(points[0]);
    results.push(point);
    for (var i = 1; i < points.length - 1; i++) {
      var mulPoint = pushDis(points[i]);
      results.push(mulPoint);
      results.push(mulPoint);
    }
    results.push(pushDis(points[points.length - 1]));
    return {
      results: results
    };
  }
}
function polygonTriangulation(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = _earcut.default.flatten(coordinates);
  var vertices = flattengeo.vertices,
    dimensions = flattengeo.dimensions,
    holes = flattengeo.holes;
  return {
    indices: (0, _earcut.default)(vertices, holes, dimensions),
    vertices: vertices,
    size: dimensions
  };
}

// 构建几何图形（带有中心点和大小）
function polygonTriangulationWithCenter(feature) {
  var coordinates = feature.coordinates;
  var flattengeo = _earcut.default.flatten(coordinates);
  var vertices = flattengeo.vertices,
    dimensions = flattengeo.dimensions,
    holes = flattengeo.holes;
  return {
    indices: (0, _earcut.default)(vertices, holes, dimensions),
    vertices: getVerticesWithCenter(vertices),
    size: dimensions + 4
  };
}
function getVerticesWithCenter(vertices) {
  var verticesWithCenter = [];
  var _calculatePointsCente = (0, _l7Utils.calculatePointsCenterAndRadius)(vertices),
    center = _calculatePointsCente.center,
    radius = _calculatePointsCente.radius;
  for (var i = 0; i < vertices.length; i += 2) {
    var lng = vertices[i];
    var lat = vertices[i + 1];
    verticesWithCenter.push.apply(verticesWithCenter, [lng, lat, 0].concat((0, _toConsumableArray2.default)(center), [radius]));
  }
  return verticesWithCenter;
}
function PolygonExtrudeTriangulation(feature) {
  var coordinates = feature.coordinates;
  var _extrude_PolygonNorma = (0, _extrude.extrude_PolygonNormal)(coordinates, true),
    positions = _extrude_PolygonNorma.positions,
    index = _extrude_PolygonNorma.index,
    normals = _extrude_PolygonNorma.normals;
  return {
    vertices: positions,
    // [ x, y, z, uv.x,uv.y ]
    indices: index,
    normals: normals,
    size: 5
  };
}
function HeatmapGridTriangulation(feature) {
  var shape = feature.shape;
  var _getHeatmapGeometry = getHeatmapGeometry(shape),
    positions = _getHeatmapGeometry.positions,
    index = _getHeatmapGeometry.index;
  return {
    vertices: positions,
    // [ x, y, z ] 多边形顶点
    indices: index,
    size: 3
  };
}

/**
 * 图片图层顶点构造
 * @param feature 数据
 */
function RasterImageTriangulation(feature) {
  var coordinates = feature.coordinates;
  // [ x, y, z. uv.x, uv.y]
  var positions = [].concat((0, _toConsumableArray2.default)(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], (0, _toConsumableArray2.default)(coordinates[1]), [0, 1, 0], (0, _toConsumableArray2.default)(coordinates[0]), [0, 0, 1], (0, _toConsumableArray2.default)(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);
  var indexs = [0, 1, 2, 3, 4, 5];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}

/**
 *  计算3D弧线顶点
 * @param feature 映射数据
 * @param segNum 弧线线段数
 */
function LineArcTriangulation(feature, segmentNumber) {
  var segNum = segmentNumber ? segmentNumber : 30;
  var coordinates = feature.coordinates;
  var positions = [];
  var indexArray = [];
  var _loop = function _loop(i) {
    // 上线两个顶点
    // [ x, y, z, sx,sy, tx,ty]
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);
    if (i !== segNum - 1) {
      indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)([0, 1, 2, 1, 3, 2].map(function (v) {
        return i * 2 + v;
      })));
    }
  };
  for (var i = 0; i < segNum; i++) {
    _loop(i);
  }
  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}

/**
 * 构建热力图密度图的顶点
 * @param feature
 * @returns
 */
function HeatmapTriangulation(feature) {
  var coordinates = feature.coordinates;
  if (coordinates.length === 2) {
    coordinates.push(0);
  }
  var dir = addDir(-1, 1);
  var dir1 = addDir(1, 1);
  var dir2 = addDir(-1, -1);
  var dir3 = addDir(1, -1);
  // [x,y,z, dirx ,diry, weight]
  var positions = [].concat((0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir2), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir3), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir1));
  var indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}

/**
 * 点图层3d geomerty
 * @param shape 3D形状
 */
function getGeometry(shape) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }
  var path = _Path.geometryShape[shape] ? _Path.geometryShape[shape]() : _Path.geometryShape.cylinder();
  var geometry = (0, _extrude.extrude_PolygonNormal)([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}
function computeVertexNormals(positions, indexArray) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var normals = new Float32Array(positions.length / dim * 3);
  var vA;
  var vB;
  var vC;
  var cb = _glMatrix.vec3.create();
  var ab = _glMatrix.vec3.create();
  var normal = _glMatrix.vec3.create();
  for (var i = 0, li = indexArray.length; i < li; i += 3) {
    vA = indexArray[i + 0] * 3;
    vB = indexArray[i + 1] * 3;
    vC = indexArray[i + 2] * 3;
    var p1 = [positions[vA], positions[vA + 1]];
    var p2 = [positions[vB], positions[vB + 1]];
    var p3 = [positions[vC], positions[vC + 1]];
    if (needFlat) {
      p1 = (0, _l7Utils.lngLatToMeters)(p1);
      p2 = (0, _l7Utils.lngLatToMeters)(p2);
      p3 = (0, _l7Utils.lngLatToMeters)(p3);
    }
    var _p = p1,
      _p2 = (0, _slicedToArray2.default)(_p, 2),
      ax = _p2[0],
      ay = _p2[1];
    var pA = _glMatrix.vec3.fromValues(ax, ay, positions[vA + 2]);
    var _p3 = p2,
      _p4 = (0, _slicedToArray2.default)(_p3, 2),
      bx = _p4[0],
      by = _p4[1];
    var pB = _glMatrix.vec3.fromValues(bx, by, positions[vB + 2]);
    var _p5 = p3,
      _p6 = (0, _slicedToArray2.default)(_p5, 2),
      cx = _p6[0],
      cy = _p6[1];
    var pC = _glMatrix.vec3.fromValues(cx, cy, positions[vC + 2]);
    _glMatrix.vec3.sub(cb, pC, pB);
    _glMatrix.vec3.sub(ab, pA, pB);
    _glMatrix.vec3.cross(normal, cb, ab);
    normals[vA] += cb[0];
    normals[vA + 1] += cb[1];
    normals[vA + 2] += cb[2];
    normals[vB] += cb[0];
    normals[vB + 1] += cb[1];
    normals[vB + 2] += cb[2];
    normals[vC] += cb[0];
    normals[vC + 1] += cb[1];
    normals[vC + 2] += cb[2];
  }
  normalizeNormals(normals);
  return normals;
}
function normalizeNormals(normals) {
  for (var i = 0, li = normals.length; i < li; i += 3) {
    var normal = _glMatrix.vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);
    var newNormal = _glMatrix.vec3.create();
    _glMatrix.vec3.normalize(newNormal, normal);
    normals.set(newNormal, i);
  }
}
function checkIsClosed(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  return p1[0] === p2[0] && p1[1] === p2[1];
}
function getHeatmapGeometry(shape) {
  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];
  var path = _Path.geometryShape[shape] ? _Path.geometryShape[shape]() : _Path.geometryShape.circle();
  var geometry = shape3d.indexOf(shape) === -1 ? (0, _extrude.fillPolygon)([path]) : (0, _extrude.default)([path]);
  // const geometry = fillPolygon([path]);
  return geometry;
}
// 热力图计算范围
function addDir(dirX, dirY) {
  var x = (dirX + 1) / 2;
  var y = (dirY + 1) / 2;
  return [x, y];
}

/**
 * 构建地球三角网格
 * @returns
 */
function earthTriangulation() {
  var earthmesh = (0, _utils.primitiveSphere)(_utils.EARTH_RADIUS, {
    segments: _utils.EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
    indicesArr = earthmesh.indicesArr,
    normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
function earthOuterTriangulation() {
  var earthmesh = (0, _utils.primitiveSphere)(_utils.EARTH_RADIUS + _utils.EARTH_RADIUS_OUTER, {
    segments: _utils.EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
    indicesArr = earthmesh.indicesArr,
    normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}