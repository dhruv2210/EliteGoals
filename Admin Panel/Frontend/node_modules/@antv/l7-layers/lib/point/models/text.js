"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextTriangulation = TextTriangulation;
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _l7Core = require("@antv/l7-core");
var _l7Utils = require("@antv/l7-utils");
var _lodash = require("lodash");
var _BaseModel2 = _interopRequireDefault(require("../../core/BaseModel"));
var _collisionIndex = _interopRequireDefault(require("../../utils/collision-index"));
var _symbolLayout = require("../../utils/symbol-layout");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* babel-plugin-inline-import '../shaders/text_frag.glsl' */
var textFrag = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 48.0\nuniform sampler2D u_sdf_map;\nuniform float u_gamma_scale : 0.5;\n// uniform float u_font_size : 24.0;\nuniform float u_opacity : 1.0;\nuniform vec4 u_stroke_color : [0, 0, 0, 1];\nuniform float u_stroke_width : 2.0;\nuniform float u_halo_blur : 0.5;\nuniform float u_DevicePixelRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying float v_fontScale;\n\nvarying mat4 styleMappingMat; // \u4F20\u9012\u4ECE\u7247\u5143\u4E2D\u4F20\u9012\u7684\u6620\u5C04\u6570\u636E\n\n#pragma include \"picking\"\nvoid main() {\n  // get style data mapping\n  float opacity = styleMappingMat[0][0];\n  float strokeWidth = styleMappingMat[0][2];\n  vec4 textrueStroke = vec4(\n    styleMappingMat[1][0],\n    styleMappingMat[1][1],\n    styleMappingMat[1][2],\n    styleMappingMat[1][3]\n  );\n\n  // get sdf from atlas\n  float dist = texture2D(u_sdf_map, v_uv).a;\n\n  // float fontScale = u_font_size / FONT_SIZE;\n\n  // lowp float buff = (6.0 - u_stroke_width / v_fontScale) / SDF_PX;\n  lowp float buff = (6.0 - strokeWidth / v_fontScale) / SDF_PX;\n  highp float gamma = (u_halo_blur * 1.19 / SDF_PX + EDGE_GAMMA) / (v_fontScale * u_gamma_scale) / 1.0;\n\n  highp float gamma_scaled = gamma * v_gamma_scale;\n\n  highp float alpha = smoothstep(buff - gamma_scaled, buff + gamma_scaled, dist);\n  // gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), vec4(u_stroke_color.rgb, u_stroke_color.a * u_opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * opacity), vec4(textrueStroke.rgb, textrueStroke.a * opacity), smoothstep(0., 0.5, 1. - dist));\n  gl_FragColor.a= gl_FragColor.a * alpha;\n   // \u4F5C\u4E3A mask \u6A21\u677F\u65F6\u9700\u8981\u4E22\u5F03\u900F\u660E\u7684\u50CF\u7D20\n  if (gl_FragColor.a < 0.01) {\n    discard;\n  }\n  gl_FragColor = filterColor(gl_FragColor);\n}\n";
/* babel-plugin-inline-import '../shaders/text_vert.glsl' */
var textVert = "#define SDF_PX 8.0\n#define EDGE_GAMMA 0.105\n#define FONT_SIZE 24.0\nattribute vec3 a_Position;\nattribute vec2 a_tex;\nattribute vec2 a_textOffsets;\nattribute vec4 a_Color;\nattribute float a_Size;\nattribute float a_Rotate;\n\nuniform vec2 u_sdf_map_size;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\nuniform float u_raisingHeight: 0.0;\n\nvarying vec2 v_uv;\nvarying float v_gamma_scale;\nvarying vec4 v_color;\nvarying float v_fontScale;\n\nvarying mat4 styleMappingMat; // \u7528\u4E8E\u5C06\u5728\u9876\u70B9\u7740\u8272\u5668\u4E2D\u8BA1\u7B97\u597D\u7684\u6837\u5F0F\u503C\u4F20\u9012\u7ED9\u7247\u5143\n\nuniform float u_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\n#pragma include \"styleMapping\"\n#pragma include \"styleMappingCalOpacity\"\n#pragma include \"styleMappingCalStrokeWidth\"\n\n#pragma include \"projection\"\n#pragma include \"picking\"\n\nvoid main() {\n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n   styleMappingMat = mat4(\n    0.0, 0.0, 0.0, 0.0, // opacity - strokeOpacity - strokeWidth - empty\n    0.0, 0.0, 0.0, 0.0, // strokeR - strokeG - strokeB - strokeA\n    0.0, 0.0, 0.0, 0.0, // offsets[0] - offsets[1]\n    0.0, 0.0, 0.0, 0.0\n  );\n\n  float rowCount = u_cellTypeLayout[0][0];    // \u5F53\u524D\u7684\u6570\u636E\u7EB9\u7406\u6709\u51E0\u884C\n  float columnCount = u_cellTypeLayout[0][1]; // \u5F53\u770B\u5230\u6570\u636E\u7EB9\u7406\u6709\u51E0\u5217\n  float columnWidth = 1.0/columnCount;  // \u5217\u5BBD\n  float rowHeight = 1.0/rowCount;       // \u884C\u9AD8\n  float cellCount = calCellCount(); // opacity - strokeOpacity - strokeWidth - stroke - offsets\n  float id = a_vertexId; // \u7B2Cn\u4E2A\u9876\u70B9\n  float cellCurrentRow = floor(id * cellCount / columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u884C\n  float cellCurrentColumn = mod(id * cellCount, columnCount) + 1.0; // \u8D77\u59CB\u70B9\u5728\u7B2C\u51E0\u5217\n  \n  // cell \u56FA\u5B9A\u987A\u5E8F opacity -> strokeOpacity -> strokeWidth -> stroke ... \n  // \u6309\u987A\u5E8F\u4ECE cell \u4E2D\u53D6\u503C\u3001\u82E5\u6CA1\u6709\u5219\u81EA\u52A8\u5F80\u4E0B\u53D6\u503C\n  float textureOffset = 0.0; // \u5728 cell \u4E2D\u53D6\u503C\u7684\u504F\u79FB\u91CF\n\n  vec2 opacityAndOffset = calOpacityAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][0] = opacityAndOffset.r;\n  textureOffset = opacityAndOffset.g;\n\n   vec2 strokeWidthAndOffset = calStrokeWidthAndOffset(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset, columnWidth, rowHeight);\n  styleMappingMat[0][2] = strokeWidthAndOffset.r;\n  textureOffset = strokeWidthAndOffset.g;\n\n  vec4 textrueStroke = vec4(-1.0, -1.0, -1.0, -1.0);\n  if(hasStroke()) {\n    vec2 valueRPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][0] = pos2value(valueRPos, columnWidth, rowHeight); // R\n    textureOffset += 1.0;\n\n    vec2 valueGPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][1] = pos2value(valueGPos, columnWidth, rowHeight); // G\n    textureOffset += 1.0;\n\n    vec2 valueBPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][2] = pos2value(valueBPos, columnWidth, rowHeight); // B\n    textureOffset += 1.0;\n\n    vec2 valueAPos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\n    styleMappingMat[1][3] = pos2value(valueAPos, columnWidth, rowHeight); // A\n    textureOffset += 1.0;\n  } else {\n    if(u_stroke_color == vec4(0.0)) {\n      styleMappingMat[1][0] = v_color.r;\n      styleMappingMat[1][1] = v_color.g;\n      styleMappingMat[1][2] = v_color.b;\n      styleMappingMat[1][3] = v_color.a;\n    } else {\n      styleMappingMat[1][0] = u_stroke_color.r;\n      styleMappingMat[1][1] = u_stroke_color.g;\n      styleMappingMat[1][2] = u_stroke_color.b;\n      styleMappingMat[1][3] = u_stroke_color.a;\n    }\n  }\n  \n  // cal style mapping - \u6570\u636E\u7EB9\u7406\u6620\u5C04\u90E8\u5206\u7684\u8BA1\u7B97\n\n  v_color = a_Color;\n  v_uv = a_tex / u_sdf_map_size;\n\n  // \u6587\u672C\u7F29\u653E\u6BD4\u4F8B\n  float fontScale = a_Size / FONT_SIZE;\n  v_fontScale = fontScale;\n\n  vec4 project_pos = project_position(vec4(a_Position, 1.0));\n  // vec4 projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz, 1.0));\n\n  highp float angle_sin = sin(a_Rotate);\n  highp float angle_cos = cos(a_Rotate);\n  mat2 rotation_matrix = mat2(angle_cos, -1.0 * angle_sin, angle_sin, angle_cos);\n  \n  // gl_Position = vec4(projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n\n  float raiseHeight = u_raisingHeight;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\n    float mapboxZoomScale = 4.0/pow(2.0, 21.0 - u_Zoom);\n    raiseHeight = u_raisingHeight * mapboxZoomScale;\n  }\n\n  vec4 projected_position;\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n   projected_position  = u_Mvp *(vec4(a_Position.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n  } else { // else\n   projected_position  = project_common_position_to_clipspace(vec4(project_pos.xyz + vec3(0.0, 0.0, raiseHeight), 1.0));\n  }\n\n  gl_Position = vec4(\n    projected_position.xy / projected_position.w + rotation_matrix * a_textOffsets * fontScale / u_ViewportSize * 2.0 * u_DevicePixelRatio, 0.0, 1.0);\n  v_gamma_scale = gl_Position.w;\n  setPickingColor(a_PickingColor);\n\n}\n";
function TextTriangulation(feature) {
  // @ts-ignore
  var that = this;
  var id = feature.id;
  var vertices = [];
  var indices = [];
  if (!that.glyphInfoMap || !that.glyphInfoMap[id]) {
    return {
      vertices: [],
      // [ x, y, z, tex.x,tex.y, offset.x. offset.y]
      indices: [],
      size: 7
    };
  }
  var centroid = that.glyphInfoMap[id].centroid; // 计算中心点
  var coord = centroid.length === 2 ? [centroid[0], centroid[1], 0] : centroid;
  that.glyphInfoMap[id].glyphQuads.forEach(function (quad, index) {
    vertices.push.apply(vertices, (0, _toConsumableArray2.default)(coord).concat([quad.tex.x, quad.tex.y + quad.tex.height, quad.tl.x, quad.tl.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y + quad.tex.height, quad.tr.x, quad.tr.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x + quad.tex.width, quad.tex.y, quad.br.x, quad.br.y], (0, _toConsumableArray2.default)(coord), [quad.tex.x, quad.tex.y, quad.bl.x, quad.bl.y]));
    indices.push(0 + index * 4, 1 + index * 4, 2 + index * 4, 2 + index * 4, 3 + index * 4, 0 + index * 4);
  });
  return {
    vertices: vertices,
    // [ x, y, z, tex.x,tex.y, offset.x. offset.y]
    indices: indices,
    size: 7
  };
}
var TextModel = /*#__PURE__*/function (_BaseModel) {
  (0, _inherits2.default)(TextModel, _BaseModel);
  var _super = _createSuper(TextModel);
  function TextModel() {
    var _this;
    (0, _classCallCheck2.default)(this, TextModel);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "glyphInfoMap", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "currentZoom", -1);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "textureHeight", 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "textCount", 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "preTextStyle", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "mapping", /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _this.initGlyph(); //
            _this.updateTexture();
            _context.next = 4;
            return _this.reBuildModel();
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    return _this;
  }
  (0, _createClass2.default)(TextModel, [{
    key: "getUninforms",
    value: function getUninforms() {
      var _ref2 = this.layer.getLayerConfig(),
        _ref2$opacity = _ref2.opacity,
        opacity = _ref2$opacity === void 0 ? 1.0 : _ref2$opacity,
        _ref2$stroke = _ref2.stroke,
        stroke = _ref2$stroke === void 0 ? '#fff' : _ref2$stroke,
        _ref2$strokeWidth = _ref2.strokeWidth,
        strokeWidth = _ref2$strokeWidth === void 0 ? 0 : _ref2$strokeWidth,
        _ref2$halo = _ref2.halo,
        halo = _ref2$halo === void 0 ? 0.5 : _ref2$halo,
        _ref2$gamma = _ref2.gamma,
        gamma = _ref2$gamma === void 0 ? 2.0 : _ref2$gamma,
        _ref2$raisingHeight = _ref2.raisingHeight,
        raisingHeight = _ref2$raisingHeight === void 0 ? 0 : _ref2$raisingHeight;
      var mapping = this.getFontServiceMapping();
      var canvas = this.getFontServiceCanvas();
      if (mapping && Object.keys(mapping).length !== this.textCount && canvas) {
        this.updateTexture();
        this.textCount = Object.keys(mapping).length;
      }
      this.preTextStyle = this.getTextStyle();
      if (this.dataTextureTest && this.dataTextureNeedUpdate({
        opacity: opacity,
        strokeWidth: strokeWidth,
        stroke: stroke
      })) {
        this.judgeStyleAttributes({
          opacity: opacity,
          strokeWidth: strokeWidth,
          stroke: stroke
        });
        var encodeData = this.layer.getEncodedData();
        var _this$calDataFrame = this.calDataFrame(this.cellLength, encodeData, this.cellProperties),
          data = _this$calDataFrame.data,
          width = _this$calDataFrame.width,
          height = _this$calDataFrame.height;
        this.rowCount = height; // 当前数据纹理有多少行

        this.dataTexture = this.cellLength > 0 && data.length > 0 ? this.createTexture2D({
          flipY: true,
          data: data,
          format: _l7Core.gl.LUMINANCE,
          type: _l7Core.gl.FLOAT,
          width: width,
          height: height
        }) : this.createTexture2D({
          flipY: true,
          data: [1],
          format: _l7Core.gl.LUMINANCE,
          type: _l7Core.gl.FLOAT,
          width: 1,
          height: 1
        });
      }
      return {
        u_dataTexture: this.dataTexture,
        // 数据纹理 - 有数据映射的时候纹理中带数据，若没有任何数据映射时纹理是 [1]
        u_cellTypeLayout: this.getCellTypeLayout(),
        u_raisingHeight: Number(raisingHeight),
        u_opacity: (0, _lodash.isNumber)(opacity) ? opacity : 1.0,
        u_stroke_width: (0, _lodash.isNumber)(strokeWidth) ? strokeWidth : 1.0,
        u_stroke_color: this.getStrokeColor(stroke),
        u_sdf_map: this.texture,
        u_halo_blur: halo,
        u_gamma_scale: gamma,
        u_sdf_map_size: [(canvas === null || canvas === void 0 ? void 0 : canvas.width) || 1, (canvas === null || canvas === void 0 ? void 0 : canvas.height) || 1]
      };
    }
  }, {
    key: "initModels",
    value: function () {
      var _initModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              // 绑定事件
              this.bindEvent();
              this.extent = this.textExtent();
              this.preTextStyle = this.getTextStyle();
              return _context2.abrupt("return", this.buildModels());
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function initModels() {
        return _initModels.apply(this, arguments);
      }
      return initModels;
    }()
  }, {
    key: "buildModels",
    value: function () {
      var _buildModels = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var _ref3, _ref3$textAllowOverla, textAllowOverlap, model;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _ref3 = this.layer.getLayerConfig(), _ref3$textAllowOverla = _ref3.textAllowOverlap, textAllowOverlap = _ref3$textAllowOverla === void 0 ? false : _ref3$textAllowOverla; //  this.mapping(); 重复调用
              this.initGlyph(); //
              this.updateTexture();
              if (!textAllowOverlap) {
                this.filterGlyphs();
              }
              _context3.next = 6;
              return this.layer.buildLayerModel({
                moduleName: 'pointText',
                vertexShader: textVert,
                fragmentShader: textFrag,
                triangulation: TextTriangulation.bind(this),
                depth: {
                  enable: false
                }
              });
            case 6:
              model = _context3.sent;
              return _context3.abrupt("return", [model]);
            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function buildModels() {
        return _buildModels.apply(this, arguments);
      }
      return buildModels;
    }() // 需要更新的场景
    // 1. 文本偏移量发生改变
    // 2. 文本锚点发生改变
    // 3. 文本允许重叠发生改变
    // 4. 文本字体发生改变
    // 5. 文本字体粗细发生改变
  }, {
    key: "needUpdate",
    value: function () {
      var _needUpdate = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var _ref4, _ref4$textAllowOverla, textAllowOverlap, _ref4$textAnchor, textAnchor, textOffset, padding, fontFamily, fontWeight, zoom, extent, flag;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _ref4 = this.getTextStyle(), _ref4$textAllowOverla = _ref4.textAllowOverlap, textAllowOverlap = _ref4$textAllowOverla === void 0 ? false : _ref4$textAllowOverla, _ref4$textAnchor = _ref4.textAnchor, textAnchor = _ref4$textAnchor === void 0 ? 'center' : _ref4$textAnchor, textOffset = _ref4.textOffset, padding = _ref4.padding, fontFamily = _ref4.fontFamily, fontWeight = _ref4.fontWeight;
              if (!(!(0, _lodash.isEqual)(padding, this.preTextStyle.padding) || !(0, _lodash.isEqual)(textOffset, this.preTextStyle.textOffset) || !(0, _lodash.isEqual)(textAnchor, this.preTextStyle.textAnchor) || !(0, _lodash.isEqual)(fontFamily, this.preTextStyle.fontFamily) || !(0, _lodash.isEqual)(fontWeight, this.preTextStyle.fontWeight))) {
                _context4.next = 5;
                break;
              }
              _context4.next = 4;
              return this.mapping();
            case 4:
              return _context4.abrupt("return", true);
            case 5:
              if (!textAllowOverlap) {
                _context4.next = 7;
                break;
              }
              return _context4.abrupt("return", false);
            case 7:
              // textAllowOverlap 发生改变
              zoom = this.mapService.getZoom();
              extent = this.mapService.getBounds();
              flag = (0, _l7Utils.boundsContains)(this.extent, extent); // 文本不能压盖则进行过滤
              if (!(Math.abs(this.currentZoom - zoom) > 0.5 || !flag || textAllowOverlap !== this.preTextStyle.textAllowOverlap)) {
                _context4.next = 14;
                break;
              }
              _context4.next = 13;
              return this.reBuildModel();
            case 13:
              return _context4.abrupt("return", true);
            case 14:
              return _context4.abrupt("return", false);
            case 15:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function needUpdate() {
        return _needUpdate.apply(this, arguments);
      }
      return needUpdate;
    }()
  }, {
    key: "clearModels",
    value: function clearModels() {
      var _this$texture, _this$dataTexture;
      (_this$texture = this.texture) === null || _this$texture === void 0 ? void 0 : _this$texture.destroy();
      (_this$dataTexture = this.dataTexture) === null || _this$dataTexture === void 0 ? void 0 : _this$dataTexture.destroy();
      // TODO this.mapping
      this.layer.off('remapping', this.mapping);
    }
  }, {
    key: "registerBuiltinAttributes",
    value: function registerBuiltinAttributes() {
      this.styleAttributeService.registerStyleAttribute({
        name: 'rotate',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Rotate',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature) {
            var _feature$rotate = feature.rotate,
              rotate = _feature$rotate === void 0 ? 0 : _feature$rotate;
            return Array.isArray(rotate) ? [rotate[0]] : [rotate];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textOffsets',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_textOffsets',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.STATIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[5], vertex[6]];
          }
        }
      });

      // point layer size;
      this.styleAttributeService.registerStyleAttribute({
        name: 'size',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_Size',
          buffer: {
            // give the WebGL driver a hint that this buffer may change
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 1,
          update: function update(feature) {
            var _feature$size = feature.size,
              size = _feature$size === void 0 ? 12 : _feature$size;
            return Array.isArray(size) ? [size[0]] : [size];
          }
        }
      });
      this.styleAttributeService.registerStyleAttribute({
        name: 'textUv',
        type: _l7Core.AttributeType.Attribute,
        descriptor: {
          name: 'a_tex',
          buffer: {
            usage: _l7Core.gl.DYNAMIC_DRAW,
            data: [],
            type: _l7Core.gl.FLOAT
          },
          size: 2,
          update: function update(feature, featureIdx, vertex) {
            return [vertex[3], vertex[4]];
          }
        }
      });
    }
  }, {
    key: "bindEvent",
    value: function bindEvent() {
      if (!this.layer.isTileLayer) {
        // 重新绑定
        this.layer.on('remapping', this.mapping);
      }
    }
  }, {
    key: "textExtent",
    value: function textExtent() {
      var bounds = this.mapService.getBounds();
      return (0, _l7Utils.padBounds)(bounds, 0.5);
    }
    /**
     * 生成文字纹理（生成文字纹理字典）
     */
  }, {
    key: "initTextFont",
    value: function initTextFont() {
      var _this$getTextStyle = this.getTextStyle(),
        fontWeight = _this$getTextStyle.fontWeight,
        fontFamily = _this$getTextStyle.fontFamily;
      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape = item.shape,
          shape = _item$shape === void 0 ? '' : _item$shape;
        shape = shape.toString();
        var _iterator = _createForOfIteratorHelper(shape),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var char = _step.value;
            // 去重
            if (characterSet.indexOf(char) === -1) {
              characterSet.push(char);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        iconfont: false
      });
    }

    /**
     * 生成 iconfont 纹理字典
     */
  }, {
    key: "initIconFontTex",
    value: function initIconFontTex() {
      var _this$getTextStyle2 = this.getTextStyle(),
        fontWeight = _this$getTextStyle2.fontWeight,
        fontFamily = _this$getTextStyle2.fontFamily;
      var data = this.layer.getEncodedData();
      var characterSet = [];
      data.forEach(function (item) {
        var _item$shape2 = item.shape,
          shape = _item$shape2 === void 0 ? '' : _item$shape2;
        shape = "".concat(shape);
        if (characterSet.indexOf(shape) === -1) {
          characterSet.push(shape);
        }
      });
      this.fontService.setFontOptions({
        characterSet: characterSet,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        iconfont: true
      });
    }
  }, {
    key: "getTextStyle",
    value: function getTextStyle() {
      var _ref5 = this.layer.getLayerConfig(),
        _ref5$fontWeight = _ref5.fontWeight,
        fontWeight = _ref5$fontWeight === void 0 ? '400' : _ref5$fontWeight,
        _ref5$fontFamily = _ref5.fontFamily,
        fontFamily = _ref5$fontFamily === void 0 ? 'sans-serif' : _ref5$fontFamily,
        _ref5$textAllowOverla = _ref5.textAllowOverlap,
        textAllowOverlap = _ref5$textAllowOverla === void 0 ? false : _ref5$textAllowOverla,
        _ref5$padding = _ref5.padding,
        padding = _ref5$padding === void 0 ? [0, 0] : _ref5$padding,
        _ref5$textAnchor = _ref5.textAnchor,
        textAnchor = _ref5$textAnchor === void 0 ? 'center' : _ref5$textAnchor,
        _ref5$textOffset = _ref5.textOffset,
        textOffset = _ref5$textOffset === void 0 ? [0, 0] : _ref5$textOffset,
        _ref5$opacity = _ref5.opacity,
        opacity = _ref5$opacity === void 0 ? 1 : _ref5$opacity,
        _ref5$strokeOpacity = _ref5.strokeOpacity,
        strokeOpacity = _ref5$strokeOpacity === void 0 ? 1 : _ref5$strokeOpacity,
        _ref5$strokeWidth = _ref5.strokeWidth,
        strokeWidth = _ref5$strokeWidth === void 0 ? 0 : _ref5$strokeWidth,
        _ref5$stroke = _ref5.stroke,
        stroke = _ref5$stroke === void 0 ? '#000' : _ref5$stroke;
      return {
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        textAllowOverlap: textAllowOverlap,
        padding: padding,
        textAnchor: textAnchor,
        textOffset: textOffset,
        opacity: opacity,
        strokeOpacity: strokeOpacity,
        strokeWidth: strokeWidth,
        stroke: stroke
      };
    }

    /**
     * 生成文字布局（对照文字纹理字典提取对应文字的位置很好信息）
     */
  }, {
    key: "generateGlyphLayout",
    value: function generateGlyphLayout(iconfont) {
      var _this2 = this;
      var mapping = this.getFontServiceMapping();
      var _ref6 = this.layer.getLayerConfig(),
        _ref6$spacing = _ref6.spacing,
        spacing = _ref6$spacing === void 0 ? 2 : _ref6$spacing,
        _ref6$textAnchor = _ref6.textAnchor,
        textAnchor = _ref6$textAnchor === void 0 ? 'center' : _ref6$textAnchor,
        textOffset = _ref6.textOffset;
      var data = this.layer.getEncodedData();
      this.glyphInfo = data.map(function (feature) {
        var _feature$shape = feature.shape,
          shape = _feature$shape === void 0 ? '' : _feature$shape,
          id = feature.id,
          _feature$size2 = feature.size,
          size = _feature$size2 === void 0 ? 1 : _feature$size2;
        var shaping = (0, _symbolLayout.shapeText)(shape.toString(), mapping,
        // @ts-ignore
        size, textAnchor, 'left', spacing, textOffset || feature.textOffset || [0, 0], iconfont);
        var glyphQuads = (0, _symbolLayout.getGlyphQuads)(shaping, textOffset, false);
        feature.shaping = shaping;
        feature.glyphQuads = glyphQuads;
        // feature.centroid = calculteCentroid(coordinates);

        feature.centroid = (0, _l7Utils.calculateCentroid)(feature.coordinates);

        // 此时地图高德2.0 originCentroid == centroid
        feature.originCentroid = feature.version === 'GAODE2.x' ? (0, _l7Utils.calculateCentroid)(feature.originCoordinates) : feature.originCentroid = feature.centroid;
        _this2.glyphInfoMap[id] = {
          shaping: shaping,
          glyphQuads: glyphQuads,
          centroid: (0, _l7Utils.calculateCentroid)(feature.coordinates)
        };
        return feature;
      });
    }
  }, {
    key: "getFontServiceMapping",
    value: function getFontServiceMapping() {
      var _ref7 = this.layer.getLayerConfig(),
        _ref7$fontWeight = _ref7.fontWeight,
        fontWeight = _ref7$fontWeight === void 0 ? '400' : _ref7$fontWeight,
        _ref7$fontFamily = _ref7.fontFamily,
        fontFamily = _ref7$fontFamily === void 0 ? 'sans-serif' : _ref7$fontFamily;
      return this.fontService.getMappingByKey("".concat(fontFamily, "_").concat(fontWeight));
    }
  }, {
    key: "getFontServiceCanvas",
    value: function getFontServiceCanvas() {
      var _ref8 = this.layer.getLayerConfig(),
        _ref8$fontWeight = _ref8.fontWeight,
        fontWeight = _ref8$fontWeight === void 0 ? '400' : _ref8$fontWeight,
        _ref8$fontFamily = _ref8.fontFamily,
        fontFamily = _ref8$fontFamily === void 0 ? 'sans-serif' : _ref8$fontFamily;
      // 更新文字布局
      return this.fontService.getCanvasByKey("".concat(fontFamily, "_").concat(fontWeight));
    }

    /**
     * 文字避让 depend on originCentorid
     */
  }, {
    key: "filterGlyphs",
    value: function filterGlyphs() {
      var _this3 = this;
      var _ref9 = this.layer.getLayerConfig(),
        _ref9$padding = _ref9.padding,
        padding = _ref9$padding === void 0 ? [0, 0] : _ref9$padding,
        _ref9$textAllowOverla = _ref9.textAllowOverlap,
        textAllowOverlap = _ref9$textAllowOverla === void 0 ? false : _ref9$textAllowOverla;
      if (textAllowOverlap) {
        // 如果允许文本覆盖
        return;
      }
      this.glyphInfoMap = {};
      this.currentZoom = this.mapService.getZoom();
      this.extent = this.textExtent();
      var _this$rendererService = this.rendererService.getViewportSize(),
        width = _this$rendererService.width,
        height = _this$rendererService.height;
      var collisionIndex = new _collisionIndex.default(width, height);
      var filterData = this.glyphInfo.filter(function (feature) {
        var shaping = feature.shaping,
          _feature$id = feature.id,
          id = _feature$id === void 0 ? 0 : _feature$id;
        // const centroid = feature.centroid as [number, number];
        // const centroid = feature.originCentroid as [number, number];
        var centroid = feature.version === 'GAODE2.x' ? feature.originCentroid : feature.centroid;
        var size = feature.size;
        var fontScale = size / 16;
        var pixels = _this3.mapService.lngLatToContainer(centroid);
        var _collisionIndex$place = collisionIndex.placeCollisionBox({
            x1: shaping.left * fontScale - padding[0],
            x2: shaping.right * fontScale + padding[0],
            y1: shaping.top * fontScale - padding[1],
            y2: shaping.bottom * fontScale + padding[1],
            anchorPointX: pixels.x,
            anchorPointY: pixels.y
          }),
          box = _collisionIndex$place.box;
        if (box && box.length) {
          collisionIndex.insertCollisionBox(box, id);
          return true;
        } else {
          return false;
        }
      });
      filterData.forEach(function (item) {
        // @ts-ignore
        _this3.glyphInfoMap[item.id] = item;
      });
      // this.layer.setEncodedData(filterData);
    }
    /**
     * 初始化文字布局
     */
  }, {
    key: "initGlyph",
    value: function initGlyph() {
      var _this$layer$getLayerC = this.layer.getLayerConfig(),
        _this$layer$getLayerC2 = _this$layer$getLayerC.iconfont,
        iconfont = _this$layer$getLayerC2 === void 0 ? false : _this$layer$getLayerC2;
      // 1.生成文字纹理（或是生成 iconfont）
      iconfont ? this.initIconFontTex() : this.initTextFont();
      // 2.生成文字布局
      this.generateGlyphLayout(iconfont);
    }
    /**
     * 更新文字纹理
     */
  }, {
    key: "updateTexture",
    value: function updateTexture() {
      var createTexture2D = this.rendererService.createTexture2D;
      var canvas = this.getFontServiceCanvas();
      this.textureHeight = canvas.height;
      if (this.texture) {
        this.texture.destroy();
      }
      this.texture = createTexture2D({
        data: canvas,
        mag: _l7Core.gl.LINEAR,
        min: _l7Core.gl.LINEAR,
        width: canvas.width,
        height: canvas.height
      });
    }
  }, {
    key: "reBuildModel",
    value: function () {
      var _reBuildModel = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var model;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              this.filterGlyphs();
              _context5.next = 3;
              return this.layer.buildLayerModel({
                moduleName: 'pointText',
                vertexShader: textVert,
                fragmentShader: textFrag,
                triangulation: TextTriangulation.bind(this),
                depth: {
                  enable: false
                }
              });
            case 3:
              model = _context5.sent;
              // TODO 渲染流程待修改
              this.layer.models = [model];
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function reBuildModel() {
        return _reBuildModel.apply(this, arguments);
      }
      return reBuildModel;
    }()
  }]);
  return TextModel;
}(_BaseModel2.default);
exports.default = TextModel;