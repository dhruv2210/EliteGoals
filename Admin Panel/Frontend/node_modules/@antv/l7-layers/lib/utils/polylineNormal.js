"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeMiter = computeMiter;
exports.computeNormal = computeNormal;
exports.default = _default;
exports.direction = direction;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _l7Utils = require("@antv/l7-utils");
var _glMatrix = require("gl-matrix");
function computeMiter(tangent, miter, lineA, lineB, halfThick) {
  _glMatrix.vec2.add(tangent, lineA, lineB);
  _glMatrix.vec2.normalize(tangent, tangent);
  miter = _glMatrix.vec2.fromValues(-tangent[1], tangent[0]);
  var tmp = _glMatrix.vec2.fromValues(-lineA[1], lineA[0]);
  return halfThick / _glMatrix.vec2.dot(miter, tmp);
}
function computeNormal(out, dir) {
  return _glMatrix.vec2.set(out, -dir[1], dir[0]);
}
function direction(out, a, b) {
  // const a1 = aProjectFlat([a[0], a[1]]) as [number, number];
  // const b1 = aProjectFlat([b[0], b[1]]) as [number, number];
  _glMatrix.vec2.sub(out, a, b);
  _glMatrix.vec2.normalize(out, out);
  return out;
}
function extrusions(positions, out, miters, point, normal, scale) {
  addNext(out, miters, normal, -scale);
  addNext(out, miters, normal, scale);
  positions.push(point[0], point[1], 0);
  positions.push(point[0], point[1], 0);
}
function addNext(out, miters, normal, length) {
  out.push(normal[0], normal[1], 0);
  miters.push(length);
}
function lineSegmentDistance(b1, a1) {
  var dx = a1[0] - b1[0];
  var dy = a1[1] - b1[1];
  return Math.sqrt(dx * dx + dy * dy);
}
function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function _default(points, closed, indexOffset) {
  var isDash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var lineA = _glMatrix.vec2.fromValues(0, 0);
  var lineB = _glMatrix.vec2.fromValues(0, 0);
  var tangent = _glMatrix.vec2.fromValues(0, 0);
  var miter = _glMatrix.vec2.create();
  var started = false;
  var lineNormal = null;
  var tmp = _glMatrix.vec2.create();
  var count = indexOffset || 0;
  var miterLimit = 4;
  var out = [];
  var attrPos = [];
  var attrIndex = [];
  var miters = [];
  var attrDistance = [0, 0];
  if (closed) {
    points = points.slice();
    points.push(points[0]);
  }
  var total = points.length;
  for (var i = 1; i < total; i++) {
    var index = count;
    var last = _glMatrix.vec2.fromValues(points[i - 1][0], points[i - 1][1]);
    var cur = _glMatrix.vec2.fromValues(points[i][0], points[i][1]);
    var next = i < points.length - 1 ? _glMatrix.vec2.fromValues(points[i + 1][0], points[i + 1][1]) : null;
    // 如果当前点和前一点相同，跳过
    if (isPointEqual(last, cur)) {
      continue;
    }
    if (next) {
      var nextIndex = i + 1;
      // 找到不相同的下一点
      while (next && isPointEqual(cur, next)) {
        next = nextIndex < points.length - 1 ? _glMatrix.vec2.fromValues(points[++nextIndex][0], points[nextIndex][1]) : null;
      }
    }
    var d = 0;
    var flatCur = (0, _l7Utils.aProjectFlat)([cur[0], cur[1]]);
    var flatLast = (0, _l7Utils.aProjectFlat)([last[0], last[1]]);
    if (isDash) {
      var lineDistance = lineSegmentDistance(flatCur, flatLast);
      d = lineDistance + attrDistance[attrDistance.length - 1];
    }
    direction(lineA, flatCur, flatLast);
    if (!lineNormal) {
      lineNormal = _glMatrix.vec2.create();
      computeNormal(lineNormal, lineA);
    }
    if (!started) {
      started = true;
      extrusions(attrPos, out, miters, last, lineNormal, 1);
    }
    attrIndex.push(index + 0, index + 2, index + 1);

    // no miter, simple segment
    if (!next) {
      // reset normal
      computeNormal(lineNormal, lineA);
      extrusions(attrPos, out, miters, cur, lineNormal, 1);
      attrDistance.push(d, d);
      attrIndex.push(index + 1, index + 2, index + 3);
      count += 2;
    } else {
      var flatNext = (0, _l7Utils.aProjectFlat)([next[0], next[1]]);
      // get unit dir of next line
      direction(lineB, flatNext, flatCur);

      // stores tangent & miter
      var miterLen = computeMiter(tangent, _glMatrix.vec2.fromValues(miter[0], miter[1]), lineA, lineB, 1);

      // get orientation
      var flip = _glMatrix.vec2.dot(tangent, lineNormal) < 0 ? -1 : 1;
      var bevel = Math.abs(miterLen) > miterLimit;

      // 处理前后两条线段重合的情况，这种情况不需要使用任何接头（miter/bevel）。
      // 理论上这种情况下 miterLen = Infinity，本应通过 isFinite(miterLen) 判断，
      // 但是 AMap 投影变换后丢失精度，只能通过一个阈值（1000）判断。

      if (Math.abs(miterLen) > 1000) {
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);
        attrIndex.push(index + 2, index + 4, index + 3);
        computeNormal(tmp, lineB);
        _glMatrix.vec2.copy(lineNormal, tmp); // store normal for next round

        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d);

        // the miter is now the normal for our next join
        count += 4;
        continue;
      }
      if (bevel) {
        miterLen = miterLimit;

        // next two points in our first segment
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);

        // now add the bevel triangle
        attrIndex.push.apply(attrIndex, (0, _toConsumableArray2.default)(flip === 1 ? [index + 2, index + 4, index + 5] : [index + 4, index + 5, index + 3]));
        computeNormal(tmp, lineB);
        _glMatrix.vec2.copy(lineNormal, tmp); // store normal for next round

        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d);

        // the miter is now the normal for our next join
        count += 4;
      } else {
        // next two points in our first segment
        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrIndex.push(index + 1, index + 2, index + 3);

        // now add the miter triangles
        addNext(out, miters, lineNormal, miterLen * -flip);
        attrPos.push(cur[0], cur[1], 0);
        attrIndex.push(index + 2, index + 4, index + 3);
        attrIndex.push(index + 4, index + 5, index + 6);
        computeNormal(tmp, lineB);
        _glMatrix.vec2.copy(lineNormal, tmp); // store normal for next round

        extrusions(attrPos, out, miters, cur, lineNormal, 1);
        attrDistance.push(d, d, d, d, d);

        // the miter is now the normal for our next join
        count += 5;
      }
    }
  }
  var pickData = [];
  for (var _i = 0; _i < miters.length; _i++) {
    var totalDistance = attrDistance[attrDistance.length - 1];
    pickData.push(attrPos[_i * 3], attrPos[_i * 3 + 1], attrPos[_i * 3 + 2], attrDistance[_i],
    // dash
    miters[_i], totalDistance // dash
    );
  }

  return {
    normals: out,
    attrIndex: attrIndex,
    attrPos: pickData // [x,y,z, distance, miter ,t0tal ]
  };
}
// [x,y,z, distance, miter ]