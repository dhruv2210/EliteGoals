"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.direction = direction;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _glMatrix = require("gl-matrix");
var lineA = _glMatrix.vec2.create();
function direction(out, a, b) {
  _glMatrix.vec2.sub(out, a, b);
  _glMatrix.vec2.normalize(out, out);
  return out;
}
var ExtrudePolyline = /*#__PURE__*/function () {
  function ExtrudePolyline() {
    (0, _classCallCheck2.default)(this, ExtrudePolyline);
    (0, _defineProperty2.default)(this, "started", false);
    (0, _defineProperty2.default)(this, "totalDistance", 0);
    (0, _defineProperty2.default)(this, "currentIndex", 0);
    this.complex = {
      positions: [],
      indices: [],
      startIndex: 0,
      indexes: []
    };
  }
  (0, _createClass2.default)(ExtrudePolyline, [{
    key: "simpleExtrude",
    value: function simpleExtrude(points) {
      var complex = this.complex;
      if (points.length <= 1) {
        return complex;
      }
      this.started = false;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;
      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var amt = this.simpleSegment(complex, count, last, cur);
        count += amt;
      }
      for (var _i = 0; _i < complex.positions.length / 6; _i++) {
        complex.positions[_i * 6 + 5] = this.totalDistance;
      }
      return complex;
    }
  }, {
    key: "simpleSegment",
    value: function simpleSegment(complex, index, last, cur) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var flatCur = (0, _l7Utils.aProjectFlat)([cur[0], cur[1]]);
      var flatLast = (0, _l7Utils.aProjectFlat)([last[0], last[1]]);
      direction(lineA, flatCur, flatLast);
      var segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
      this.totalDistance += segmentDistance;
      if (!this.started) {
        this.started = true;
        this.extrusions(positions, last, this.totalDistance - segmentDistance);
      }
      this.extrusions(positions, cur, this.totalDistance);
      indices.push(index + 0, index + 1, index + 2);
      indices.push(index + 2, index + 1, index + 3);
      count += 2;
      return count;
    }
  }, {
    key: "extrusions",
    value: function extrusions(positions, point,
    // 顶点
    distanceRadio) {
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, 0, point[2] | 0);
      this.complex.indexes.push(this.currentIndex);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, 0, point[2] | 0);
      this.complex.indexes.push(this.currentIndex);
      this.currentIndex++;
    }
  }, {
    key: "lineSegmentDistance",
    value: function lineSegmentDistance(b1, a1) {
      var dx = a1[0] - b1[0];
      var dy = a1[1] - b1[1];
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);
  return ExtrudePolyline;
}();
exports.default = ExtrudePolyline;