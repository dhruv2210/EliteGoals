"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeMiter = computeMiter;
exports.computeNormal = computeNormal;
exports.default = void 0;
exports.direction = direction;
exports.getArrayUnique = getArrayUnique;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _glMatrix = require("gl-matrix");
var tmp = _glMatrix.vec2.create();
// eslint-disable-next-line @typescript-eslint/no-unused-vars
var capEnd = _glMatrix.vec2.create();
var lineA = _glMatrix.vec2.create();
var lineB = _glMatrix.vec2.create();
var tangent = _glMatrix.vec2.create();
function computeMiter(lineTangent, miter, start, end, halfThick) {
  _glMatrix.vec2.add(lineTangent, start, end);
  _glMatrix.vec2.normalize(lineTangent, lineTangent);
  miter = _glMatrix.vec2.fromValues(-lineTangent[1], lineTangent[0]);
  var tmpvec = _glMatrix.vec2.fromValues(-start[1], start[0]);
  return [halfThick / _glMatrix.vec2.dot(miter, tmpvec), miter];
}
function computeNormal(out, dir) {
  return _glMatrix.vec2.set(out, -dir[1], dir[0]);
}
function direction(out, a, b) {
  _glMatrix.vec2.sub(out, a, b);
  _glMatrix.vec2.normalize(out, out);
  return out;
}
function isPointEqual(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function getArrayUnique(matrix) {
  var map = new Map();
  for (var i = 0; i < matrix.length; i++) {
    var key = matrix[0].toString() + '-' + matrix[1].toString();
    if (map.get(key)) {
      matrix.splice(i, 1);
      i++;
    } else {
      map.set(key, key);
    }
  }
  return matrix;
}
var ExtrudePolyline = /*#__PURE__*/function () {
  function ExtrudePolyline() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, ExtrudePolyline);
    (0, _defineProperty2.default)(this, "lastFlip", -1);
    (0, _defineProperty2.default)(this, "miter", _glMatrix.vec2.fromValues(0, 0));
    (0, _defineProperty2.default)(this, "started", false);
    (0, _defineProperty2.default)(this, "dash", false);
    (0, _defineProperty2.default)(this, "totalDistance", 0);
    (0, _defineProperty2.default)(this, "currentIndex", 0);
    this.join = opts.join || 'miter';
    this.cap = opts.cap || 'butt';
    this.miterLimit = opts.miterLimit || 10;
    this.thickness = opts.thickness || 1;
    this.dash = opts.dash || false;
    this.complex = {
      positions: [],
      indices: [],
      normals: [],
      startIndex: 0,
      indexes: []
    };
  }
  (0, _createClass2.default)(ExtrudePolyline, [{
    key: "simpleExtrude",
    value: function simpleExtrude(points) {
      var complex = this.complex;
      if (points.length <= 1) {
        return complex;
      }
      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      var total = points.length;
      var count = complex.startIndex;
      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.simpleSegment(complex, count, last, cur, next);
        count += amt;
      }
      if (this.dash) {
        for (var _i = 0; _i < complex.positions.length / 6; _i++) {
          complex.positions[_i * 6 + 5] = this.totalDistance;
        }
      }
      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "simpleExtrude_gaode2",
    value: function simpleExtrude_gaode2(points, originPoints) {
      var complex = this.complex;
      if (points.length <= 1) {
        return complex;
      }
      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      // 去除数组里重复的点
      // points = getArrayUnique(points);
      var total = points.length;
      var count = complex.startIndex;
      for (var i = 1; i < total; i++) {
        var _originPoints$, _originPoints$i$, _originPoints$2;
        var last = points[i - 1];
        last.push((_originPoints$ = originPoints[i - 1][2]) !== null && _originPoints$ !== void 0 ? _originPoints$ : 0);
        // @ts-ignore
        var originLast = originPoints[i - 1];
        var cur = points[i];
        cur.push((_originPoints$i$ = originPoints[i][2]) !== null && _originPoints$i$ !== void 0 ? _originPoints$i$ : 0);
        // @ts-ignore
        var originCur = originPoints[i];
        var next = i < points.length - 1 ? [].concat((0, _toConsumableArray2.default)(points[i + 1]), [(_originPoints$2 = originPoints[i + 1][2]) !== null && _originPoints$2 !== void 0 ? _originPoints$2 : 0]) : null;
        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
        var amt = this.simpleSegment(complex, count,
        // @ts-ignore
        last,
        // @ts-ignore
        cur,
        // @ts-ignore
        next,
        // @ts-ignore
        originLast, originCur,
        // @ts-ignore
        originNext);
        count += amt;
      }
      if (this.dash) {
        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {
          complex.positions[_i2 * 6 + 5] = this.totalDistance;
        }
      }
      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "extrude_gaode2",
    value: function extrude_gaode2(points, originPoints) {
      var complex = this.complex;
      if (points.length <= 1) {
        return complex;
      }
      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      // 去除数组里重复的点
      // points = getArrayUnique(points);
      var total = points.length;
      var count = complex.startIndex;
      for (var i = 1; i < total; i++) {
        var _originPoints$3, _originPoints$i$2, _originPoints$4;
        var last = points[i - 1];
        last.push((_originPoints$3 = originPoints[i - 1][2]) !== null && _originPoints$3 !== void 0 ? _originPoints$3 : 0);
        // @ts-ignore
        var originLast = originPoints[i - 1];
        var cur = points[i];
        cur.push((_originPoints$i$2 = originPoints[i][2]) !== null && _originPoints$i$2 !== void 0 ? _originPoints$i$2 : 0);
        // @ts-ignore
        var originCur = originPoints[i];
        var next = i < points.length - 1 ? [].concat((0, _toConsumableArray2.default)(points[i + 1]), [(_originPoints$4 = originPoints[i + 1][2]) !== null && _originPoints$4 !== void 0 ? _originPoints$4 : 0]) : null;
        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;
        var amt = this.segment_gaode2(complex, count,
        // @ts-ignore
        last,
        // @ts-ignore
        cur,
        // @ts-ignore
        next,
        // @ts-ignore
        originLast, originCur,
        // @ts-ignore
        originNext);
        count += amt;
      }
      if (this.dash) {
        for (var _i3 = 0; _i3 < complex.positions.length / 6; _i3++) {
          complex.positions[_i3 * 6 + 5] = this.totalDistance;
        }
      }
      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "extrude",
    value: function extrude(points) {
      var complex = this.complex;
      if (points.length <= 1) {
        return complex;
      }
      this.lastFlip = -1;
      this.started = false;
      this.normal = null;
      this.totalDistance = 0;
      // 去除数组里重复的点
      // points = getArrayUnique(points);
      var total = points.length;
      var count = complex.startIndex;
      for (var i = 1; i < total; i++) {
        var last = points[i - 1];
        var cur = points[i];
        var next = i < points.length - 1 ? points[i + 1] : null;
        var amt = this.segment(complex, count, last, cur, next);
        count += amt;
      }
      if (this.dash) {
        for (var _i4 = 0; _i4 < complex.positions.length / 6; _i4++) {
          complex.positions[_i4 * 6 + 5] = this.totalDistance;
        }
      }
      complex.startIndex = complex.positions.length / 6;
      return complex;
    }
  }, {
    key: "simpleSegment",
    value: function simpleSegment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var flatCur = (0, _l7Utils.aProjectFlat)([cur[0], cur[1]]);
      var flatLast = (0, _l7Utils.aProjectFlat)([last[0], last[1]]);
      // @ts-ignore
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;
      if (this.dash) {
        // @ts-ignore
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }
      if (!this.normal) {
        this.normal = _glMatrix.vec2.create();
        computeNormal(this.normal, lineA);
      }
      if (!this.started) {
        this.started = true;
        this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
      }
      indices.push(index + 0, index + 1, index + 2);
      if (!next) {
        computeNormal(this.normal, lineA);
        this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = (0, _l7Utils.aProjectFlat)([next[0], next[1]]);
        if (isPointEqual(flatCur, flatNext)) {
          _glMatrix.vec2.add(flatNext, flatCur, _glMatrix.vec2.normalize(flatNext, _glMatrix.vec2.subtract(flatNext, flatCur, flatLast)));
        }
        direction(lineB, flatNext, flatCur);

        // stores tangent & miter

        var _computeMiter = computeMiter(tangent, _glMatrix.vec2.create(), lineA, lineB, this.thickness),
          _computeMiter2 = (0, _slicedToArray2.default)(_computeMiter, 2),
          miterLen = _computeMiter2[0],
          miter = _computeMiter2[1];
        // normal(tmp, lineA)

        // get orientation
        var flip = _glMatrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
        indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        flip = -1;

        // the miter is now the normal for our next join
        _glMatrix.vec2.copy(this.normal, miter);
        count += 2;
        this.lastFlip = flip;
      }
      return count;
    }
  }, {
    key: "segment_gaode2",
    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    originNext) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = (0, _l7Utils.aProjectFlat)([originCur[0], originCur[1]]);
      var flatLast = (0, _l7Utils.aProjectFlat)([originLast[0], originLast[1]]);
      // @ts-ignore
      direction(lineA, cur, last);
      var segmentDistance = 0;
      if (this.dash) {
        // @ts-ignore
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }
      if (!this.normal) {
        this.normal = _glMatrix.vec2.create();
        computeNormal(this.normal, lineA);
      }
      if (!this.started) {
        this.started = true;

        // if the end cap is type square, we can just push the verts out a bit
        if (capSquare) {
          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);
          var out1 = _glMatrix.vec2.create();
          var out2 = _glMatrix.vec2.create();
          _glMatrix.vec2.add(out1, this.normal, lineA);
          _glMatrix.vec2.add(out2, this.normal, lineA);
          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }
      indices.push(index + 0, index + 1, index + 2);
      if (!next) {
        computeNormal(this.normal, lineA);
        if (capSquare) {
          var _out = _glMatrix.vec2.create();
          var _out2 = _glMatrix.vec2.create();
          _glMatrix.vec2.sub(_out2, lineA, this.normal);
          _glMatrix.vec2.add(_out, lineA, this.normal);
          normals.push(_out2[0], _out2[1], 0);
          normals.push(_out[0], _out[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }
        indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        // @ts-ignore
        if (isPointEqual(cur, next)) {
          _glMatrix.vec2.add(
          // @ts-ignore
          next,
          // @ts-ignore
          cur, _glMatrix.vec2.normalize(
          // @ts-ignore
          next,
          // @ts-ignore
          _glMatrix.vec2.subtract(next, cur, last)));
        }
        // @ts-ignore
        direction(lineB, next, cur);
        // stores tangent & miter

        var _computeMiter3 = computeMiter(tangent, _glMatrix.vec2.create(), lineA, lineB, this.thickness),
          _computeMiter4 = (0, _slicedToArray2.default)(_computeMiter3, 2),
          miterLen = _computeMiter4[0],
          miter = _computeMiter4[1];
        // normal(tmp, lineA)

        // get orientation
        var flip = _glMatrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;
        if (!bevel && this.join === 'miter') {
          var limit = miterLen;
          if (limit > this.miterLimit) {
            bevel = true;
          }
        }
        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));

          // now add the bevel triangle
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);
          _glMatrix.vec2.copy(this.normal, tmp); // store normal for next round
          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;

          // the miter is now the normal for our next join
          _glMatrix.vec2.copy(this.normal, miter);
          count += 2;
        }
        this.lastFlip = flip;
      }
      return count;
    }
  }, {
    key: "segment",
    value: function segment(complex, index, last, cur, next) {
      var count = 0;
      var indices = complex.indices;
      var positions = complex.positions;
      var normals = complex.normals;
      var capSquare = this.cap === 'square';
      var joinBevel = this.join === 'bevel';
      var flatCur = (0, _l7Utils.aProjectFlat)([cur[0], cur[1]]);
      var flatLast = (0, _l7Utils.aProjectFlat)([last[0], last[1]]);
      // @ts-ignore
      direction(lineA, flatCur, flatLast);
      var segmentDistance = 0;
      if (this.dash) {
        // @ts-ignore
        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);
        this.totalDistance += segmentDistance;
      }
      if (!this.normal) {
        this.normal = _glMatrix.vec2.create();
        computeNormal(this.normal, lineA);
      }
      if (!this.started) {
        this.started = true;

        // if the end cap is type square, we can just push the verts out a bit
        if (capSquare) {
          // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);
          var out1 = _glMatrix.vec2.create();
          var out2 = _glMatrix.vec2.create();
          _glMatrix.vec2.add(out1, this.normal, lineA);
          _glMatrix.vec2.add(out2, this.normal, lineA);
          normals.push(out2[0], out2[1], 0);
          normals.push(out1[0], out1[1], 0);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          // this.extrusions(positions, normals, last, out, this.thickness);
          // last = capEnd;
        } else {
          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);
        }
      }
      indices.push(index + 0, index + 1, index + 2);
      if (!next) {
        computeNormal(this.normal, lineA);
        if (capSquare) {
          // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);
          // cur = capEnd;
          var _out3 = _glMatrix.vec2.create();
          var _out4 = _glMatrix.vec2.create();
          _glMatrix.vec2.sub(_out4, lineA, this.normal);
          _glMatrix.vec2.add(_out3, lineA, this.normal);
          // this.extrusions(positions, normals, cur, out, this.thickness);
          normals.push(_out4[0], _out4[1], 0);
          normals.push(_out3[0], _out3[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
        } else {
          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);
        }

        // this.extrusions(positions, normals, cur, this.normal, this.thickness);
        indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
        count += 2;
      } else {
        var flatNext = (0, _l7Utils.aProjectFlat)([next[0], next[1]]);
        if (isPointEqual(flatCur, flatNext)) {
          _glMatrix.vec2.add(flatNext, flatCur, _glMatrix.vec2.normalize(flatNext, _glMatrix.vec2.subtract(flatNext, flatCur, flatLast)));
        }
        direction(lineB, flatNext, flatCur);

        // stores tangent & miter

        var _computeMiter5 = computeMiter(tangent, _glMatrix.vec2.create(), lineA, lineB, this.thickness),
          _computeMiter6 = (0, _slicedToArray2.default)(_computeMiter5, 2),
          miterLen = _computeMiter6[0],
          miter = _computeMiter6[1];
        // normal(tmp, lineA)

        // get orientation
        var flip = _glMatrix.vec2.dot(tangent, this.normal) < 0 ? -1 : 1;
        var bevel = joinBevel;
        if (!bevel && this.join === 'miter') {
          var limit = miterLen;
          if (limit > this.miterLimit) {
            bevel = true;
          }
        }
        if (bevel) {
          normals.push(this.normal[0], this.normal[1], 0);
          normals.push(miter[0], miter[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));

          // now add the bevel triangle
          indices.push(index + 2, index + 3, index + 4);
          computeNormal(tmp, lineB);
          _glMatrix.vec2.copy(this.normal, tmp); // store normal for next round
          normals.push(this.normal[0], this.normal[1], 0);
          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);
          this.complex.indexes.push(this.currentIndex);
          this.currentIndex++;
          count += 3;
        } else {
          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);
          indices.push.apply(indices, (0, _toConsumableArray2.default)(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));
          flip = -1;

          // the miter is now the normal for our next join
          _glMatrix.vec2.copy(this.normal, miter);
          count += 2;
        }
        this.lastFlip = flip;
      }
      return count;
    }
  }, {
    key: "extrusions",
    value: function extrusions(positions, normals, point,
    // 顶点
    normal,
    // 法向量
    thickness,
    // 高度
    distanceRadio) {
      normals.push(normal[0], normal[1], 0);
      normals.push(normal[0], normal[1], 0);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);
      this.complex.indexes.push(this.currentIndex);
      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);
      this.complex.indexes.push(this.currentIndex);
      this.currentIndex++;
    }
  }, {
    key: "lineSegmentDistance",
    value: function lineSegmentDistance(b1, a1) {
      var dx = a1[0] - b1[0];
      var dy = a1[1] - b1[1];
      return Math.sqrt(dx * dx + dy * dy);
    }
  }]);
  return ExtrudePolyline;
}();
exports.default = ExtrudePolyline;