"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _glMatrix = require("gl-matrix");
var _gridIndex = _interopRequireDefault(require("./grid-index"));
// @mapbox/grid-index 并没有类似 hitTest 的单纯获取碰撞检测结果的方法，query 将导致计算大量多余的包围盒结果，因此使用改良版
/**
 * 基于网格实现文本避让，大幅提升包围盒碰撞检测效率
 * @see https://zhuanlan.zhihu.com/p/74373214
 */
var CollisionIndex = /*#__PURE__*/function () {
  function CollisionIndex(width, height) {
    (0, _classCallCheck2.default)(this, CollisionIndex);
    (0, _defineProperty2.default)(this, "viewportPadding", 100);
    this.width = width;
    this.height = height;
    this.viewportPadding = Math.max(width, height);
    // 创建网格索引
    this.grid = new _gridIndex.default(width + this.viewportPadding, height + this.viewportPadding, 25);
    this.screenRightBoundary = width + this.viewportPadding;
    this.screenBottomBoundary = height + this.viewportPadding;
    this.gridRightBoundary = width + 2 * this.viewportPadding;
    this.gridBottomBoundary = height + 2 * this.viewportPadding;
  }
  (0, _createClass2.default)(CollisionIndex, [{
    key: "placeCollisionBox",
    value: function placeCollisionBox(collisionBox) {
      // const projectedPoint = this.project(
      //   mvpMatrix,
      //   collisionBox.anchorPointX,
      //   collisionBox.anchorPointY,
      // );

      var tlX = collisionBox.x1 + collisionBox.anchorPointX + this.viewportPadding;
      var tlY = collisionBox.y1 + collisionBox.anchorPointY + this.viewportPadding;
      var brX = collisionBox.x2 + collisionBox.anchorPointX + this.viewportPadding;
      var brY = collisionBox.y2 + collisionBox.anchorPointY + this.viewportPadding;
      if (!this.isInsideGrid(tlX, tlY, brX, brY) || this.grid.hitTest(tlX, tlY, brX, brY)) {
        return {
          box: []
        };
      }
      return {
        box: [tlX, tlY, brX, brY]
      };
    }
  }, {
    key: "insertCollisionBox",
    value: function insertCollisionBox(box, featureIndex) {
      var key = {
        featureIndex: featureIndex
      };
      this.grid.insert(key, box[0], box[1], box[2], box[3]);
    }

    /**
     * 后续碰撞检测都需要投影到 viewport 坐标系
     * @param {THREE.Matrix4} mvpMatrix mvp矩阵
     * @param {number} x P20 平面坐标X
     * @param {number} y P20 平面坐标Y
     * @return {Point} projectedPoint
     */
  }, {
    key: "project",
    value: function project(mvpMatrix, x, y) {
      var point = _glMatrix.vec4.fromValues(x, y, 0, 1);
      var out = _glMatrix.vec4.create();
      // @ts-ignore
      var mat = _glMatrix.mat4.fromValues.apply(_glMatrix.mat4, (0, _toConsumableArray2.default)(mvpMatrix));
      _glMatrix.vec4.transformMat4(out, point, mat);
      // GL 坐标系[-1, 1] -> viewport 坐标系[width, height]
      return {
        x: (out[0] / out[3] + 1) / 2 * this.width + this.viewportPadding,
        y: (-out[1] / out[3] + 1) / 2 * this.height + this.viewportPadding
      };
    }

    /**
     * 判断包围盒是否在整个网格内，需要加上 buffer
     * @param {number} x1 x1
     * @param {number} y1 y1
     * @param {number} x2 x2
     * @param {number} y2 y2
     * @return {Point} isInside
     */
  }, {
    key: "isInsideGrid",
    value: function isInsideGrid(x1, y1, x2, y2) {
      return x2 >= 0 && x1 < this.gridRightBoundary && y2 >= 0 && y1 < this.gridBottomBoundary;
    }
  }]);
  return CollisionIndex;
}();
exports.default = CollisionIndex;