"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGlyphQuads = getGlyphQuads;
exports.shapeText = shapeText;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * 返回文本相对锚点位置
 * @param {string} anchor 锚点位置
 * @return {alignment} alignment
 */
function getAnchorAlignment(anchor) {
  var horizontalAlign = 0.5;
  var verticalAlign = 0.5;
  switch (anchor) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
      horizontalAlign = 1;
      break;
    case 'left':
    case 'top-left':
    case 'bottom-left':
      horizontalAlign = 0;
      break;
    default:
      horizontalAlign = 0.5;
  }
  switch (anchor) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
      verticalAlign = 1;
      break;
    case 'top':
    case 'top-right':
    case 'top-left':
      verticalAlign = 0;
      break;
    default:
      verticalAlign = 0.5;
  }
  return {
    horizontalAlign: horizontalAlign,
    verticalAlign: verticalAlign
  };
}

// justify right = 1, left = 0, center = 0.5
function justifyLine(positionedGlyphs, glyphMap, start, end, justify) {
  if (!justify) {
    return;
  }
  var lastPositionedGlyph = positionedGlyphs[end];
  var glyph = lastPositionedGlyph.glyph;
  if (glyph) {
    var lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;
    for (var j = start; j <= end; j++) {
      positionedGlyphs[j].x -= lineIndent;
    }
  }
}

// justify right=1 left=0 center=0.5
// horizontalAlign right=1 left=0 center=0.5
// verticalAlign right=1 left=0 center=0.5
function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {
  var shiftX = (justify - horizontalAlign) * maxLineLength;
  var shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;
  var _iterator = _createForOfIteratorHelper(positionedGlyphs),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var glyphs = _step.value;
      glyphs.x += shiftX;
      glyphs.y += shiftY;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {
  // buffer 为 4
  var yOffset = -8;
  var x = 0;
  var y = yOffset;
  var maxLineLength = 0;
  var positionedGlyphs = shaping.positionedGlyphs;
  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;
  var lineStartIndex = positionedGlyphs.length;
  lines.forEach(function (line) {
    line.split('').forEach(function (char) {
      var glyph = glyphMap[char];
      var baselineOffset = 0;
      if (glyph) {
        positionedGlyphs.push({
          glyph: char,
          x: x,
          y: y + baselineOffset,
          vertical: false,
          // TODO：目前只支持水平方向
          scale: 1,
          metrics: glyph
        });
        x += glyph.advance + spacing;
      }
    });

    // 左右对齐
    if (positionedGlyphs.length !== lineStartIndex) {
      var lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }
    x = 0;
    y -= lineHeight + 5;
  });
  var _getAnchorAlignment = getAnchorAlignment(textAnchor),
    horizontalAlign = _getAnchorAlignment.horizontalAlign,
    verticalAlign = _getAnchorAlignment.verticalAlign;
  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);

  // 计算包围盒
  var height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top - height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}
function shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {
  // buffer 为 4
  var yOffset = -8;
  var x = 0;
  var y = yOffset;
  var maxLineLength = 0;
  var positionedGlyphs = shaping.positionedGlyphs;
  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;
  var lineStartIndex = positionedGlyphs.length;
  iconfonts.forEach(function (iconfont) {
    var glyph = glyphMap[iconfont];
    var baselineOffset = 0;
    if (glyph) {
      positionedGlyphs.push({
        glyph: iconfont,
        // x,
        /**
         * iconfont
         * 在计算大小的时候计算的是 unicode 字符 如 &#xe6d4;
         * 在布局计算 icon 位置的时候应该始终保持居中（且 icon 只占一个字符的位置）
         */
        x: glyph.advance / 2,
        y: y + baselineOffset,
        vertical: false,
        // TODO：目前只支持水平方向
        scale: 1,
        metrics: glyph
      });
      x += glyph.advance + spacing;
    }

    // 左右对齐
    if (positionedGlyphs.length !== lineStartIndex) {
      var lineLength = x - spacing;
      maxLineLength = Math.max(lineLength, maxLineLength);
      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);
    }
    x = 0;
    y -= lineHeight + 5;
  });
  var _getAnchorAlignment2 = getAnchorAlignment(textAnchor),
    horizontalAlign = _getAnchorAlignment2.horizontalAlign,
    verticalAlign = _getAnchorAlignment2.verticalAlign;
  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);

  // 计算包围盒
  var height = y - yOffset;
  shaping.top += -verticalAlign * height;
  shaping.bottom = shaping.top - height;
  shaping.left += -horizontalAlign * maxLineLength;
  shaping.right = shaping.left + maxLineLength;
}

/**
 * 计算文本中每个独立字符相对锚点的位置
 *
 * @param {string} text 原始文本
 * @param {*} glyphs mapping
 * @param {number} lineHeight 行高
 * @param {string} textAnchor 文本相对于锚点的位置
 * @param {string} textJustify 左右对齐
 * @param {number} spacing 字符间距
 * @param {[number, number]} translate 文本水平 & 垂直偏移量
 * @param {[boolean]} isIconFont 是否是 iconfont
 * @return {boolean|shaping} 每个字符相对于锚点的位置
 */
function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing) {
  var translate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [0, 0];
  var isIconFont = arguments.length > 7 ? arguments[7] : undefined;
  // TODO：处理换行
  var lines = text.split('\n');
  var positionedGlyphs = [];
  var shaping = {
    positionedGlyphs: positionedGlyphs,
    top: translate[1],
    bottom: translate[1],
    left: translate[0],
    right: translate[0],
    lineCount: lines.length,
    text: text
  };
  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);
  if (!positionedGlyphs.length) {
    return false;
  }
  return shaping;
}
function getGlyphQuads(shaping) {
  var textOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];
  var alongLine = arguments.length > 2 ? arguments[2] : undefined;
  var _shaping$positionedGl = shaping.positionedGlyphs,
    positionedGlyphs = _shaping$positionedGl === void 0 ? [] : _shaping$positionedGl;
  var quads = [];
  var _iterator2 = _createForOfIteratorHelper(positionedGlyphs),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var positionedGlyph = _step2.value;
      var rect = positionedGlyph.metrics;

      // The rects have an addditional buffer that is not included in their size.
      var rectBuffer = 4;
      var halfAdvance = rect.advance * positionedGlyph.scale / 2;
      var glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];
      var builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];
      var x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];
      var y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];
      var x2 = x1 + rect.width * positionedGlyph.scale;
      var y2 = y1 + rect.height * positionedGlyph.scale;
      var tl = {
        x: x1,
        y: y1
      };
      var tr = {
        x: x2,
        y: y1
      };
      var bl = {
        x: x1,
        y: y2
      };
      var br = {
        x: x2,
        y: y2
      };

      // TODO：处理字符旋转的情况

      quads.push({
        tl: tl,
        tr: tr,
        bl: bl,
        br: br,
        tex: rect,
        glyphOffset: glyphOffset
      });
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return quads;
}