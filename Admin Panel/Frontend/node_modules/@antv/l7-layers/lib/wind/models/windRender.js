"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wind = void 0;
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var glUtils = _interopRequireWildcard(require("./utils"));
var _windShader = require("./windShader");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function getColorRamp(colors) {
  var canvas = document.createElement('canvas');
  var ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 1;
  var gradient = ctx.createLinearGradient(0, 0, 256, 0);
  for (var _i = 0, _Object$keys = Object.keys(colors); _i < _Object$keys.length; _i++) {
    var stop = _Object$keys[_i];
    gradient.addColorStop(+stop, colors[+stop]);
  }
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, 256, 1);

  // @ts-ignore dispose canvas element
  canvas = null;
  return new Uint8Array(ctx.getImageData(0, 0, 256, 1).data);
}
function bindAttribute(gl, buffer, attribute, numComponents) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.enableVertexAttribArray(attribute);
  gl.vertexAttribPointer(attribute, numComponents, gl.FLOAT, false, 0, 0);
}
function bindFramebuffer(gl, framebuffer, texture) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  if (texture) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  }
}
var Wind = /*#__PURE__*/function () {
  function Wind(options) {
    (0, _classCallCheck2.default)(this, Wind);
    (0, _defineProperty2.default)(this, "width", 512);
    (0, _defineProperty2.default)(this, "height", 512);
    (0, _defineProperty2.default)(this, "numParticles", 65536);
    this.gl = options.glContext;
    this.width = options.imageWidth;
    this.height = options.imageHeight;
    this.fadeOpacity = options.fadeOpacity;
    this.speedFactor = options.speedFactor;
    this.dropRate = options.dropRate;
    this.dropRateBump = options.dropRateBump;
    this.rampColors = options.rampColors;
    this.init();
  }
  (0, _createClass2.default)(Wind, [{
    key: "init",
    value: function init() {
      var gl = this.gl;
      this.fadeOpacity = 0.996; // how fast the particle trails fade on each frame
      this.speedFactor = 0.25; // how fast the particles move
      this.dropRate = 0.003; // how often the particles move to a random place
      this.dropRateBump = 0.01; // drop rate increase relative to individual particle speed

      this.drawProgram = glUtils.createProgram(gl, _windShader.drawVert, _windShader.drawFrag);
      this.fullScreenProgram = glUtils.createProgram(gl, _windShader.fullScreenVert, _windShader.fullScreenFrag);
      this.updateProgram = glUtils.createProgram(gl, _windShader.updateVert, _windShader.updateFrag);
      this.quadBuffer = glUtils.createBuffer(gl, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]));
      this.framebuffer = gl.createFramebuffer();
      this.colorRampTexture = glUtils.createTexture(this.gl, this.gl.LINEAR, getColorRamp(this.rampColors), 16, 16);
      var emptyPixels = new Uint8Array(this.width * this.height * 4);

      // screen textures to hold the drawn screen for the previous and the current frame

      this.backgroundTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, this.width, this.height);
      this.screenTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, this.width, this.height);

      // we create a square texture where each pixel will hold a particle position encoded as RGBA
      var particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
      // particleRes size
      this.numParticlesSize = particleRes * particleRes;
      var particleState = new Uint8Array(this.numParticlesSize * 4);
      for (var i = 0; i < particleState.length; i++) {
        particleState[i] = Math.floor(Math.random() * 256); // randomize the initial particle positions
      }
      // textures to hold the particle state for the current and the next frame
      this.particleStateTexture0 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
      this.particleStateTexture1 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
      var particleIndices = new Float32Array(this.numParticlesSize);
      for (var i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
        particleIndices[i$1] = i$1;
      }
      this.particleIndexBuffer = glUtils.createBuffer(gl, particleIndices);
    }
  }, {
    key: "setWind",
    value: function setWind(windData) {
      this.windData = windData;
      this.windTexture = glUtils.createDataTexture(this.gl, this.gl.LINEAR, windData.image);
    }

    /**
     * 更新风场粒子数量
     * @param num
     */
  }, {
    key: "updateParticelNum",
    value: function updateParticelNum(num) {
      var gl = this.gl;
      if (num !== this.numParticles) {
        this.numParticles = num; // params number

        // we create a square texture where each pixel will hold a particle position encoded as RGBA
        var particleRes = this.particleStateResolution = Math.ceil(Math.sqrt(this.numParticles));
        this.numParticlesSize = particleRes * particleRes;
        var particleState = new Uint8Array(this.numParticlesSize * 4);
        for (var i = 0; i < particleState.length; i++) {
          particleState[i] = Math.floor(Math.random() * 256); // randomize the initial particle positions
        }
        // textures to hold the particle state for the current and the next frame
        this.particleStateTexture0 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
        this.particleStateTexture1 = glUtils.createTexture(gl, gl.NEAREST, particleState, particleRes, particleRes);
        var particleIndices = new Float32Array(this.numParticlesSize);
        for (var i$1 = 0; i$1 < this.numParticlesSize; i$1++) {
          particleIndices[i$1] = i$1;
        }
        this.particleIndexBuffer = glUtils.createBuffer(gl, particleIndices);
      }
    }

    /**
     * 更新风场风向风速
     * @param uMin
     * @param uMax
     * @param vMin
     * @param vMax
     */
  }, {
    key: "updateWindDir",
    value: function updateWindDir(uMin, uMax, vMin, vMax) {
      this.windData.uMin = uMin;
      this.windData.uMax = uMax;
      this.windData.vMin = vMin;
      this.windData.vMax = vMax;
    }

    /**
     * update rampColors
     * @param rampColors
     */
  }, {
    key: "updateColorRampTexture",
    value: function updateColorRampTexture(rampColors) {
      if (this.isColorChanged(rampColors)) {
        this.rampColors = rampColors;
        var gl = this.gl;
        gl.deleteTexture(this.colorRampTexture);
        this.colorRampTexture = glUtils.createTexture(gl, gl.LINEAR, getColorRamp(rampColors), 16, 16);
      }
    }
  }, {
    key: "isColorChanged",
    value: function isColorChanged(rampColors) {
      var keys = Object.keys(rampColors);
      for (var _i2 = 0, _keys = keys; _i2 < _keys.length; _i2++) {
        var item = _keys[_i2];
        var _key = Number(item);
        // exist new key -> color need update
        if (!this.rampColors[_key]) {
          return true;
        }
        // value changed -> color need update
        if (this.rampColors[_key] && this.rampColors[_key] !== rampColors[_key]) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "reSize",
    value: function reSize(width, height) {
      if (width !== this.width || height !== this.height) {
        var gl = this.gl;
        gl.deleteTexture(this.backgroundTexture);
        gl.deleteTexture(this.screenTexture);
        this.width = width;
        this.height = height;
        var emptyPixels = new Uint8Array(width * height * 4);
        // screen textures to hold the drawn screen for the previous and the current frame
        this.backgroundTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, width, height);
        this.screenTexture = glUtils.createTexture(gl, gl.NEAREST, emptyPixels, width, height);
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this$windData;
      if ((_this$windData = this.windData) !== null && _this$windData !== void 0 && _this$windData.image) {
        var gl = this.gl;
        glUtils.bindTexture(gl, this.windTexture, 0);
        glUtils.bindTexture(gl, this.particleStateTexture0, 1);
        this.drawScreen(); // draw Particles into framebuffer
        this.updateParticles();
        return {
          d: this.pixels,
          w: this.width,
          h: this.height
        };
      } else {
        return {
          d: new Uint8Array([0, 0, 0, 0]),
          w: 1,
          h: 1
        };
      }
    }
  }, {
    key: "drawScreen",
    value: function drawScreen() {
      var gl = this.gl;

      // draw the screen into a temporary framebuffer to retain it as the background on the next frame
      bindFramebuffer(gl, this.framebuffer, this.screenTexture);
      gl.viewport(0, 0, this.width, this.height);
      gl.disable(gl.BLEND);
      this.drawFullTexture(this.backgroundTexture, this.fadeOpacity);
      this.drawParticles();
      this.pixels = new Uint8Array(4 * this.width * this.height);
      gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.pixels);
      bindFramebuffer(gl, null, null);
      gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);

      //   save the current screen as the background for the next frame
      var temp = this.backgroundTexture;
      this.backgroundTexture = this.screenTexture;
      this.screenTexture = temp;
    }
  }, {
    key: "drawFullTexture",
    value: function drawFullTexture(texture, opacity) {
      var gl = this.gl;
      var program = this.fullScreenProgram;
      gl.useProgram(program);

      // bindAttribute(gl, this.quadBuffer, program.a_pos, 2);

      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
      gl.vertexAttribPointer(program.a_pos, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(program.a_pos);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      glUtils.bindTexture(gl, texture, 2);
      gl.uniform1i(program.u_screen, 2);
      gl.uniform1f(program.u_opacity, opacity);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      // gl.drawArrays(gl.POINTS, 0, 6);
    }
  }, {
    key: "drawParticles",
    value: function drawParticles() {
      var gl = this.gl;
      var program = this.drawProgram;
      gl.useProgram(program);
      bindAttribute(gl, this.particleIndexBuffer, program.a_index, 1);
      glUtils.bindTexture(gl, this.colorRampTexture, 2);
      gl.uniform1i(program.u_wind, 0);
      gl.uniform1i(program.u_particles, 1);
      gl.uniform1i(program.u_color_ramp, 2);
      gl.uniform1f(program.u_particles_res, this.particleStateResolution);
      gl.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
      gl.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
      gl.drawArrays(gl.POINTS, 0, this.numParticlesSize);
    }
  }, {
    key: "updateParticles",
    value: function updateParticles() {
      var gl = this.gl;
      bindFramebuffer(gl, this.framebuffer, this.particleStateTexture1);
      gl.viewport(0, 0, this.particleStateResolution, this.particleStateResolution);
      var program = this.updateProgram;
      gl.useProgram(program);
      bindAttribute(gl, this.quadBuffer, program.a_pos, 2);
      gl.uniform1i(program.u_wind, 0);
      gl.uniform1i(program.u_particles, 1);
      gl.uniform1f(program.u_rand_seed, Math.random());
      gl.uniform2f(program.u_wind_res, this.windData.image.width * 2, this.windData.image.height * 2);
      gl.uniform2f(program.u_wind_min, this.windData.uMin, this.windData.vMin);
      gl.uniform2f(program.u_wind_max, this.windData.uMax, this.windData.vMax);
      gl.uniform1f(program.u_speed_factor, this.speedFactor);
      gl.uniform1f(program.u_drop_rate, this.dropRate);
      gl.uniform1f(program.u_drop_rate_bump, this.dropRateBump);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // swap the particle state textures so the new one becomes the current one
      var temp = this.particleStateTexture0;
      this.particleStateTexture0 = this.particleStateTexture1;
      this.particleStateTexture1 = temp;
      bindFramebuffer(gl, null, null);

      // gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // private drawProgram: WebGLProgram;
      // private fullScreenProgram: WebGLProgram;
      // private updateProgram: WebGLProgram;

      // private quadBuffer: WebGLBuffer | null;
      // private particleIndexBuffer: WebGLBuffer | null;

      // private framebuffer: WebGLFramebuffer | null;

      // private colorRampTexture: WebGLTexture | null;
      // private backgroundTexture: WebGLTexture | null;
      // private screenTexture: WebGLTexture | null;
      // private particleStateTexture0: WebGLTexture | null;
      // private particleStateTexture1: WebGLTexture | null;
      // private windTexture: WebGLTexture | null;

      this.gl.deleteBuffer(this.quadBuffer);
      this.gl.deleteBuffer(this.particleIndexBuffer);
      this.gl.deleteFramebuffer(this.framebuffer);

      // @ts-ignore
      this.gl.deleteShader(this.drawProgram.vertexShader);
      // @ts-ignore
      this.gl.deleteShader(this.drawProgram.fragmentShader);
      this.gl.deleteProgram(this.drawProgram);

      // @ts-ignore
      this.gl.deleteShader(this.fullScreenProgram.vertexShader);
      // @ts-ignore
      this.gl.deleteShader(this.fullScreenProgram.fragmentShader);
      this.gl.deleteProgram(this.fullScreenProgram);

      // @ts-ignore
      this.gl.deleteShader(this.updateProgram.vertexShader);
      // @ts-ignore
      this.gl.deleteShader(this.updateProgram.fragmentShader);
      this.gl.deleteProgram(this.updateProgram);
      this.gl.deleteTexture(this.colorRampTexture);
      this.gl.deleteTexture(this.backgroundTexture);
      this.gl.deleteTexture(this.screenTexture);
      this.gl.deleteTexture(this.particleStateTexture0);
      this.gl.deleteTexture(this.particleStateTexture1);
      this.gl.deleteTexture(this.windTexture);
    }
  }]);
  return Wind;
}();
exports.Wind = Wind;