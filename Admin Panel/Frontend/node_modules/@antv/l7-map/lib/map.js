"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Map = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _lodash = require("lodash");
var _camera = _interopRequireDefault(require("./camera"));
var _lng_lat = _interopRequireDefault(require("./geo/lng_lat"));
var _lng_lat_bounds = _interopRequireDefault(require("./geo/lng_lat_bounds"));
var _point = _interopRequireDefault(require("./geo/point"));
var _handler_manager = _interopRequireDefault(require("./handler/handler_manager"));
var _hash = _interopRequireDefault(require("./hash"));
var _util = require("./util");
var _performance = require("./utils/performance");
var _task_queue = _interopRequireDefault(require("./utils/task_queue"));
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(".l7-map {\n  font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;\n  overflow: hidden;\n  position: relative;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.l7-canvas {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.l7-map:-webkit-full-screen {\n  width: 100%;\n  height: 100%;\n}\n\n.l7-canary {\n  background-color: salmon;\n}\n\n.l7-canvas-container.l7-interactive,\n.l7-ctrl-group button.l7-ctrl-compass {\n  cursor: -webkit-grab;\n  cursor: grab;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\n.l7-canvas-container.l7-interactive.l7-track-pointer {\n  cursor: pointer;\n}\n\n.l7-canvas-container.l7-interactive:active,\n.l7-ctrl-group button.l7-ctrl-compass:active {\n  cursor: -webkit-grabbing;\n  cursor: grabbing;\n}\n\n.l7-canvas-container.l7-touch-zoom-rotate,\n.l7-canvas-container.l7-touch-zoom-rotate .l7-canvas {\n  -ms-touch-action: pan-x pan-y;\n      touch-action: pan-x pan-y;\n}\n\n.l7-canvas-container.l7-touch-drag-pan,\n.l7-canvas-container.l7-touch-drag-pan .l7-canvas {\n  -ms-touch-action: pinch-zoom;\n      touch-action: pinch-zoom;\n}\n\n.l7-canvas-container.l7-touch-zoom-rotate.l7-touch-drag-pan,\n.l7-canvas-container.l7-touch-zoom-rotate.l7-touch-drag-pan .l7-canvas {\n  -ms-touch-action: none;\n      touch-action: none;\n}\n\n.l7-ctrl-top-left,\n.l7-ctrl-top-right,\n.l7-ctrl-bottom-left,\n.l7-ctrl-bottom-right { position: absolute; pointer-events: none; z-index: 2; }\n.l7-ctrl-top-left     { top: 0; left: 0; }\n.l7-ctrl-top-right    { top: 0; right: 0; }\n.l7-ctrl-bottom-left  { bottom: 0; left: 0; }\n.l7-ctrl-bottom-right { right: 0; bottom: 0; }\n\n.l7-ctrl {\n  clear: both;\n  pointer-events: auto;\n\n  /* workaround for a Safari bug https://github.com/mapbox/mapbox-gl-js/issues/8185 */\n  -webkit-transform: translate(0, 0);\n          transform: translate(0, 0);\n}\n.l7-ctrl-top-left .l7-ctrl     { margin: 10px 0 0 10px; float: left; }\n.l7-ctrl-top-right .l7-ctrl    { margin: 10px 10px 0 0; float: right; }\n.l7-ctrl-bottom-left .l7-ctrl  { margin: 0 0 10px 10px; float: left; }\n.l7-ctrl-bottom-right .l7-ctrl { margin: 0 10px 10px 0; float: right; }\n\n\n.l7-crosshair,\n.l7-crosshair .l7-interactive,\n.l7-crosshair .l7-interactive:active {\n    cursor: crosshair;\n}\n\n.l7-boxzoom {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 0;\n    height: 0;\n    background: #fff;\n    border: 2px dotted #202020;\n    opacity: 0.5;\n    z-index: 10;\n}\n");
var defaultMinZoom = -2;
var defaultMaxZoom = 22;

// the default values, but also the valid range
var defaultMinPitch = 0;
var defaultMaxPitch = 60;
var DefaultOptions = {
  hash: false,
  zoom: -1,
  center: [112, 32],
  pitch: 0,
  bearing: 0,
  interactive: true,
  minZoom: defaultMinZoom,
  maxZoom: defaultMaxZoom,
  minPitch: defaultMinPitch,
  maxPitch: defaultMaxPitch,
  scrollZoom: true,
  boxZoom: true,
  dragRotate: true,
  dragPan: true,
  keyboard: true,
  doubleClickZoom: true,
  touchZoomRotate: true,
  touchPitch: true,
  bearingSnap: 7,
  clickTolerance: 3,
  pitchWithRotate: true,
  trackResize: true,
  renderWorldCopies: true,
  pitchEnabled: true,
  rotateEnabled: true
};
var Map = /*#__PURE__*/function (_Camera) {
  (0, _inherits2.default)(Map, _Camera);
  var _super = _createSuper(Map);
  function Map(options) {
    var _this;
    (0, _classCallCheck2.default)(this, Map);
    _this = _super.call(this, (0, _lodash.merge)({}, DefaultOptions, options));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderTaskQueue", new _task_queue.default());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "trackResize", true);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onWindowOnline", function () {
      _this.update();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "onWindowResize", function (event) {
      if (_this.trackResize) {
        _this.resize({
          originalEvent: event
        }).update();
      }
    });
    if (_l7Utils.isMini) {
      _this.initMiniContainer();
    } else {
      _this.initContainer();
    }
    _this.resize();
    _this.handlers = new _handler_manager.default((0, _assertThisInitialized2.default)(_this), _this.options);
    if (typeof window !== 'undefined') {
      window.addEventListener('online', _this.onWindowOnline, false);
      window.addEventListener('resize', _this.onWindowResize, false);
      window.addEventListener('orientationchange', _this.onWindowResize, false);
    }
    if (!_l7Utils.isMini) {
      var hashName = typeof options.hash === 'string' && options.hash || undefined;
      if (options.hash) {
        _this.hash = new _hash.default(hashName).addTo((0, _assertThisInitialized2.default)(_this));
      }
    }

    // don't set position from options if set through hash
    if (!_this.hash || !_this.hash.onHashChange()) {
      _this.jumpTo({
        center: options.center,
        zoom: options.zoom,
        bearing: options.bearing,
        pitch: options.pitch
      });
      if (options.bounds) {
        _this.resize();
        _this.fitBounds(options.bounds, (0, _lodash.merge)({}, options.fitBoundsOptions, {
          duration: 0
        }));
      }
    }
    return _this;
  }
  (0, _createClass2.default)(Map, [{
    key: "resize",
    value: function resize(eventData) {
      var _this$containerDimens = this.containerDimensions(),
        _this$containerDimens2 = (0, _slicedToArray2.default)(_this$containerDimens, 2),
        width = _this$containerDimens2[0],
        height = _this$containerDimens2[1];
      this.transform.resize(width, height);
      // 小程序环境不需要执行后续动作
      if (_l7Utils.isMini) {
        return this;
      }
      var fireMoving = !this.moving;
      if (fireMoving) {
        this.stop();
        this.emit('movestart', new _l7Utils.$window.Event('movestart', eventData));
        this.emit('move', new _l7Utils.$window.Event('move', eventData));
      }
      this.emit('resize', new _l7Utils.$window.Event('resize', eventData));
      if (fireMoving) {
        this.emit('moveend', new _l7Utils.$window.Event('moveend', eventData));
      }
      return this;
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }
  }, {
    key: "getCanvas",
    value: function getCanvas() {
      return this.canvas;
    }
  }, {
    key: "getCanvasContainer",
    value: function getCanvasContainer() {
      return this.canvasContainer;
    }
  }, {
    key: "project",
    value: function project(lngLat) {
      return this.transform.locationPoint(_lng_lat.default.convert(lngLat));
    }
  }, {
    key: "unproject",
    value: function unproject(point) {
      return this.transform.pointLocation(_point.default.convert(point));
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      return this.transform.getBounds();
    }
  }, {
    key: "getMaxBounds",
    value: function getMaxBounds() {
      return this.transform.getMaxBounds();
    }
  }, {
    key: "setMaxBounds",
    value: function setMaxBounds(bounds) {
      this.transform.setMaxBounds(_lng_lat_bounds.default.convert(bounds));
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "setStyle",
    value: function setStyle(style) {
      return;
    }
  }, {
    key: "setMinZoom",
    value: function setMinZoom(minZoom) {
      minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;
      if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
        this.transform.minZoom = minZoom;
        if (this.getZoom() < minZoom) {
          this.setZoom(minZoom);
        }
        return this;
      } else {
        throw new Error("minZoom must be between ".concat(defaultMinZoom, " and the current maxZoom, inclusive"));
      }
    }
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return this.transform.minZoom;
    }
  }, {
    key: "setMaxZoom",
    value: function setMaxZoom(maxZoom) {
      maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;
      if (maxZoom >= this.transform.minZoom) {
        this.transform.maxZoom = maxZoom;
        if (this.getZoom() > maxZoom) {
          this.setZoom(maxZoom);
        }
        return this;
      } else {
        throw new Error('maxZoom must be greater than the current minZoom');
      }
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return this.transform.maxZoom;
    }
  }, {
    key: "setMinPitch",
    value: function setMinPitch(minPitch) {
      minPitch = minPitch === null || minPitch === undefined ? defaultMinPitch : minPitch;
      if (minPitch < defaultMinPitch) {
        throw new Error("minPitch must be greater than or equal to ".concat(defaultMinPitch));
      }
      if (minPitch >= defaultMinPitch && minPitch <= this.transform.maxPitch) {
        this.transform.minPitch = minPitch;
        if (this.getPitch() < minPitch) {
          this.setPitch(minPitch);
        }
        return this;
      } else {
        throw new Error("minPitch must be between ".concat(defaultMinPitch, " and the current maxPitch, inclusive"));
      }
    }
  }, {
    key: "getMinPitch",
    value: function getMinPitch() {
      return this.transform.minPitch;
    }
  }, {
    key: "setMaxPitch",
    value: function setMaxPitch(maxPitch) {
      maxPitch = maxPitch === null || maxPitch === undefined ? defaultMaxPitch : maxPitch;
      if (maxPitch > defaultMaxPitch) {
        throw new Error("maxPitch must be less than or equal to ".concat(defaultMaxPitch));
      }
      if (maxPitch >= this.transform.minPitch) {
        this.transform.maxPitch = maxPitch;
        if (this.getPitch() > maxPitch) {
          this.setPitch(maxPitch);
        }
        return this;
      } else {
        throw new Error('maxPitch must be greater than the current minPitch');
      }
    }
  }, {
    key: "getMaxPitch",
    value: function getMaxPitch() {
      return this.transform.maxPitch;
    }
  }, {
    key: "getRenderWorldCopies",
    value: function getRenderWorldCopies() {
      return this.transform.renderWorldCopies;
    }
  }, {
    key: "setRenderWorldCopies",
    value: function setRenderWorldCopies(renderWorldCopies) {
      this.transform.renderWorldCopies = !!renderWorldCopies;
    }
  }, {
    key: "remove",
    value: function remove() {
      this.container.removeChild(this.canvasContainer);
      // @ts-ignore
      this.canvasContainer = null;
      if (this.frame) {
        this.frame.cancel();
        this.frame = null;
      }
      this.renderTaskQueue.clear();
    }
  }, {
    key: "requestRenderFrame",
    value: function requestRenderFrame(cb) {
      this.update();
      return this.renderTaskQueue.add(cb);
    }
  }, {
    key: "cancelRenderFrame",
    value: function cancelRenderFrame(id) {
      return this.renderTaskQueue.remove(id);
    }
  }, {
    key: "triggerRepaint",
    value: function triggerRepaint() {
      var _this2 = this;
      if (!this.frame) {
        this.frame = (0, _util.renderframe)(function (paintStartTimeStamp) {
          _performance.PerformanceUtils.frame(paintStartTimeStamp);
          _this2.frame = null;
          _this2.update(paintStartTimeStamp);
        });
      }
    }
  }, {
    key: "update",
    value: function update(time) {
      var _this3 = this;
      if (!this.frame) {
        this.frame = (0, _util.renderframe)(function (paintStartTimeStamp) {
          _performance.PerformanceUtils.frame(paintStartTimeStamp);
          _this3.frame = null;
          _this3.renderTaskQueue.run(time);
        });
      }
    }
  }, {
    key: "initContainer",
    value: function initContainer() {
      if (typeof this.options.container === 'string') {
        this.container = window.document.getElementById(this.options.container);
        if (!this.container) {
          throw new Error("Container '".concat(this.options.container, "' not found."));
        }
      } else if (this.options.container instanceof HTMLElement) {
        this.container = this.options.container;
      } else {
        throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
      }
      var container = this.container;
      container.classList.add('l7-map');
      var canvasContainer = this.canvasContainer = _l7Utils.DOM.create('div', 'l7-canvas-container', container);
      if (this.options.interactive) {
        canvasContainer.classList.add('l7-interactive');
      }
    }

    /**
     * 小程序环境构建容器
     */
  }, {
    key: "initMiniContainer",
    value: function initMiniContainer() {
      this.container = this.options.canvas;
      this.canvasContainer = this.container;
    }
  }, {
    key: "containerDimensions",
    value: function containerDimensions() {
      var width = 0;
      var height = 0;
      if (this.container) {
        if (_l7Utils.isMini) {
          width = this.container.width / _l7Utils.$window.devicePixelRatio;
          height = this.container.height / _l7Utils.$window.devicePixelRatio;
        } else {
          width = this.container.clientWidth;
          height = this.container.clientHeight;
          width = width === 0 ? 400 : width;
          height = height === 0 ? 300 : height;
        }
      }
      return [width, height];
    }
  }]);
  return Map;
}(_camera.default);
exports.Map = Map;