import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
// @ts-ignore
import Point from "../geo/point";

// tslint:disable-next-line:no-submodule-imports
import merge from 'lodash/merge';
import { bezier, clamp, now } from "../util";
var defaultInertiaOptions = {
  linearity: 0.3,
  easing: bezier(0, 0, 0.3, 1)
};
var defaultPanInertiaOptions = merge({
  deceleration: 2500,
  maxSpeed: 1400
}, defaultInertiaOptions);
var defaultZoomInertiaOptions = merge({
  deceleration: 20,
  maxSpeed: 1400
}, defaultInertiaOptions);
var defaultBearingInertiaOptions = merge({
  deceleration: 1000,
  maxSpeed: 360
}, defaultInertiaOptions);
var defaultPitchInertiaOptions = merge({
  deceleration: 1000,
  maxSpeed: 90
}, defaultInertiaOptions);
var HandlerInertia = /*#__PURE__*/function () {
  function HandlerInertia(map) {
    _classCallCheck(this, HandlerInertia);
    this.map = map;
    this.clear();
  }
  _createClass(HandlerInertia, [{
    key: "clear",
    value: function clear() {
      this.inertiaBuffer = [];
    }
  }, {
    key: "record",
    value: function record(settings) {
      this.drainInertiaBuffer();
      this.inertiaBuffer.push({
        time: now(),
        settings: settings
      });
    }
  }, {
    key: "drainInertiaBuffer",
    value: function drainInertiaBuffer() {
      var inertia = this.inertiaBuffer;
      var nowTime = now();
      var cutoff = 160; // msec

      while (inertia.length > 0 && nowTime - inertia[0].time > cutoff) {
        inertia.shift();
      }
    }
  }, {
    key: "onMoveEnd",
    value: function onMoveEnd(panInertiaOptions) {
      this.drainInertiaBuffer();
      if (this.inertiaBuffer.length < 2) {
        return;
      }
      var deltas = {
        zoom: 0,
        bearing: 0,
        pitch: 0,
        pan: new Point(0, 0),
        pinchAround: undefined,
        around: undefined
      };
      var _iterator = _createForOfIteratorHelper(this.inertiaBuffer),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var settings = _step.value.settings;
          deltas.zoom += settings.zoomDelta || 0;
          deltas.bearing += settings.bearingDelta || 0;
          deltas.pitch += settings.pitchDelta || 0;
          if (settings.panDelta) {
            deltas.pan._add(settings.panDelta);
          }
          if (settings.around) {
            deltas.around = settings.around;
          }
          if (settings.pinchAround) {
            deltas.pinchAround = settings.pinchAround;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var lastEntry = this.inertiaBuffer[this.inertiaBuffer.length - 1];
      var duration = lastEntry.time - this.inertiaBuffer[0].time;
      var easeOptions = {};
      if (deltas.pan.mag()) {
        var result = calculateEasing(deltas.pan.mag(), duration, merge({}, defaultPanInertiaOptions, panInertiaOptions || {}));
        easeOptions.offset = deltas.pan.mult(result.amount / deltas.pan.mag());
        easeOptions.center = this.map.transform.center;
        extendDuration(easeOptions, result);
      }
      if (deltas.zoom) {
        var _result = calculateEasing(deltas.zoom, duration, defaultZoomInertiaOptions);
        easeOptions.zoom = this.map.transform.zoom + _result.amount;
        extendDuration(easeOptions, _result);
      }
      if (deltas.bearing) {
        var _result2 = calculateEasing(deltas.bearing, duration, defaultBearingInertiaOptions);
        easeOptions.bearing = this.map.transform.bearing + clamp(_result2.amount, -179, 179);
        extendDuration(easeOptions, _result2);
      }
      if (deltas.pitch) {
        var _result3 = calculateEasing(deltas.pitch, duration, defaultPitchInertiaOptions);
        easeOptions.pitch = this.map.transform.pitch + _result3.amount;
        extendDuration(easeOptions, _result3);
      }
      if (easeOptions.zoom || easeOptions.bearing) {
        var last = deltas.pinchAround === undefined ? deltas.around : deltas.pinchAround;
        easeOptions.around = last ? this.map.unproject(last) : this.map.getCenter();
      }
      this.clear();
      return merge(easeOptions, {
        noMoveStart: true
      });
    }
  }]);
  return HandlerInertia;
}(); // Unfortunately zoom, bearing, etc can't have different durations and easings so
// we need to choose one. We use the longest duration and it's corresponding easing.
export { HandlerInertia as default };
function extendDuration(easeOptions, result) {
  if (!easeOptions.duration || easeOptions.duration < result.duration) {
    easeOptions.duration = result.duration;
    easeOptions.easing = result.easing;
  }
}
function calculateEasing(amount, inertiaDuration, inertiaOptions) {
  var maxSpeed = inertiaOptions.maxSpeed,
    linearity = inertiaOptions.linearity,
    deceleration = inertiaOptions.deceleration;
  var speed = clamp(amount * linearity / (inertiaDuration / 1000), -maxSpeed, maxSpeed);
  var duration = Math.abs(speed) / (deceleration * linearity);
  return {
    easing: inertiaOptions.easing,
    duration: duration * 1000,
    amount: speed * (duration / 2)
  };
}