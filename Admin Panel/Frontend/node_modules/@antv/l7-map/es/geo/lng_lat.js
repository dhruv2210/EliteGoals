import _typeof from "@babel/runtime/helpers/esm/typeof";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { wrap as _wrap } from "../util";
export var earthRadius = 6371008.8;
var LngLat = /*#__PURE__*/function () {
  function LngLat(lng, lat) {
    _classCallCheck(this, LngLat);
    if (isNaN(lng) || isNaN(lat)) {
      throw new Error("Invalid LngLat object: (".concat(lng, ", ").concat(lat, ")"));
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
      throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
    }
  }
  _createClass(LngLat, [{
    key: "wrap",
    value: function wrap() {
      return new LngLat(_wrap(this.lng, -180, 180), this.lat);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.lng, this.lat];
    }
    // public toBounds(radius: number = 0) {
    //   const earthCircumferenceInMetersAtEquator = 40075017;
    //   const latAccuracy = (360 * radius) / earthCircumferenceInMetersAtEquator;
    //   const lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

    //   return new LngLatBounds(
    //     new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),
    //     new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy),
    //   );
    // }
  }, {
    key: "toString",
    value: function toString() {
      return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")");
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(lngLat) {
      var rad = Math.PI / 180;
      var lat1 = this.lat * rad;
      var lat2 = lngLat.lat * rad;
      var a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((lngLat.lng - this.lng) * rad);
      var maxMeters = earthRadius * Math.acos(Math.min(a, 1));
      return maxMeters;
    }
  }], [{
    key: "convert",
    value: function convert(input) {
      if (input instanceof LngLat) {
        return input;
      }
      if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {
        return new LngLat(Number(input[0]), Number(input[1]));
      }
      if (!Array.isArray(input) && _typeof(input) === 'object' && input !== null) {
        var lng = 'lng' in input ? input.lng : input.lon;
        return new LngLat(
        // flow can't refine this to have one of lng or lat, so we have to cast to any
        Number(lng), Number(input.lat));
      }
      throw new Error('`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]');
    }
  }]);
  return LngLat;
}();
export { LngLat as default };