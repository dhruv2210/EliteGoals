import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
// @ts-ignore
import { clamp, interpolate as _interpolate } from "../util";
import Point from "./point";

/**
 * An `EdgeInset` object represents screen space padding applied to the edges of the viewport.
 * This shifts the apprent center or the vanishing point of the map. This is useful for adding floating UI elements
 * on top of the map and having the vanishing point shift as UI elements resize.
 *
 * @param {number} [top=0]
 * @param {number} [bottom=0]
 * @param {number} [left=0]
 * @param {number} [right=0]
 */
var EdgeInsets = /*#__PURE__*/function () {
  function EdgeInsets() {
    var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var bottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var right = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    _classCallCheck(this, EdgeInsets);
    if (isNaN(top) || top < 0 || isNaN(bottom) || bottom < 0 || isNaN(left) || left < 0 || isNaN(right) || right < 0) {
      throw new Error('Invalid value for edge-insets, top, bottom, left and right must all be numbers');
    }
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
  }

  /**
   * Interpolates the inset in-place.
   * This maintains the current inset value for any inset not present in `target`.
   *
   * @param {PaddingOptions} target
   * @param {number} t
   * @returns {EdgeInsets}
   * @memberof EdgeInsets
   */
  _createClass(EdgeInsets, [{
    key: "interpolate",
    value: function interpolate(start, target, t) {
      if (target.top != null && start.top != null) {
        this.top = _interpolate(start.top, target.top, t);
      }
      if (target.bottom != null && start.bottom != null) {
        this.bottom = _interpolate(start.bottom, target.bottom, t);
      }
      if (target.left != null && start.left != null) {
        this.left = _interpolate(start.left, target.left, t);
      }
      if (target.right != null && start.right != null) {
        this.right = _interpolate(start.right, target.right, t);
      }
      return this;
    }

    /**
     * Utility method that computes the new apprent center or vanishing point after applying insets.
     * This is in pixels and with the top left being (0.0) and +y being downwards.
     *
     * @param {number} width
     * @param {number} height
     * @returns {Point}
     * @memberof EdgeInsets
     */
  }, {
    key: "getCenter",
    value: function getCenter(width, height) {
      // Clamp insets so they never overflow width/height and always calculate a valid center
      var x = clamp((this.left + width - this.right) / 2, 0, width);
      var y = clamp((this.top + height - this.bottom) / 2, 0, height);
      return new Point(x, y);
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return this.top === other.top && this.bottom === other.bottom && this.left === other.left && this.right === other.right;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new EdgeInsets(this.top, this.bottom, this.left, this.right);
    }

    /**
     * Returns the current sdtate as json, useful when you want to have a
     * read-only representation of the inset.
     *
     * @returns {PaddingOptions}
     * @memberof EdgeInsets
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        top: this.top,
        bottom: this.bottom,
        left: this.left,
        right: this.right
      };
    }
  }]);
  return EdgeInsets;
}();
export { EdgeInsets as default };