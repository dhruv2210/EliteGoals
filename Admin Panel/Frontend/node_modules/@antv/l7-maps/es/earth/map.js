import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _excluded = ["id", "style", "rotation"];
var _dec, _class;
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * MapboxService
 */
import { CoordinateSystem, MapServiceEvent } from '@antv/l7-core';
import { EarthMap } from '@antv/l7-map';
import { injectable } from 'inversify';
import 'reflect-metadata';
import BaseMapService from "../utils/BaseMapService";
import { Version } from "../version";
import Viewport from "./Viewport";
var EventMap = {
  mapmove: 'move',
  camerachange: 'move',
  zoomchange: 'zoom',
  dragging: 'drag'
};
var LNGLAT_OFFSET_ZOOM_THRESHOLD = 12;
/**
 * EarthService
 */
var L7EarthService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_ref) {
  _inherits(L7EarthService, _ref);
  var _super = _createSuper(L7EarthService);
  function L7EarthService() {
    var _this;
    _classCallCheck(this, L7EarthService);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "version", Version.GLOBEL);
    _defineProperty(_assertThisInitialized(_this), "dragging", false);
    _defineProperty(_assertThisInitialized(_this), "handleCameraChanged", function (e) {
      // Tip: 统一触发地图变化事件
      _this.emit('mapchange');
      var DELAY_TIME = 2000;
      _this.handleCameraChanging = true;
      if (_this.handleCameraTimer) {
        clearTimeout(_this.handleCameraTimer);
      }
      _this.handleCameraTimer = setTimeout(function () {
        _this.handleCameraChanging = false;
      }, DELAY_TIME);
      // 定义鼠标相机控制
      var rotateStep = 0.02;
      if (e.type && e.originalEvent) {
        if (e.originalEvent.type === 'wheel') {
          _this.viewport.scaleZoom(0.01 * Math.sign(e.originalEvent.wheelDelta) * -1);
        }
        if (Math.abs(e.originalEvent.movementX) > Math.abs(e.originalEvent.movementY)) {
          if (e.originalEvent.movementX > 0) {
            _this.viewport.rotateY(rotateStep);
          } else if (e.originalEvent.movementX < 0) {
            _this.viewport.rotateY(-rotateStep);
          }
        } else {
          if (e.originalEvent.movementY > 0) {
            _this.viewport.rotateX(rotateStep);
          } else if (e.originalEvent.movementY < 0) {
            _this.viewport.rotateX(-rotateStep);
          }
        }
      }
      var _this$config$offsetCo = _this.config.offsetCoordinate,
        offsetCoordinate = _this$config$offsetCo === void 0 ? true : _this$config$offsetCo;

      // resync
      _this.viewport.syncWithMapCamera({
        viewportHeight: _this.map.transform.height,
        viewportWidth: _this.map.transform.width
      });
      // set coordinate system
      if (_this.viewport.getZoom() > LNGLAT_OFFSET_ZOOM_THRESHOLD && offsetCoordinate) {
        _this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT_OFFSET);
      } else {
        _this.coordinateSystemService.setCoordinateSystem(CoordinateSystem.LNGLAT);
      }
      _this.cameraChangedCallback(_this.viewport);
    });
    return _this;
  }
  _createClass(L7EarthService, [{
    key: "lngLatToMercator",
    value: function lngLatToMercator(lnglat, altitude) {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix(lnglat, altitude, rotate, scale, origin) {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "on",
    value:
    //  map event
    function on(type, handle) {
      if (MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.on(type, handle);
      } else {
        // 统一事件名称
        this.map.on(EventMap[type] || type, handle);
      }
    }
  }, {
    key: "off",
    value: function off(type, handle) {
      this.map.off(EventMap[type] || type, handle);
      this.eventEmitter.off(type, handle);
    }
  }, {
    key: "getMapCanvasContainer",
    value: function getMapCanvasContainer() {
      return this.map.getCanvasContainer();
    }
  }, {
    key: "getSize",
    value: function getSize() {
      var size = this.map.transform;
      return [size.width, size.height];
    }
    // get mapStatus method
  }, {
    key: "getType",
    value: function getType() {
      return 'earth';
    }
  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this$config, _this$config$id, id, _this$config$style, style, _this$config$rotation, rotation, rest;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$config = this.config, _this$config$id = _this$config.id, id = _this$config$id === void 0 ? 'map' : _this$config$id, _this$config$style = _this$config.style, style = _this$config$style === void 0 ? 'light' : _this$config$style, _this$config$rotation = _this$config.rotation, rotation = _this$config$rotation === void 0 ? 0 : _this$config$rotation, rest = _objectWithoutProperties(_this$config, _excluded);
              this.viewport = new Viewport();
              this.$mapContainer = this.creatMapContainer(id);
              // @ts-ignore
              this.map = new EarthMap(_objectSpread({
                container: this.$mapContainer,
                style: this.getMapStyleValue(style),
                bearing: rotation
              }, rest));
              this.map.on('load', this.handleCameraChanged);
              this.map.on('move', this.handleCameraChanged);

              // 不同于高德地图，需要手动触发首次渲染
              this.handleCameraChanged({});
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$$mapContainer, _this$$mapContainer$p;
      // 销毁地图可视化层的容器
      (_this$$mapContainer = this.$mapContainer) === null || _this$$mapContainer === void 0 ? void 0 : (_this$$mapContainer$p = _this$$mapContainer.parentNode) === null || _this$$mapContainer$p === void 0 ? void 0 : _this$$mapContainer$p.removeChild(this.$mapContainer);
      this.eventEmitter.removeAllListeners();
      if (this.map) {
        this.map.remove();
        this.$mapContainer = null;
      }
    }
  }, {
    key: "emit",
    value: function emit(name) {
      var _this$eventEmitter;
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      (_this$eventEmitter = this.eventEmitter).emit.apply(_this$eventEmitter, [name].concat(args));
    }
  }, {
    key: "once",
    value: function once(name) {
      var _this$eventEmitter2;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      (_this$eventEmitter2 = this.eventEmitter).once.apply(_this$eventEmitter2, [name].concat(args));
    }
  }, {
    key: "getMapContainer",
    value: function getMapContainer() {
      return this.$mapContainer;
    }
  }, {
    key: "onCameraChanged",
    value: function onCameraChanged(callback) {
      this.cameraChangedCallback = callback;
    }

    /**
     * 地球模式向外暴露的 Y 轴旋转方法
     * @returns
     */
  }, {
    key: "rotateY",
    value: function rotateY(option) {
      var _ref2 = option || {},
        _ref2$force = _ref2.force,
        force = _ref2$force === void 0 ? false : _ref2$force,
        _ref2$reg = _ref2.reg,
        reg = _ref2$reg === void 0 ? 0.01 : _ref2$reg;
      // TODO: 让旋转方法与
      if (this.handleCameraChanging && !force) {
        return;
      }
      if (this.viewport) {
        this.viewport.rotateY(reg);
        this.viewport.syncWithMapCamera({
          viewportHeight: this.map.transform.height,
          viewportWidth: this.map.transform.width
        });
        this.cameraChangedCallback(this.viewport);
      }
    }
  }]);
  return L7EarthService;
}(BaseMapService)) || _class);
export { L7EarthService as default };