import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { mat4, vec3 } from 'gl-matrix';
var Viewport = /*#__PURE__*/function () {
  function Viewport() {
    _classCallCheck(this, Viewport);
    _defineProperty(this, "projectionMatrix", mat4.create());
    _defineProperty(this, "viewMatrix", mat4.create());
    _defineProperty(this, "viewProjectionMatrix", mat4.create());
    _defineProperty(this, "ViewProjectionMatrixUncentered", mat4.create());
    _defineProperty(this, "viewUncenteredMatrix", mat4.create());
  }
  _createClass(Viewport, [{
    key: "syncWithMapCamera",
    value: function syncWithMapCamera(mapCamera) {
      var _mapCamera$zoom = mapCamera.zoom,
        zoom = _mapCamera$zoom === void 0 ? 1 : _mapCamera$zoom,
        _mapCamera$center = mapCamera.center,
        center = _mapCamera$center === void 0 ? [0, 0] : _mapCamera$center,
        _mapCamera$offsetOrig = mapCamera.offsetOrigin,
        offsetOrigin = _mapCamera$offsetOrig === void 0 ? [0, 0] : _mapCamera$offsetOrig,
        _mapCamera$cameraPosi = mapCamera.cameraPosition,
        cameraPosition = _mapCamera$cameraPosi === void 0 ? [0, 0, 0] : _mapCamera$cameraPosi,
        _mapCamera$up = mapCamera.up,
        up = _mapCamera$up === void 0 ? [0, 1, 0] : _mapCamera$up,
        _mapCamera$lookAt = mapCamera.lookAt,
        lookAt = _mapCamera$lookAt === void 0 ? [0, 0, 0] : _mapCamera$lookAt,
        _mapCamera$aspect = mapCamera.aspect,
        aspect = _mapCamera$aspect === void 0 ? 1 : _mapCamera$aspect,
        _mapCamera$near = mapCamera.near,
        near = _mapCamera$near === void 0 ? 0.1 : _mapCamera$near,
        _mapCamera$far = mapCamera.far,
        far = _mapCamera$far === void 0 ? 1000 : _mapCamera$far,
        _mapCamera$fov = mapCamera.fov,
        fov = _mapCamera$fov === void 0 ? 45 : _mapCamera$fov;
      this.zoom = zoom;
      this.center = center;

      // 计算透视投影矩阵 projectionMatrix
      mat4.perspective(this.projectionMatrix, fov / 180 * Math.PI, aspect, near, far);

      // ortho(out, left, right, bottom, top, near, far)
      // mat4.ortho(this.projectionMatrix, left, right, bottom, top, near, far)
      // console.log(left, right, bottom, top, near, far)
      // 计算相机矩阵 viewMatrix
      // console.log(cameraPosition)
      var eyePoint = vec3.fromValues.apply(vec3, _toConsumableArray(cameraPosition));
      // const eyePoint = vec3.fromValues(cameraPosition[0], cameraPosition[1], 0.1);
      // 计算相机矩阵 viewMatrix

      var lookAtPoint = vec3.fromValues.apply(vec3, _toConsumableArray(lookAt));
      // const lookAtPoint = vec3.fromValues(...cameraPosition);
      // const lookAtPoint = vec3.fromValues(cameraPosition[0], cameraPosition[1], -0.1);
      // const lookAtPoint = vec3.fromValues(0, 0, 0);

      var upDirect = vec3.fromValues.apply(vec3, _toConsumableArray(up));
      // const upDirect = vec3.fromValues(0, 1, 0);
      mat4.lookAt(this.viewMatrix, eyePoint, lookAtPoint, upDirect);
      this.viewUncenteredMatrix = mat4.clone(this.viewMatrix);

      // 移动相机位置
      mat4.translate(this.viewMatrix, this.viewMatrix, vec3.fromValues(-offsetOrigin[0], offsetOrigin[1], 0));
      mat4.multiply(this.viewProjectionMatrix, this.projectionMatrix, this.viewMatrix);
      mat4.multiply(this.ViewProjectionMatrixUncentered, this.projectionMatrix, this.viewMatrix);
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.zoom;
    }
  }, {
    key: "getZoomScale",
    value: function getZoomScale() {
      // 512 尺寸下的缩放：2 ^ 20
      return 1048576;
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      var _this$center = _slicedToArray(this.center, 2),
        lng = _this$center[0],
        lat = _this$center[1];
      return [lng, lat];
    }
  }, {
    key: "getProjectionMatrix",
    value: function getProjectionMatrix() {
      // @ts-ignore
      return this.projectionMatrix;
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
  }, {
    key: "getViewMatrix",
    value: function getViewMatrix() {
      // @ts-ignore
      return this.viewMatrix;
    }
  }, {
    key: "getViewMatrixUncentered",
    value: function getViewMatrixUncentered() {
      // @ts-ignore
      return this.viewUncenteredMatrix;
    }
  }, {
    key: "getViewProjectionMatrix",
    value: function getViewProjectionMatrix() {
      // @ts-ignore
      return this.viewProjectionMatrix;
    }
  }, {
    key: "getViewProjectionMatrixUncentered",
    value: function getViewProjectionMatrixUncentered() {
      // @ts-ignore
      return this.ViewProjectionMatrixUncentered;
    }
  }, {
    key: "getFocalDistance",
    value: function getFocalDistance() {
      return 1.2;
    }

    /**
     * P20 坐标系，固定 scale
     */
  }, {
    key: "projectFlat",
    value: function projectFlat(lngLat) {
      var maxs = 85.0511287798;
      var lat = Math.max(Math.min(maxs, lngLat[1]), -maxs);
      // tslint:disable-next-line:no-bitwise
      var zoomScale = 256 << 20;
      var d = Math.PI / 180;
      var x = lngLat[0] * d;
      var y = lat * d;
      y = Math.log(Math.tan(Math.PI / 4 + y / 2));
      var a = 0.5 / Math.PI;
      var b = 0.5;
      var c = -0.5 / Math.PI;
      d = 0.5;
      x = zoomScale * (a * x + b) - 215440491;
      y = -(zoomScale * (c * y + d) - 106744817);
      return [x, y];
    }
  }]);
  return Viewport;
}();
export { Viewport as default };