"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _initializerDefineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerDefineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));
var _initializerWarningHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerWarningHelper"));
var _glMatrix = require("gl-matrix");
var _inversify = require("inversify");
require("reflect-metadata");
var _types = require("../../types");
var _project = require("../../utils/project");
var _ICoordinateSystemService = require("./ICoordinateSystemService");
var _dec, _dec2, _class, _class2, _descriptor;
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var CoordinateSystemService = (_dec = (0, _inversify.injectable)(), _dec2 = (0, _inversify.inject)(_types.TYPES.ICameraService), _dec(_class = (_class2 = /*#__PURE__*/function () {
  function CoordinateSystemService() {
    (0, _classCallCheck2.default)(this, CoordinateSystemService);
    (0, _defineProperty2.default)(this, "needRefresh", true);
    (0, _initializerDefineProperty2.default)(this, "cameraService", _descriptor, this);
    (0, _defineProperty2.default)(this, "coordinateSystem", void 0);
    (0, _defineProperty2.default)(this, "viewportCenter", void 0);
    (0, _defineProperty2.default)(this, "viewportCenterProjection", void 0);
    (0, _defineProperty2.default)(this, "pixelsPerDegree", void 0);
    (0, _defineProperty2.default)(this, "pixelsPerDegree2", void 0);
    (0, _defineProperty2.default)(this, "pixelsPerMeter", void 0);
  }
  (0, _createClass2.default)(CoordinateSystemService, [{
    key: "refresh",
    value:
    /**
     * 重新计算当前坐标系参数
     * TODO: 使用 memoize 缓存参数以及计算结果
     */
    function refresh(offsetCenter) {
      // if (!this.needRefresh) {
      //   return;
      // }
      var zoom = this.cameraService.getZoom();
      var zoomScale = this.cameraService.getZoomScale();
      var center = offsetCenter ? offsetCenter : this.cameraService.getCenter();

      // 计算像素到米以及经纬度之间的转换
      var _getDistanceScales = (0, _project.getDistanceScales)({
          // longitude: center[0],
          latitude: center[1],
          zoom: zoom
        }),
        pixelsPerMeter = _getDistanceScales.pixelsPerMeter,
        pixelsPerDegree = _getDistanceScales.pixelsPerDegree;
      this.viewportCenter = center;
      this.viewportCenterProjection = [0, 0, 0, 0];
      this.pixelsPerMeter = pixelsPerMeter;
      this.pixelsPerDegree = pixelsPerDegree;
      this.pixelsPerDegree2 = [0, 0, 0];
      if (this.coordinateSystem === _ICoordinateSystemService.CoordinateSystem.LNGLAT || this.coordinateSystem === _ICoordinateSystemService.CoordinateSystem.P20) {
        // 继续使用相机服务计算的 VP 矩阵
        this.cameraService.setViewProjectionMatrix(undefined);
      } else if (this.coordinateSystem === _ICoordinateSystemService.CoordinateSystem.LNGLAT_OFFSET) {
        this.calculateLnglatOffset(center, zoom);
      } else if (this.coordinateSystem === _ICoordinateSystemService.CoordinateSystem.P20_OFFSET) {
        this.calculateLnglatOffset(center, zoom, zoomScale, true);
      }
      this.needRefresh = false;

      // TODO: 判断是否应用瓦片 & 常规坐标系
    }
  }, {
    key: "getCoordinateSystem",
    value: function getCoordinateSystem() {
      return this.coordinateSystem;
    }
  }, {
    key: "setCoordinateSystem",
    value: function setCoordinateSystem(coordinateSystem) {
      this.coordinateSystem = coordinateSystem;
    }
  }, {
    key: "getViewportCenter",
    value: function getViewportCenter() {
      return this.viewportCenter;
    }
  }, {
    key: "getViewportCenterProjection",
    value: function getViewportCenterProjection() {
      return this.viewportCenterProjection;
    }
  }, {
    key: "getPixelsPerDegree",
    value: function getPixelsPerDegree() {
      return this.pixelsPerDegree;
    }
  }, {
    key: "getPixelsPerDegree2",
    value: function getPixelsPerDegree2() {
      return this.pixelsPerDegree2;
    }
  }, {
    key: "getPixelsPerMeter",
    value: function getPixelsPerMeter() {
      return this.pixelsPerMeter;
    }
  }, {
    key: "calculateLnglatOffset",
    value: function calculateLnglatOffset(center, zoom, scale, flipY) {
      // http://uber-common.github.io/viewport-mercator-project/docs/api-reference/web-mercator-utils#code-classlanguage-textgetdistancescalesviewportcode
      var _getDistanceScales2 = (0, _project.getDistanceScales)({
          // longitude: center[0],
          latitude: center[1],
          zoom: zoom,
          scale: scale,
          flipY: flipY,
          highPrecision: true
        }),
        ppm = _getDistanceScales2.pixelsPerMeter,
        ppd = _getDistanceScales2.pixelsPerDegree,
        pixelsPerDegree2 = _getDistanceScales2.pixelsPerDegree2;
      var viewMatrix = this.cameraService.getViewMatrix();
      var projectionMatrix = this.cameraService.getProjectionMatrix();
      var viewProjectionMatrix = _glMatrix.mat4.multiply([], projectionMatrix, viewMatrix);

      // 经纬度投影到 Web 墨卡托坐标系
      var positionPixels = this.cameraService.projectFlat([Math.fround(center[0]), Math.fround(center[1])], Math.pow(2, zoom));

      // Web 墨卡托坐标系通过 VP 矩阵变换到世界坐标系
      this.viewportCenterProjection = _glMatrix.vec4.transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      viewMatrix = this.cameraService.getViewMatrixUncentered() || viewMatrix;

      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      viewProjectionMatrix = _glMatrix.mat4.multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = _glMatrix.mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);

      // 重新计算相机 VP 矩阵
      this.cameraService.setViewProjectionMatrix(viewProjectionMatrix);
      this.pixelsPerMeter = ppm;
      this.pixelsPerDegree = ppd;
      this.pixelsPerDegree2 = pixelsPerDegree2;
    }
  }]);
  return CoordinateSystemService;
}(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class2.prototype, "cameraService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
exports.default = CoordinateSystemService;