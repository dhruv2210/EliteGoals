"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _initializerDefineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerDefineProperty"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));
var _initializerWarningHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerWarningHelper"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Utils = require("@antv/l7-utils");
var _inversify = require("inversify");
require("reflect-metadata");
var _types = require("../../types");
var _gl = require("../renderer/gl");
var _StyleAttribute = _interopRequireDefault(require("./StyleAttribute"));
var _excluded = ["modelType"],
  _excluded2 = ["buffer", "update", "name"],
  _excluded3 = ["buffer", "update", "name"],
  _excluded4 = ["buffer", "update", "name"];
var _bytesPerElementMap, _dec, _dec2, _class, _class2, _descriptor;
var bytesPerElementMap = (_bytesPerElementMap = {}, (0, _defineProperty2.default)(_bytesPerElementMap, _gl.gl.FLOAT, 4), (0, _defineProperty2.default)(_bytesPerElementMap, _gl.gl.UNSIGNED_BYTE, 1), (0, _defineProperty2.default)(_bytesPerElementMap, _gl.gl.UNSIGNED_SHORT, 2), _bytesPerElementMap);

/**
 * 每个 Layer 都拥有一个，用于管理样式属性的注册和更新
 */
var StyleAttributeService = (_dec = (0, _inversify.injectable)(), _dec2 = (0, _inversify.inject)(_types.TYPES.IRendererService), _dec(_class = (_class2 = /*#__PURE__*/function () {
  function StyleAttributeService() {
    (0, _classCallCheck2.default)(this, StyleAttributeService);
    (0, _defineProperty2.default)(this, "attributesAndIndices", void 0);
    (0, _initializerDefineProperty2.default)(this, "rendererService", _descriptor, this);
    (0, _defineProperty2.default)(this, "attributes", []);
    (0, _defineProperty2.default)(this, "triangulation", void 0);
    (0, _defineProperty2.default)(this, "featureLayout", {
      sizePerElement: 0,
      elements: []
    });
  }
  (0, _createClass2.default)(StyleAttributeService, [{
    key: "registerStyleAttribute",
    value: function registerStyleAttribute(options) {
      var attributeToUpdate = this.getLayerStyleAttribute(options.name || '');
      if (attributeToUpdate) {
        attributeToUpdate.setProps(options);
      } else {
        attributeToUpdate = new _StyleAttribute.default(options);
        this.attributes.push(attributeToUpdate);
      }
      return attributeToUpdate;
    }
  }, {
    key: "updateScaleAttribute",
    value: function updateScaleAttribute(scaleOption) {
      this.attributes.forEach(function (attr) {
        var _attr$scale;
        var name = attr.name;
        var field = (_attr$scale = attr.scale) === null || _attr$scale === void 0 ? void 0 : _attr$scale.field;
        if (scaleOption[name] || field && scaleOption[field]) {
          // 字段类型和映射类型
          attr.needRescale = true;
          attr.needRemapping = true;
          attr.needRegenerateVertices = true;
        }
      });
    }
  }, {
    key: "updateStyleAttribute",
    value: function updateStyleAttribute(attributeName, options, updateOptions) {
      var attributeToUpdate = this.getLayerStyleAttribute(attributeName);
      if (!attributeToUpdate) {
        attributeToUpdate = this.registerStyleAttribute((0, _objectSpread2.default)((0, _objectSpread2.default)({}, options), {}, {
          name: attributeName
        }));
      }
      var scale = options.scale;
      if (scale && attributeToUpdate) {
        // TODO: 需要比较新旧值确定是否需要 rescale
        // 需要重新 scale，肯定也需要重新进行数据映射
        attributeToUpdate.scale = scale;
        attributeToUpdate.needRescale = true;
        attributeToUpdate.needRemapping = true;
        attributeToUpdate.needRegenerateVertices = true;
        if (updateOptions && updateOptions.featureRange) {
          attributeToUpdate.featureRange = updateOptions.featureRange;
        }
      }
    }
  }, {
    key: "getLayerStyleAttributes",
    value: function getLayerStyleAttributes() {
      return this.attributes;
    }
  }, {
    key: "getLayerStyleAttribute",
    value: function getLayerStyleAttribute(attributeName) {
      return this.attributes.find(function (attribute) {
        return attribute.name === attributeName;
      });
    }
  }, {
    key: "getLayerAttributeScale",
    value: function getLayerAttributeScale(name) {
      var _attribute$scale;
      var attribute = this.getLayerStyleAttribute(name);
      var scale = attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;
      if (scale && scale[0]) {
        return scale[0].func;
      }
      return null;
    }
  }, {
    key: "updateAttributeByFeatureRange",
    value: function updateAttributeByFeatureRange(attributeName, features) {
      var startFeatureIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var endFeatureIdx = arguments.length > 3 ? arguments[3] : undefined;
      var layer = arguments.length > 4 ? arguments[4] : undefined;
      var attributeToUpdate = this.attributes.find(function (attribute) {
        return attribute.name === attributeName;
      });
      if (attributeToUpdate && attributeToUpdate.descriptor) {
        var descriptor = attributeToUpdate.descriptor;
        var update = descriptor.update,
          buffer = descriptor.buffer,
          _descriptor$size = descriptor.size,
          size = _descriptor$size === void 0 ? 0 : _descriptor$size;
        var bytesPerElement = bytesPerElementMap[buffer.type || _gl.gl.FLOAT];
        if (update) {
          var _this$featureLayout = this.featureLayout,
            elements = _this$featureLayout.elements,
            sizePerElement = _this$featureLayout.sizePerElement;
          // 截取待更新的 feature 范围
          var featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);
          // [n, n] 中断更新
          if (!featuresToUpdate.length) {
            return;
          }
          var offset = featuresToUpdate[0].offset;
          // 以 byte 为单位计算 buffer 中的偏移
          var bufferOffsetInBytes = offset * size * bytesPerElement;
          var updatedBufferData = featuresToUpdate.map(function (_ref, attributeIdx) {
            var featureIdx = _ref.featureIdx,
              vertices = _ref.vertices,
              normals = _ref.normals;
            var verticesNumForCurrentFeature = vertices.length / sizePerElement;
            var featureData = [];
            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
              var normal = normals ?
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];
              featureData.push.apply(featureData, (0, _toConsumableArray2.default)(update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal)));
            }
            return featureData;
          }).reduce(function (prev, cur) {
            prev.push.apply(prev, (0, _toConsumableArray2.default)(cur));
            return prev;
          }, []);

          // 更新底层 IAttribute 中包含的 IBuffer，使用 subdata
          attributeToUpdate.vertexAttribute.updateBuffer({
            data: updatedBufferData,
            offset: bufferOffsetInBytes
          });
          // size color 触发更新事件
          layer === null || layer === void 0 ? void 0 : layer.emit("legend:".concat(attributeName), {
            type: attributeName,
            attr: attributeToUpdate
          });
        }
      }
    }
  }, {
    key: "createAttributesAndIndicesAscy",
    value: function createAttributesAndIndicesAscy(features, segmentNumber, workerOptions) {
      var _this = this;
      // 每次创建的初始化化 LayerOut
      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };
      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      }).filter(function (d) {
        return d;
      });
      var modelType = workerOptions.modelType,
        restOptions = (0, _objectWithoutProperties2.default)(workerOptions, _excluded);
      var _this$rendererService = this.rendererService,
        createAttribute = _this$rendererService.createAttribute,
        createBuffer = _this$rendererService.createBuffer,
        createElements = _this$rendererService.createElements;
      var attributes = {};
      return new Promise(function (resolve, reject) {
        (0, _l7Utils.executeWorkerTask)(modelType, (0, _objectSpread2.default)({
          // Tip: worker 不支持传递 function 函数
          descriptors: _this.getDescriptorsWithOutFunc(descriptors),
          features: features,
          segmentNumber: segmentNumber
        }, restOptions)).then(function (e) {
          e.descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor) {
              // IAttribute 参数透传
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              var buffer = descriptor.buffer,
                update = descriptor.update,
                name = descriptor.name,
                rest = (0, _objectWithoutProperties2.default)(descriptor, _excluded2);
              var vertexAttribute = createAttribute((0, _objectSpread2.default)({
                // IBuffer 参数透传
                buffer: createBuffer(buffer)
              }, rest));
              attributes[descriptor.name || ''] = vertexAttribute;

              // 在 StyleAttribute 上保存对 VertexAttribute 的引用
              _this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
            }
          });
          _this.featureLayout = e.featureLayout;
          var elements = createElements({
            data: e.indices,
            type: _gl.gl.UNSIGNED_INT,
            count: e.indices.length
          });
          _this.attributesAndIndices = {
            attributes: attributes,
            elements: elements,
            count: null
          };
          resolve(_this.attributesAndIndices);
        }).catch(function (err) {
          console.warn(err);
          reject(err);
        });
      });
    }
  }, {
    key: "createAttributesAndIndices",
    value: function createAttributesAndIndices(features, triangulation, segmentNumber) {
      var _this2 = this;
      // 每次创建的初始化化 LayerOut
      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };
      if (triangulation) {
        this.triangulation = triangulation;
      }
      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      });
      var verticesNum = 0;
      var vecticesCount = 0; // 在不使用 element 的时候记录顶点、图层所有顶点的总数
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var vertices = [];
      var indices = [];
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var normals = [];
      var size = 3;
      features.forEach(function (feature, featureIdx) {
        // 逐 feature 进行三角化
        var _this2$triangulation = _this2.triangulation(feature, segmentNumber),
          indicesForCurrentFeature = _this2$triangulation.indices,
          verticesForCurrentFeature = _this2$triangulation.vertices,
          normalsForCurrentFeature = _this2$triangulation.normals,
          vertexSize = _this2$triangulation.size,
          indexes = _this2$triangulation.indexes,
          count = _this2$triangulation.count;
        if (typeof count === 'number') {
          vecticesCount += count;
        }
        indicesForCurrentFeature.forEach(function (i) {
          indices.push(i + verticesNum);
        });
        size = vertexSize;
        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;

        // 记录三角化结果，用于后续精确更新指定 feature
        _this2.featureLayout.sizePerElement = size;
        _this2.featureLayout.elements.push({
          featureIdx: featureIdx,
          vertices: verticesForCurrentFeature,
          normals: normalsForCurrentFeature,
          offset: verticesNum
        });
        verticesNum += verticesNumForCurrentFeature;
        // 根据 position 顶点生成其他顶点数据
        var _loop = function _loop(vertexIdx) {
          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
          var vertexIndex = 0;
          if (indexes && indexes[vertexIdx] !== undefined) {
            vertexIndex = indexes[vertexIdx];
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor && descriptor.update) {
              var _ref2;
              (_ref2 = descriptor.buffer.data).push.apply(_ref2, (0, _toConsumableArray2.default)(descriptor.update(feature, featureIdx, vertice, vertexIdx,
              // 当前顶点所在feature索引
              normal, vertexIndex
              // 传入顶点索引 vertexIdx
              )));
            } // end if
          }); // end for each
        };
        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
          _loop(vertexIdx);
        } // end for
      }); // end features for Each
      var _this$rendererService2 = this.rendererService,
        createAttribute = _this$rendererService2.createAttribute,
        createBuffer = _this$rendererService2.createBuffer,
        createElements = _this$rendererService2.createElements;
      var attributes = {};
      descriptors.forEach(function (descriptor, attributeIdx) {
        if (descriptor) {
          // IAttribute 参数透传
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          var buffer = descriptor.buffer,
            update = descriptor.update,
            name = descriptor.name,
            rest = (0, _objectWithoutProperties2.default)(descriptor, _excluded3);
          var vertexAttribute = createAttribute((0, _objectSpread2.default)({
            // IBuffer 参数透传
            buffer: createBuffer(buffer)
          }, rest));
          attributes[descriptor.name || ''] = vertexAttribute;

          // 在 StyleAttribute 上保存对 VertexAttribute 的引用
          _this2.attributes[attributeIdx].vertexAttribute = vertexAttribute;
        }
      });
      var elements = createElements({
        data: indices,
        type: _gl.gl.UNSIGNED_INT,
        count: indices.length
      });
      this.attributesAndIndices = {
        attributes: attributes,
        elements: elements,
        count: vecticesCount
      };
      return this.attributesAndIndices;
    }
  }, {
    key: "createAttributes",
    value: function createAttributes(features, triangulation) {
      var _this3 = this;
      // 每次创建的初始化化 LayerOut
      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };
      if (triangulation) {
        this.triangulation = triangulation;
      }
      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      });
      var verticesNum = 0;
      var indices = [];
      var size = 3;
      features.forEach(function (feature, featureIdx) {
        // 逐 feature 进行三角化
        var _this3$triangulation = _this3.triangulation(feature),
          indicesForCurrentFeature = _this3$triangulation.indices,
          verticesForCurrentFeature = _this3$triangulation.vertices,
          normalsForCurrentFeature = _this3$triangulation.normals,
          vertexSize = _this3$triangulation.size,
          indexes = _this3$triangulation.indexes;
        indicesForCurrentFeature.forEach(function (i) {
          indices.push(i + verticesNum);
        });
        size = vertexSize;
        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;

        // 记录三角化结果，用于后续精确更新指定 feature
        _this3.featureLayout.sizePerElement = size;
        _this3.featureLayout.elements.push({
          featureIdx: featureIdx,
          vertices: verticesForCurrentFeature,
          normals: normalsForCurrentFeature,
          offset: verticesNum
        });
        verticesNum += verticesNumForCurrentFeature;
        // 根据 position 顶点生成其他顶点数据
        var _loop2 = function _loop2(vertexIdx) {
          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
          var vertexIndex = 0;
          if (indexes && indexes[vertexIdx] !== undefined) {
            vertexIndex = indexes[vertexIdx];
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor && descriptor.update) {
              var _ref3;
              (_ref3 = descriptor.buffer.data).push.apply(_ref3, (0, _toConsumableArray2.default)(descriptor.update(feature, featureIdx, vertice, vertexIdx,
              // 当前顶点所在feature索引
              normal, vertexIndex
              // 传入顶点索引 vertexIdx
              )));
            } // end if
          }); // end for each
        };
        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
          _loop2(vertexIdx);
        } // end for
      }); // end features for Each
      var _this$rendererService3 = this.rendererService,
        createAttribute = _this$rendererService3.createAttribute,
        createBuffer = _this$rendererService3.createBuffer;
      var attributes = {};
      descriptors.forEach(function (descriptor, attributeIdx) {
        if (descriptor) {
          // IAttribute 参数透传
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          var buffer = descriptor.buffer,
            update = descriptor.update,
            name = descriptor.name,
            rest = (0, _objectWithoutProperties2.default)(descriptor, _excluded4);
          var vertexAttribute = createAttribute((0, _objectSpread2.default)({
            // IBuffer 参数透传
            buffer: createBuffer(buffer)
          }, rest));
          attributes[descriptor.name || ''] = vertexAttribute;

          // 在 StyleAttribute 上保存对 VertexAttribute 的引用
          _this3.attributes[attributeIdx].vertexAttribute = vertexAttribute;
        }
      });
      return {
        attributes: attributes
      };
    }
  }, {
    key: "clearAllAttributes",
    value: function clearAllAttributes() {
      var _this$attributesAndIn;
      // 销毁关联的 vertex attribute buffer objects
      this.attributes.forEach(function (attribute) {
        if (attribute.vertexAttribute) {
          attribute.vertexAttribute.destroy();
        }
      });
      (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 ? void 0 : _this$attributesAndIn.elements.destroy();
      this.attributes = [];
    }
  }, {
    key: "getDescriptorsWithOutFunc",
    value: function getDescriptorsWithOutFunc(descriptors) {
      return descriptors.map(function (d) {
        return {
          buffer: d.buffer,
          name: d.name,
          size: d.size
        };
      });
    }
  }]);
  return StyleAttributeService;
}(), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class2.prototype, "rendererService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
exports.default = StyleAttributeService;