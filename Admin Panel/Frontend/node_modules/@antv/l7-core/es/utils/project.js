var DEGREES_TO_RADIANS = Math.PI / 180;
var TILE_SIZE = 512;
// Average circumference (40075 km equatorial, 40007 km meridional)
var EARTH_CIRCUMFERENCE = 40.03e6;
/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
export function getDistanceScales(_ref) {
  var _ref$latitude = _ref.latitude,
    latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,
    _ref$zoom = _ref.zoom,
    zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,
    scale = _ref.scale,
    _ref$highPrecision = _ref.highPrecision,
    highPrecision = _ref$highPrecision === void 0 ? false : _ref$highPrecision,
    _ref$flipY = _ref.flipY,
    flipY = _ref$flipY === void 0 ? false : _ref$flipY;
  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : Math.pow(2, zoom);

  // @ts-ignore
  var result = {};
  var worldSize = TILE_SIZE * scale;
  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);

  /**
   * Number of pixels occupied by one degree longitude around current lat/lon:
   *  pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
   *     = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
   *   pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
   *     = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
   */
  var pixelsPerDegreeX = worldSize / 360;
  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;

  /**
   * Number of pixels occupied by one meter around current lat/lon:
   */
  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;

  /**
   * LngLat: longitude -> east and latitude -> north (bottom left)
   * UTM meter offset: x -> east and y -> north (bottom left)
   * World space: x -> east and y -> south (top left)
   *
   * Y needs to be flipped when converting delta degree/meter to delta pixels
   */
  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];
  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];
  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];
  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  /**
   * Taylor series 2nd order for 1/latCosine
   *  f'(a) * (x - a)
   *     = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
   *     = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
   */
  if (highPrecision) {
    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;
    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];
    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
    if (flipY) {
      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];
      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];
    }
  }
  if (flipY) {
    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];
    result.metersPerPixel[1] = -result.metersPerPixel[1];
    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];
    result.degreesPerPixel[1] = -result.degreesPerPixel[1];
  }

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return result;
}