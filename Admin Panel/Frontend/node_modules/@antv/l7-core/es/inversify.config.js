/**
 * Root Container
 * @see /dev-docs/IoC 容器、依赖注入与服务说明.md
 */
import 'reflect-metadata';
import { EventEmitter } from 'eventemitter3';
import { Container, decorate, injectable } from 'inversify';
import getDecorators from 'inversify-inject-decorators';
import { TYPES } from "./types";

/** Service interfaces */

/** Service implements */
import FontService from "./services/asset/FontService";
import IconService from "./services/asset/IconService";
import CameraService from "./services/camera/CameraService";
import ControlService from "./services/component/ControlService";
import MarkerService from "./services/component/MarkerService";
import PopupService from "./services/component/PopupService";
import GlobalConfigService from "./services/config/ConfigService";
import CoordinateSystemService from "./services/coordinate/CoordinateSystemService";
import DebugService from "./services/debug/DebugService";
import InteractionService from "./services/interaction/InteractionService";
import PickingService from "./services/interaction/PickingService";
import LayerService from "./services/layer/LayerService";
import StyleAttributeService from "./services/layer/StyleAttributeService";
import SceneService from "./services/scene/SceneService";
import ShaderModuleService from "./services/shader/ShaderModuleService";

/** PostProcessing passes */

import ClearPass from "./services/renderer/passes/ClearPass";
import MultiPassRenderer from "./services/renderer/passes/MultiPassRenderer";
import PixelPickingPass from "./services/renderer/passes/PixelPickingPass";
import BloomPass from "./services/renderer/passes/post-processing/BloomPass";
import BlurHPass from "./services/renderer/passes/post-processing/BlurHPass";
import BlurVPass from "./services/renderer/passes/post-processing/BlurVPass";
import ColorHalfTonePass from "./services/renderer/passes/post-processing/ColorHalfTonePass";
import CopyPass from "./services/renderer/passes/post-processing/CopyPass";
import HexagonalPixelatePass from "./services/renderer/passes/post-processing/HexagonalPixelatePass";
import InkPass from "./services/renderer/passes/post-processing/InkPass";
import NoisePass from "./services/renderer/passes/post-processing/NoisePass";
import SepiaPass from "./services/renderer/passes/post-processing/SepiaPass";
import PostProcessor from "./services/renderer/passes/PostProcessor";
import RenderPass from "./services/renderer/passes/RenderPass";
import TAAPass from "./services/renderer/passes/TAAPass";

// @see https://github.com/inversify/InversifyJS/blob/master/wiki/container_api.md#defaultscope
var container = new Container();

/**
 * bind global services in root container
 */
container.bind(TYPES.IGlobalConfigService).to(GlobalConfigService).inSingletonScope();
// @see https://github.com/inversify/InversifyJS/blob/master/wiki/inheritance.md#what-can-i-do-when-my-base-class-is-provided-by-a-third-party-module
decorate(injectable(), EventEmitter);
container.bind(TYPES.IEventEmitter).to(EventEmitter);
// 支持 L7 使用 new 而非容器实例化的场景，同时禁止 lazyInject cache
// @see https://github.com/inversify/inversify-inject-decorators#caching-vs-non-caching-behaviour
var DECORATORS = getDecorators(container, false);
// Add babel legacy decorators support
// @see https://github.com/inversify/InversifyJS/issues/1050
// @see https://github.com/inversify/InversifyJS/issues/1026#issuecomment-504936034
export var lazyInject = function lazyInject(serviceIdentifier) {
  var original = DECORATORS.lazyInject(serviceIdentifier);
  // the 'descriptor' parameter is actually always defined for class fields for Babel, but is considered undefined for TSC
  // so we just hack it with ?/! combination to avoid "TS1240: Unable to resolve signature of property decorator when called as an expression"
  return function (proto, key, descriptor) {
    // make it work as usual
    original.call(this, proto, key);
    // return link to proto, so own value wont be 'undefined' after component's creation
    if (descriptor) {
      descriptor.initializer = function () {
        return proto[key];
      };
    }
  };
};
export var lazyMultiInject = function lazyMultiInject(serviceIdentifier) {
  var original = DECORATORS.lazyMultiInject(serviceIdentifier);
  // the 'descriptor' parameter is actually always defined for class fields for Babel, but is considered undefined for TSC
  // so we just hack it with ?/! combination to avoid "TS1240: Unable to resolve signature of property decorator when called as an expression"
  return function (proto, key, descriptor) {
    // make it work as usual
    original.call(this, proto, key);
    if (descriptor) {
      // return link to proto, so own value wont be 'undefined' after component's creation
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      descriptor.initializer = function () {
        return proto[key];
      };
    }
  };
};
export default container;
var sceneIdCounter = 0;
export function createSceneContainer() {
  // @see https://github.com/inversify/InversifyJS/blob/master/wiki/hierarchical_di.md#support-for-hierarchical-di-systems
  var sceneContainer = new Container();
  sceneContainer.parent = container;

  // 生成场景 ID 并保存在容器内
  sceneContainer.bind(TYPES.SceneID).toConstantValue("".concat(sceneIdCounter++));
  sceneContainer.bind(TYPES.IShaderModuleService).to(ShaderModuleService).inSingletonScope();
  sceneContainer.bind(TYPES.ILayerService).to(LayerService).inSingletonScope();
  sceneContainer.bind(TYPES.IDebugService).to(DebugService).inSingletonScope();
  sceneContainer.bind(TYPES.ISceneService).to(SceneService).inSingletonScope();
  sceneContainer.bind(TYPES.ICameraService).to(CameraService).inSingletonScope();
  sceneContainer.bind(TYPES.ICoordinateSystemService).to(CoordinateSystemService).inSingletonScope();
  sceneContainer.bind(TYPES.IInteractionService).to(InteractionService).inSingletonScope();
  sceneContainer.bind(TYPES.IPickingService).to(PickingService).inSingletonScope();
  sceneContainer.bind(TYPES.IControlService).to(ControlService).inSingletonScope();
  sceneContainer.bind(TYPES.IMarkerService).to(MarkerService).inSingletonScope();
  sceneContainer.bind(TYPES.IIconService).to(IconService).inSingletonScope();
  sceneContainer.bind(TYPES.IFontService).to(FontService).inSingletonScope();
  sceneContainer.bind(TYPES.IPopupService).to(PopupService).inSingletonScope();

  // 绑定常规 passes
  sceneContainer.bind(TYPES.INormalPass).to(ClearPass).whenTargetNamed('clear');
  sceneContainer.bind(TYPES.INormalPass).to(PixelPickingPass).whenTargetNamed('pixelPicking');
  sceneContainer.bind(TYPES.INormalPass).to(RenderPass).whenTargetNamed('render');
  sceneContainer.bind(TYPES.INormalPass).to(TAAPass).whenTargetNamed('taa');
  sceneContainer.bind(TYPES.IFactoryNormalPass).toFactory(function (context) {
    return function (named) {
      return context.container.getNamed(TYPES.INormalPass, named);
    };
  });

  // 绑定 post processing passes
  sceneContainer.bind(TYPES.IPostProcessingPass).to(CopyPass).whenTargetNamed('copy');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(BloomPass).whenTargetNamed('bloom');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(BlurHPass).whenTargetNamed('blurH');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(BlurVPass).whenTargetNamed('blurV');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(NoisePass).whenTargetNamed('noise');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(SepiaPass).whenTargetNamed('sepia');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(ColorHalfTonePass).whenTargetNamed('colorHalftone');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(HexagonalPixelatePass).whenTargetNamed('hexagonalPixelate');
  sceneContainer.bind(TYPES.IPostProcessingPass).to(InkPass).whenTargetNamed('ink');

  // 绑定工厂方法
  sceneContainer.bind(TYPES.IFactoryPostProcessingPass).toFactory(function (context) {
    return function (named) {
      var pass = context.container.getNamed(TYPES.IPostProcessingPass, named);
      pass.setName(named);
      return pass;
    };
  });
  return sceneContainer;
}
export function createLayerContainer(sceneContainer) {
  var layerContainer = new Container();
  layerContainer.parent = sceneContainer;
  layerContainer.bind(TYPES.IStyleAttributeService).to(StyleAttributeService).inSingletonScope();
  layerContainer.bind(TYPES.IMultiPassRenderer).to(MultiPassRenderer).inSingletonScope();
  layerContainer.bind(TYPES.IPostProcessor).to(PostProcessor).inSingletonScope();
  return layerContainer;
}