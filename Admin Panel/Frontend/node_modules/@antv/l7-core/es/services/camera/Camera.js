import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { mat3, mat4, quat, vec3, vec4 } from 'gl-matrix';
import { createVec3, getAngle } from "../../utils/math";
// import Landmark from './Landmark';

export var CAMERA_TYPE;
(function (CAMERA_TYPE) {
  CAMERA_TYPE["ORBITING"] = "ORBITING";
  CAMERA_TYPE["EXPLORING"] = "EXPLORING";
  CAMERA_TYPE["TRACKING"] = "TRACKING";
})(CAMERA_TYPE || (CAMERA_TYPE = {}));
export var CAMERA_TRACKING_MODE;
(function (CAMERA_TRACKING_MODE) {
  CAMERA_TRACKING_MODE["DEFAULT"] = "DEFAULT";
  CAMERA_TRACKING_MODE["ROTATIONAL"] = "ROTATIONAL";
  CAMERA_TRACKING_MODE["TRANSLATIONAL"] = "TRANSLATIONAL";
  CAMERA_TRACKING_MODE["CINEMATIC"] = "CINEMATIC";
})(CAMERA_TRACKING_MODE || (CAMERA_TRACKING_MODE = {}));
var DEG_2_RAD = Math.PI / 180;
var RAD_2_DEG = 180 / Math.PI;

/**
 * 参考「WebGL Insights - 23.Designing Cameras for WebGL Applications」，基于 Responsible Camera 思路设计
 * 保存相机参数，定义相机动作：
 * 1. dolly 沿 n 轴移动
 * 2. pan 沿 u v 轴移动
 * 3. rotate 以方位角旋转
 * 4. 移动到 Landmark，具有平滑的动画效果，其间禁止其他用户交互
 */
var Camera = /*#__PURE__*/function () {
  /**
   * 相机矩阵
   */

  /**
   * u 轴
   * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition
   */

  /**
   * v 轴
   */

  /**
   * n 轴
   */

  /**
   * 相机位置
   */

  /**
   * 视点位置
   */

  /**
   * 相机位置到视点向量
   * focalPoint - position
   */

  /**
   * 相机位置到视点距离
   * length(focalPoint - position)
   */

  /**
   * @see https://en.wikipedia.org/wiki/Azimuth
   */

  /**
   * 沿 n 轴移动时，保证移动速度从快到慢
   */

  /**
   * invert the horizontal coordinate system HCS
   */

  /**
   * 投影矩阵参数
   */

  /**
   * field of view [0-360]
   * @see http://en.wikipedia.org/wiki/Angle_of_view
   */

  /**
   * 投影矩阵
   */

  function Camera(type) {
    _classCallCheck(this, Camera);
    _defineProperty(this, "matrix", mat4.create());
    _defineProperty(this, "right", vec3.fromValues(1, 0, 0));
    _defineProperty(this, "up", vec3.fromValues(0, 1, 0));
    _defineProperty(this, "forward", vec3.fromValues(0, 0, 1));
    _defineProperty(this, "position", vec3.fromValues(0, 0, 1));
    _defineProperty(this, "focalPoint", vec3.fromValues(0, 0, 0));
    _defineProperty(this, "distanceVector", vec3.fromValues(0, 0, 0));
    _defineProperty(this, "distance", 1);
    _defineProperty(this, "azimuth", 0);
    _defineProperty(this, "elevation", 0);
    _defineProperty(this, "roll", 0);
    _defineProperty(this, "relAzimuth", 0);
    _defineProperty(this, "relElevation", 0);
    _defineProperty(this, "relRoll", 0);
    _defineProperty(this, "dollyingStep", 0);
    _defineProperty(this, "rotateWorld", false);
    _defineProperty(this, "fov", 30);
    _defineProperty(this, "near", 0.1);
    _defineProperty(this, "far", 10000);
    _defineProperty(this, "aspect", 1);
    _defineProperty(this, "perspective", mat4.create());
    _defineProperty(this, "following", undefined);
    _defineProperty(this, "type", CAMERA_TYPE.EXPLORING);
    _defineProperty(this, "trackingMode", CAMERA_TRACKING_MODE.DEFAULT);
    this.setType(type, undefined);
  }
  _createClass(Camera, [{
    key: "setType",
    value: function setType(type, trackingMode) {
      this.type = type;
      if (this.type === CAMERA_TYPE.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== undefined) {
        this.setTrackingMode(trackingMode);
      }
    }
  }, {
    key: "setTrackingMode",
    value: function setTrackingMode(trackingMode) {
      if (this.type !== CAMERA_TYPE.TRACKING) {
        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
      }
      this.trackingMode = trackingMode;
    }

    /**
     * If flag is true, it reverses the azimuth and elevation angles.
     * Subsequent calls to rotate, setAzimuth, setElevation,
     * changeAzimuth or changeElevation will cause the inverted effect.
     * setRoll or changeRoll is not affected by this method.
     *
     * This inversion is useful when one wants to simulate that the world
     * is moving, instead of the camera.
     *
     * By default the camera angles are not reversed.
     * @param {Boolean} flag the boolean flag to reverse the angles.
     */
  }, {
    key: "setWorldRotation",
    value: function setWorldRotation(flag) {
      this.rotateWorld = flag;
      this._getAngles();
    }

    /**
     * 计算 MV 矩阵，为相机矩阵的逆矩阵
     */
  }, {
    key: "getViewTransform",
    value: function getViewTransform() {
      return mat4.invert(mat4.create(), this.matrix);
    }

    /**
     * 设置相机矩阵
     */
  }, {
    key: "setMatrix",
    value: function setMatrix(matrix) {
      this.matrix = matrix;
      this._update();
    }
  }, {
    key: "setPerspective",
    value: function setPerspective(near, far, angle, aspect) {
      this.fov = angle;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      this.updatePerspective();
    }
  }, {
    key: "updatePerspective",
    value: function updatePerspective() {
      mat4.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);
    }

    /**
     * 设置相机位置
     */
  }, {
    key: "setPosition",
    value: function setPosition(x, y, z) {
      this._setPosition(x, y, z);
      this.setFocalPoint(this.focalPoint);
      return this;
    }

    /**
     * 设置视点位置
     */
  }, {
    key: "setFocalPoint",
    value: function setFocalPoint(x, y, z) {
      var up = vec3.fromValues(0, 1, 0);
      this.focalPoint = createVec3(x, y, z);
      if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {
        var d = vec3.subtract(vec3.create(), this.focalPoint, this.position);
        x = d[0];
        y = d[1];
        z = d[2];
        var r = vec3.length(d);
        var el = Math.asin(y / r) * RAD_2_DEG;
        var az = 90 + Math.atan2(z, x) * RAD_2_DEG;
        var m = mat4.create();
        mat4.rotateY(m, m, az * DEG_2_RAD);
        mat4.rotateX(m, m, el * DEG_2_RAD);
        up = vec3.transformMat4(vec3.create(), [0, 1, 0], m);
      }
      mat4.invert(this.matrix, mat4.lookAt(mat4.create(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      return this;
    }

    /**
     * 固定当前视点，按指定距离放置相机
     */
  }, {
    key: "setDistance",
    value: function setDistance(d) {
      if (this.distance === d || d < 0) {
        return;
      }
      this.distance = d;
      this.dollyingStep = this.distance / 100;
      var pos = vec3.create();
      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d * n[0] + f[0];
      pos[1] = d * n[1] + f[1];
      pos[2] = d * n[2] + f[2];
      this._setPosition(pos);
      return this;
    }

    /**
     * Changes the initial azimuth of the camera
     */
  }, {
    key: "changeAzimuth",
    value: function changeAzimuth(az) {
      this.setAzimuth(this.azimuth + az);
      return this;
    }

    /**
     * Changes the initial elevation of the camera
     */
  }, {
    key: "changeElevation",
    value: function changeElevation(el) {
      this.setElevation(this.elevation + el);
      return this;
    }

    /**
     * Changes the initial roll of the camera
     */
  }, {
    key: "changeRoll",
    value: function changeRoll(rl) {
      this.setRoll(this.roll + rl);
      return this;
    }

    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     * @param {Number} el the azimuth in degrees
     */
  }, {
    key: "setAzimuth",
    value: function setAzimuth(az) {
      this.azimuth = getAngle(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }
      return this;
    }
  }, {
    key: "getAzimuth",
    value: function getAzimuth() {
      return this.azimuth;
    }

    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     * @param {Number} el the elevation in degrees
     */
  }, {
    key: "setElevation",
    value: function setElevation(el) {
      this.elevation = getAngle(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }
      return this;
    }

    /**
     * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
     * @param {Number} angle the roll angle
     */
  }, {
    key: "setRoll",
    value: function setRoll(angle) {
      this.roll = getAngle(angle);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }
      return this;
    }

    /**
     * Changes the azimuth and elevation with respect to the current camera axes
     * @param {Number} azimuth the relative azimuth
     * @param {Number} elevation the relative elevation
     * @param {Number} roll the relative roll
     */
  }, {
    key: "rotate",
    value: function rotate(azimuth, elevation, roll) {
      if (this.type === CAMERA_TYPE.EXPLORING) {
        azimuth = getAngle(azimuth);
        elevation = getAngle(elevation);
        roll = getAngle(roll);
        var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);
        var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);
        var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], roll * DEG_2_RAD);
        var rotQ = quat.multiply(quat.create(), rotY, rotX);
        rotQ = quat.multiply(quat.create(), rotQ, rotZ);
        var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);
        mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
        mat4.multiply(this.matrix, this.matrix, rotMatrix);
        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else {
        if (Math.abs(this.elevation + elevation) > 90) {
          return;
        }
        this.relElevation = getAngle(elevation);
        this.relAzimuth = getAngle(azimuth);
        this.relRoll = getAngle(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        this.computeMatrix();
      }
      this._getAxes();
      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        this._getPosition();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        this._getFocalPoint();
      }
      this._update();
      return this;
    }

    /**
     * 沿水平(right) & 垂直(up)平移相机
     */
  }, {
    key: "pan",
    value: function pan(tx, ty) {
      var coords = createVec3(tx, ty, 0);
      var pos = vec3.clone(this.position);
      vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));
      vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));
      this._setPosition(pos);
      return this;
    }

    /**
     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
     */
  }, {
    key: "dolly",
    value: function dolly(value) {
      var n = this.forward;
      var pos = vec3.clone(this.position);
      var step = value * this.dollyingStep;
      pos[0] += step * n[0];
      pos[1] += step * n[1];
      pos[2] += step * n[2];
      this._setPosition(pos);
      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        // 重新计算视点距离
        this._getDistance();
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        // 保持视距，移动视点位置
        vec3.add(this.focalPoint, pos, this.distanceVector);
      }
      return this;
    }

    // public createLandmark(name: string): Landmark {
    //   return new Landmark(name, this);
    // }

    /**
     * 根据相机矩阵重新计算各种相机参数
     */
  }, {
    key: "_update",
    value: function _update() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
    }

    /**
     * 计算相机矩阵
     */
  }, {
    key: "computeMatrix",
    value: function computeMatrix() {
      // 使用四元数描述 3D 旋转
      // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html
      var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], this.roll * DEG_2_RAD);
      mat4.identity(this.matrix);

      // only consider HCS for EXPLORING and ORBITING cameras
      var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], (this.rotateWorld || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);
      var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * this.azimuth * DEG_2_RAD);
      var rotQ = quat.multiply(quat.create(), rotY, rotX);
      rotQ = quat.multiply(quat.create(), rotQ, rotZ);
      var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);
      if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
        mat4.translate(this.matrix, this.matrix, this.focalPoint);
        mat4.multiply(this.matrix, this.matrix, rotMatrix);
        mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CAMERA_TYPE.TRACKING) {
        mat4.translate(this.matrix, this.matrix, this.position);
        mat4.multiply(this.matrix, this.matrix, rotMatrix);
      }
    }

    /**
     * Sets the camera position in the camera matrix
     */
  }, {
    key: "_setPosition",
    value: function _setPosition(x, y, z) {
      this.position = createVec3(x, y, z);
      var m = this.matrix;
      m[12] = this.position[0];
      m[13] = this.position[1];
      m[14] = this.position[2];
      m[15] = 1;
    }

    /**
     * Recalculates axes based on the current matrix
     */
  }, {
    key: "_getAxes",
    value: function _getAxes() {
      vec3.copy(this.right, createVec3(vec4.transformMat4(vec4.create(), [1, 0, 0, 0], this.matrix)));
      vec3.copy(this.up, createVec3(vec4.transformMat4(vec4.create(), [0, 1, 0, 0], this.matrix)));
      vec3.copy(this.forward, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 1, 0], this.matrix)));
      vec3.normalize(this.right, this.right);
      vec3.normalize(this.up, this.up);
      vec3.normalize(this.forward, this.forward);
    }

    /**
     * Recalculates euler angles based on the current state
     */
  }, {
    key: "_getAngles",
    value: function _getAngles() {
      // Recalculates angles
      var x = this.distanceVector[0];
      var y = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r = vec3.length(this.distanceVector);

      // FAST FAIL: If there is no distance we cannot compute angles
      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CAMERA_TYPE.TRACKING) {
        this.elevation = Math.asin(y / r) * RAD_2_DEG;
        this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
      } else {
        if (this.rotateWorld) {
          this.elevation = Math.asin(y / r) * RAD_2_DEG;
          this.azimuth = Math.atan2(-x, -z) * RAD_2_DEG;
        } else {
          this.elevation = -Math.asin(y / r) * RAD_2_DEG;
          this.azimuth = -Math.atan2(-x, -z) * RAD_2_DEG;
        }
      }
    }

    /**
     * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
     */
  }, {
    key: "_getPosition",
    value: function _getPosition() {
      vec3.copy(this.position, createVec3(vec4.transformMat4(vec4.create(), [0, 0, 0, 1], this.matrix)));

      // 相机位置变化，需要重新计算视距
      this._getDistance();
    }

    /**
     * 重新计算视点，只有 TRACKING 模式视点才会发生变化
     */
  }, {
    key: "_getFocalPoint",
    value: function _getFocalPoint() {
      vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3.fromMat4(mat3.create(), this.matrix));
      vec3.add(this.focalPoint, this.position, this.distanceVector);

      // 视点变化，需要重新计算视距
      this._getDistance();
    }

    /**
     * 重新计算视距
     */
  }, {
    key: "_getDistance",
    value: function _getDistance() {
      this.distanceVector = vec3.subtract(vec3.create(), this.focalPoint, this.position);
      this.distance = vec3.length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    }
  }]);
  return Camera;
}();
export { Camera as default };