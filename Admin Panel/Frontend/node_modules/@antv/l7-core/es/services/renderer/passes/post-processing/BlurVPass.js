import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
var _dec, _class;
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { injectable } from 'inversify';
import { isNil } from 'lodash';
/* babel-plugin-inline-import '../../../../shaders/post-processing/blur.glsl' */
var blur = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform vec2 u_BlurDir: [1.0, 0.0];\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nvoid main() {\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\n}";
/* babel-plugin-inline-import '../../../../shaders/post-processing/quad.glsl' */
var quad = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
import BasePostProcessingPass from "../BasePostProcessingPass";
var BlurVPass = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_BasePostProcessingPa) {
  _inherits(BlurVPass, _BasePostProcessingPa);
  var _super = _createSuper(BlurVPass);
  function BlurVPass() {
    _classCallCheck(this, BlurVPass);
    return _super.apply(this, arguments);
  }
  _createClass(BlurVPass, [{
    key: "setupShaders",
    value: function setupShaders() {
      this.shaderModuleService.registerModule('blur-pass', {
        vs: quad,
        fs: blur
      });
      var _this$shaderModuleSer = this.shaderModuleService.getModule('blur-pass'),
        vs = _this$shaderModuleSer.vs,
        fs = _this$shaderModuleSer.fs,
        uniforms = _this$shaderModuleSer.uniforms;
      var _this$rendererService = this.rendererService.getViewportSize(),
        width = _this$rendererService.width,
        height = _this$rendererService.height;
      return {
        vs: vs,
        fs: fs,
        uniforms: _objectSpread(_objectSpread({}, uniforms), {}, {
          u_ViewportSize: [width, height]
        })
      };
    }
  }, {
    key: "convertOptionsToUniforms",
    value: function convertOptionsToUniforms(options) {
      var uniforms = {};
      if (!isNil(options.blurRadius)) {
        uniforms.u_BlurDir = [0, options.blurRadius];
      }
      return uniforms;
    }
  }]);
  return BlurVPass;
}(BasePostProcessingPass)) || _class);
export { BlurVPass as default };