import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _initializerDefineProperty from "@babel/runtime/helpers/esm/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _get from "@babel/runtime/helpers/esm/get";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/esm/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/esm/initializerWarningHelper";
var _dec, _dec2, _class, _class2, _descriptor;
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { $window } from '@antv/l7-utils';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
/* babel-plugin-inline-import '../../../shaders/post-processing/blend.glsl' */
var blendFS = "uniform float u_opacity : 1.0;\nuniform float u_MixRatio : 0.5;\n\nuniform sampler2D u_Diffuse1;\nuniform sampler2D u_Diffuse2;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  vec4 texel1 = texture2D(u_Diffuse1, v_UV);\n  vec4 texel2 = texture2D(u_Diffuse2, v_UV);\n  gl_FragColor = u_opacity * mix(texel1, texel2, u_MixRatio);\n}\n";
/* babel-plugin-inline-import '../../../shaders/post-processing/copy.glsl' */
var copyFS = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n}";
/* babel-plugin-inline-import '../../../shaders/post-processing/quad.glsl' */
var quadVS = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
import { TYPES } from "../../../types";
import { gl } from "../gl";
import { PassType } from "../IMultiPassRenderer";
import BaseNormalPass from "./BaseNormalPass";

// Generate halton sequence
// https://en.wikipedia.org/wiki/Halton_sequence
function halton(index, base) {
  var result = 0;
  var f = 1 / base;
  var i = index;
  while (i > 0) {
    result = result + f * (i % base);
    i = Math.floor(i / base);
    f = f / base;
  }
  return result;
}

// 累加计数器
var accumulatingId = 1;

/**
 * TAA（Temporal Anti-Aliasing）
 * 在需要后处理的场景中（例如 L7 的热力图需要 blur pass、PBR 中的 SSAO 环境光遮蔽），无法使用浏览器内置的 MSAA，
 * 只能使用 TAA
 * @see https://yuque.antfin-inc.com/yuqi.pyq/fgetpa/ri52hv
 */
var TAAPass = (_dec = injectable(), _dec2 = inject(TYPES.IShaderModuleService), _dec(_class = (_class2 = /*#__PURE__*/function (_BaseNormalPass) {
  _inherits(TAAPass, _BaseNormalPass);
  var _super = _createSuper(TAAPass);
  function TAAPass() {
    var _this;
    _classCallCheck(this, TAAPass);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _initializerDefineProperty(_assertThisInitialized(_this), "shaderModuleService", _descriptor, _assertThisInitialized(_this));
    _defineProperty(_assertThisInitialized(_this), "haltonSequence", []);
    _defineProperty(_assertThisInitialized(_this), "accumulatingId", 0);
    _defineProperty(_assertThisInitialized(_this), "frame", 0);
    _defineProperty(_assertThisInitialized(_this), "timer", undefined);
    _defineProperty(_assertThisInitialized(_this), "sampleRenderTarget", void 0);
    _defineProperty(_assertThisInitialized(_this), "prevRenderTarget", void 0);
    _defineProperty(_assertThisInitialized(_this), "outputRenderTarget", void 0);
    _defineProperty(_assertThisInitialized(_this), "copyRenderTarget", void 0);
    _defineProperty(_assertThisInitialized(_this), "blendModel", void 0);
    _defineProperty(_assertThisInitialized(_this), "outputModel", void 0);
    _defineProperty(_assertThisInitialized(_this), "copyModel", void 0);
    return _this;
  }
  _createClass(TAAPass, [{
    key: "getType",
    value: function getType() {
      return PassType.Normal;
    }
  }, {
    key: "getName",
    value: function getName() {
      return 'taa';
    }
  }, {
    key: "init",
    value: function init(layer, config) {
      _get(_getPrototypeOf(TAAPass.prototype), "init", this).call(this, layer, config);
      var _this$rendererService = this.rendererService,
        createFramebuffer = _this$rendererService.createFramebuffer,
        createTexture2D = _this$rendererService.createTexture2D;
      this.sampleRenderTarget = createFramebuffer({
        color: createTexture2D({
          width: 1,
          height: 1,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        })
      });
      this.prevRenderTarget = createFramebuffer({
        color: createTexture2D({
          width: 1,
          height: 1,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        })
      });
      this.outputRenderTarget = createFramebuffer({
        color: createTexture2D({
          width: 1,
          height: 1,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        })
      });
      this.copyRenderTarget = createFramebuffer({
        color: createTexture2D({
          width: 1,
          height: 1,
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        })
      });
      for (var i = 0; i < 30; i++) {
        this.haltonSequence.push([halton(i, 2), halton(i, 3)]);
      }
      this.blendModel = this.createTriangleModel('blend-pass', blendFS);
      this.outputModel = this.createTriangleModel('copy-pass', copyFS, {
        blend: {
          enable: true,
          func: {
            srcRGB: gl.ONE,
            dstRGB: gl.ONE_MINUS_SRC_ALPHA,
            srcAlpha: gl.ONE,
            dstAlpha: gl.ONE_MINUS_SRC_ALPHA
          },
          equation: {
            rgb: gl.FUNC_ADD,
            alpha: gl.FUNC_ADD
          }
        }
      });
      this.copyModel = this.createTriangleModel('copy-pass', copyFS);
    }
  }, {
    key: "render",
    value: function render(layer) {
      var _this2 = this;
      var _this$rendererService2 = this.rendererService,
        clear = _this$rendererService2.clear,
        getViewportSize = _this$rendererService2.getViewportSize,
        useFramebuffer = _this$rendererService2.useFramebuffer;
      var _getViewportSize = getViewportSize(),
        width = _getViewportSize.width,
        height = _getViewportSize.height;
      this.sampleRenderTarget.resize({
        width: width,
        height: height
      });
      this.prevRenderTarget.resize({
        width: width,
        height: height
      });
      this.outputRenderTarget.resize({
        width: width,
        height: height
      });
      this.copyRenderTarget.resize({
        width: width,
        height: height
      });
      this.resetFrame();
      // 首先停止上一次的累加
      this.stopAccumulating();

      // 先输出到 PostProcessor
      var readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();
      useFramebuffer(readFBO, function () {
        clear({
          color: [0, 0, 0, 0],
          depth: 1,
          stencil: 0,
          framebuffer: readFBO
        });

        // render to post processor
        layer.multiPassRenderer.setRenderFlag(false);
        layer.render();
        layer.multiPassRenderer.setRenderFlag(true);
      });
      var accumulate = function accumulate(id) {
        // 在开启新一轮累加之前，需要先结束掉之前的累加
        if (!_this2.accumulatingId || id !== _this2.accumulatingId) {
          return;
        }
        if (!_this2.isFinished()) {
          _this2.doRender(layer);
          $window.requestAnimationFrame(function () {
            accumulate(id);
          });
        }
      };
      this.accumulatingId = accumulatingId++;
      // @ts-ignore
      this.timer = $window.setTimeout(function () {
        accumulate(_this2.accumulatingId);
      }, 50);
    }
  }, {
    key: "doRender",
    value: function doRender(layer) {
      var _this3 = this;
      var _this$rendererService3 = this.rendererService,
        clear = _this$rendererService3.clear,
        getViewportSize = _this$rendererService3.getViewportSize,
        useFramebuffer = _this$rendererService3.useFramebuffer;
      var _getViewportSize2 = getViewportSize(),
        width = _getViewportSize2.width,
        height = _getViewportSize2.height;
      var _layer$getLayerConfig = layer.getLayerConfig(),
        _layer$getLayerConfig2 = _layer$getLayerConfig.jitterScale,
        jitterScale = _layer$getLayerConfig2 === void 0 ? 1 : _layer$getLayerConfig2;

      // 使用 Halton 序列抖动投影矩阵
      var offset = this.haltonSequence[this.frame % this.haltonSequence.length];
      this.cameraService.jitterProjectionMatrix((offset[0] * 2.0 - 1.0) / width * jitterScale, (offset[1] * 2.0 - 1.0) / height * jitterScale);

      // 按抖动后的投影矩阵渲染
      layer.multiPassRenderer.setRenderFlag(false);
      layer.hooks.beforeRender.call();
      useFramebuffer(this.sampleRenderTarget, function () {
        clear({
          color: [0, 0, 0, 0],
          depth: 1,
          stencil: 0,
          framebuffer: _this3.sampleRenderTarget
        });
        layer.render();
      });
      layer.hooks.afterRender.call();
      layer.multiPassRenderer.setRenderFlag(true);

      // 混合
      var layerStyleOptions = layer.getLayerConfig();
      useFramebuffer(this.outputRenderTarget, function () {
        _this3.blendModel.draw({
          uniforms: {
            // @ts-ignore
            u_opacity: layerStyleOptions.opacity || 1,
            u_MixRatio: _this3.frame === 0 ? 1 : 0.9,
            u_Diffuse1: _this3.sampleRenderTarget,
            u_Diffuse2: _this3.frame === 0 ? layer.multiPassRenderer.getPostProcessor().getReadFBO() : _this3.prevRenderTarget
          }
        });
      });

      // 输出累加结果
      if (this.frame === 0) {
        clear({
          color: [0, 0, 0, 0],
          depth: 1,
          stencil: 0,
          framebuffer: this.copyRenderTarget
        });
      }
      if (this.frame >= 1) {
        useFramebuffer(this.copyRenderTarget, function () {
          _this3.outputModel.draw({
            uniforms: {
              u_Texture: _this3.outputRenderTarget
            }
          });
        });
        useFramebuffer(layer.multiPassRenderer.getPostProcessor().getReadFBO(), function () {
          _this3.copyModel.draw({
            uniforms: {
              u_Texture: _this3.copyRenderTarget
            }
          });
        });
        layer.multiPassRenderer.getPostProcessor().render(layer);
      }

      // 保存前序帧结果
      var tmp = this.prevRenderTarget;
      this.prevRenderTarget = this.outputRenderTarget;
      this.outputRenderTarget = tmp;
      this.frame++;

      // 恢复 jitter 后的相机
      this.cameraService.clearJitterProjectionMatrix();
    }

    /**
     * 是否已经完成累加
     * @return {boolean} isFinished
     */
  }, {
    key: "isFinished",
    value: function isFinished() {
      return this.frame >= this.haltonSequence.length;
    }
  }, {
    key: "resetFrame",
    value: function resetFrame() {
      this.frame = 0;
    }
  }, {
    key: "stopAccumulating",
    value: function stopAccumulating() {
      this.accumulatingId = 0;
      $window.clearTimeout(this.timer);
    }
  }, {
    key: "createTriangleModel",
    value: function createTriangleModel(shaderModuleName, fragmentShader, options) {
      this.shaderModuleService.registerModule(shaderModuleName, {
        vs: quadVS,
        fs: fragmentShader
      });
      var _this$shaderModuleSer = this.shaderModuleService.getModule(shaderModuleName),
        vs = _this$shaderModuleSer.vs,
        fs = _this$shaderModuleSer.fs,
        uniforms = _this$shaderModuleSer.uniforms;
      var _this$rendererService4 = this.rendererService,
        createAttribute = _this$rendererService4.createAttribute,
        createBuffer = _this$rendererService4.createBuffer,
        createModel = _this$rendererService4.createModel;
      return createModel(_objectSpread({
        vs: vs,
        fs: fs,
        attributes: {
          // 使用一个全屏三角形，相比 Quad 顶点数目更少
          a_Position: createAttribute({
            buffer: createBuffer({
              data: [-4, -4, 4, -4, 0, 4],
              type: gl.FLOAT
            }),
            size: 2
          })
        },
        uniforms: _objectSpread({}, uniforms),
        depth: {
          enable: false
        },
        count: 3
      }, options));
    }
  }]);
  return TAAPass;
}(BaseNormalPass), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "shaderModuleService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { TAAPass as default };