import { RequestParameters, TilesetManager } from '@antv/l7-utils';
import { BBox } from '@turf/helpers';
export type DataType = string | object[] | object;
export type SourceEventType = 'inited' | 'sourceUpdate' | 'update';
export declare enum RasterTileType {
    IMAGE = "image",
    CUSTOMIMAGE = "customImage",
    ARRAYBUFFER = "arraybuffer",
    RGB = "rgb",
    TERRAINRGB = "terrainRGB",
    CUSTOMRGB = "customRGB",
    CUSTOMARRAYBUFFER = "customArrayBuffer",
    CUSTOMTERRAINRGB = "customTerrainRGB"
}
export interface IGeojsonvtOptions {
    maxZoom: number;
    indexMaxZoom: number;
    indexMaxPoints: number;
    tolerance: number;
    extent: number;
    buffer: number;
    lineMetrics: boolean;
    promoteId: null;
    generateId: boolean;
    debug: number;
}
export interface ITileParserCFG {
    type: string;
    tileSize?: number;
    minZoom?: number;
    maxZoom?: number;
    zoomOffset?: number;
    getCustomData: (tile: {
        x: number;
        y: number;
        z: number;
    }, cb: (err: any, data: any) => void) => void;
    extent?: [number, number, number, number];
    requestParameters: Partial<RequestParameters>;
    updateStrategy?: 'overlap' | 'replace';
    featureId?: string;
    sourceLayer?: string;
    coord?: string;
    dataType?: RasterTileType;
    geojsonvtOptions?: IGeojsonvtOptions;
    wmtsOptions: IWMTSServiceOption;
    format?: any;
    operation?: any;
    getURLFromTemplate?: (template: string, properties: {
        x: number;
        y: number;
        z: number;
    }) => string;
    transformResponse?: (response: object) => any;
}
export interface IWMTSServiceOption {
    layer: string;
    version?: string;
    style?: string;
    format: string;
    service?: string;
    tileMatrixset: string;
}
export interface IParserCfg {
    type: string;
    x?: string;
    y?: string;
    x1?: string;
    y1?: string;
    coordinates?: string;
    geometry?: string;
    [key: string]: any;
}
type CallBack = (...args: any[]) => any;
export interface ITransform {
    type: string;
    [key: string]: any;
    callback?: CallBack;
}
export interface ISourceCFG {
    cluster?: boolean;
    clusterOptions?: Partial<IClusterOptions>;
    autoRender?: boolean;
    parser?: IParserCfg | ITileParserCFG;
    transforms?: ITransform[];
}
export interface IClusterOptions {
    enable: false;
    radius: number;
    maxZoom: number;
    minZoom: number;
    zoom: number;
    bbox: [number, number, number, number];
    field: string;
    method: 'max' | 'sum' | 'min' | 'mean' | 'count' | CallBack;
}
export interface IDictionary<TValue> {
    [key: string]: TValue;
}
export interface IFeatureKey {
    [key: string]: {
        index: number;
        idField: any;
    };
}
export interface IParseDataItem {
    coordinates: any[];
    _id: number;
    [key: string]: any;
}
export interface IParserData {
    [key: string]: any;
    dataArray: IParseDataItem[];
    featureKeys?: IFeatureKey;
}
export interface IJsonItem {
    [key: string]: any;
}
export type IJsonData = IJsonItem[];
export interface ISource {
    inited: boolean;
    isTile: boolean;
    data: IParserData;
    center: [number, number];
    parser: IParserCfg;
    transforms: ITransform[];
    cluster: boolean;
    clusterOptions: Partial<IClusterOptions>;
    extent: BBox;
    tileset: TilesetManager | undefined;
    getSourceCfg(): any;
    setData(data: any, options?: ISourceCFG): void;
    updateClusterData(zoom: number): void;
    getFeatureById(id: number): unknown;
    getFeatureId(field: string, value: any): number | undefined;
    getParserType(): string;
    getClusters(zoom: number): any;
    getClustersLeaves(id: number): any;
    updateFeaturePropertiesById(id: number, properties: Record<string, any>): void;
    destroy(): void;
    on(type: SourceEventType | string, handler: (...args: any[]) => void): void;
    off(type: SourceEventType | string, handler: (...args: any[]) => void): void;
    once(type: SourceEventType | string, handler: (...args: any[]) => void): void;
}
export interface IRasterCfg {
    extent: [number, number, number, number];
    width: number;
    height: number;
    max: number;
    min: number;
}
export interface IRasterParserDataItem extends IParseDataItem {
    data: number[];
    width: number;
    height: number;
}
export {};
