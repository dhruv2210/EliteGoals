import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _dec, _class;
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { $window, LRUCache } from '@antv/l7-utils';
import { EventEmitter } from 'eventemitter3';
import { injectable } from 'inversify';
import TinySDF from 'l7-tiny-sdf';
import 'reflect-metadata';
import { buildMapping } from "../../utils/font_util";
export var DEFAULT_CHAR_SET = getDefaultCharacterSet();
export var DEFAULT_FONT_FAMILY = 'sans-serif';
export var DEFAULT_FONT_WEIGHT = 'normal';
export var DEFAULT_FONT_SIZE = 24;
export var DEFAULT_BUFFER = 3;
export var DEFAULT_CUTOFF = 0.25;
export var DEFAULT_RADIUS = 8;
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 1.0;
var HEIGHT_SCALE = 1.0;
var CACHE_LIMIT = 3;
export var VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];
function getDefaultCharacterSet() {
  var charSet = [];
  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = 'black';
  ctx.textBaseline = 'middle';
  // ctx.textAlign = 'left';
}

function populateAlphaChannel(alphaChannel, imageData) {
  // populate distance value from tinySDF to image alpha channel
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
var FontService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function (_EventEmitter) {
  _inherits(FontService, _EventEmitter);
  var _super = _createSuper(FontService);
  function FontService() {
    var _this;
    _classCallCheck(this, FontService);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "fontAtlas", void 0);
    _defineProperty(_assertThisInitialized(_this), "iconFontMap", void 0);
    _defineProperty(_assertThisInitialized(_this), "iconFontGlyphs", {});
    _defineProperty(_assertThisInitialized(_this), "fontOptions", void 0);
    _defineProperty(_assertThisInitialized(_this), "key", void 0);
    _defineProperty(_assertThisInitialized(_this), "cache", new LRUCache(CACHE_LIMIT));
    return _this;
  }
  _createClass(FontService, [{
    key: "scale",
    get: function get() {
      return HEIGHT_SCALE;
    }
  }, {
    key: "canvas",
    get: function get() {
      var data = this.cache.get(this.key);
      return data && data.data;
    }
  }, {
    key: "mapping",
    get: function get() {
      var data = this.cache.get(this.key);
      return data && data.mapping || {};
    }
  }, {
    key: "getCanvasByKey",
    value: function getCanvasByKey(key) {
      var data = this.cache.get(key);
      return data && data.data;
    }
  }, {
    key: "getMappingByKey",
    value: function getMappingByKey(key) {
      var data = this.cache.get(key);
      return data && data.mapping || {};
    }
  }, {
    key: "init",
    value: function init() {
      this.cache.clear();
      this.fontOptions = {
        fontFamily: DEFAULT_FONT_FAMILY,
        fontWeight: DEFAULT_FONT_WEIGHT,
        characterSet: DEFAULT_CHAR_SET,
        fontSize: DEFAULT_FONT_SIZE,
        buffer: DEFAULT_BUFFER,
        sdf: true,
        cutoff: DEFAULT_CUTOFF,
        radius: DEFAULT_RADIUS,
        iconfont: false
      };
      this.key = '';
      this.iconFontMap = new Map();
    }
  }, {
    key: "addIconGlyphs",
    value: function addIconGlyphs(glyphs) {
      var _this2 = this;
      glyphs.forEach(function (glyph) {
        _this2.iconFontGlyphs[glyph.name] = glyph.unicode;
      });
    }

    /**
     * 添加对 iconfont unicode 的映射
     * @param fontUnicode
     * @param name
     */
  }, {
    key: "addIconFont",
    value: function addIconFont(name, fontUnicode) {
      this.iconFontMap.set(name, fontUnicode);
    }

    /**
     * 获取自定义 iconfont 别称对应的 unicode 编码，若是当前的 map 中没有对应的键值对，那么就返回原值
     * @param name
     * @returns
     */
  }, {
    key: "getIconFontKey",
    value: function getIconFontKey(name) {
      return this.iconFontMap.get(name) || name;
    }
  }, {
    key: "getGlyph",
    value: function getGlyph(name) {
      if (this.iconFontGlyphs[name]) {
        return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));
      }
      return '';
    }
  }, {
    key: "setFontOptions",
    value: function setFontOptions(option) {
      this.fontOptions = _objectSpread(_objectSpread({}, this.fontOptions), option);
      this.key = this.getKey();
      var charSet = this.getNewChars(this.key, this.fontOptions.characterSet);
      var cachedFontAtlas = this.cache.get(this.key);
      if (cachedFontAtlas && charSet.length === 0) {
        // update texture with cached fontAtlas
        return;
      }
      // update fontAtlas with new settings
      var fontAtlas = this.generateFontAtlas(this.key, charSet, cachedFontAtlas);
      this.fontAtlas = fontAtlas;

      // update cache
      this.cache.set(this.key, fontAtlas);
    }
    /**
     * 用户自定义添加第三方字体 （用户使用 layer/point/text/iconfont 的前提需要加载第三方字体文件）
     * @param fontFamily
     * @param fontPath
     */
  }, {
    key: "addFontFace",
    value: function addFontFace(fontFamily, fontPath) {
      var _this3 = this;
      var style = document.createElement('style');
      style.type = 'text/css';
      style.innerText = "\n        @font-face{\n            font-family: '".concat(fontFamily, "';\n            src: url('").concat(fontPath, "') format('woff2'),\n            url('").concat(fontPath, "') format('woff'),\n            url('").concat(fontPath, "') format('truetype');\n        }");
      style.onload = function () {
        if (document.fonts) {
          try {
            // @ts-ignore
            document.fonts.load("24px ".concat(fontFamily), 'L7text');
            document.fonts.ready.then(function () {
              _this3.emit('fontloaded', {
                fontFamily: fontFamily
              });
            });
          } catch (e) {
            console.warn('当前环境不支持 document.fonts !');
            console.warn('当前环境不支持 iconfont !');
            console.warn(e);
          }
        }
      };
      document.getElementsByTagName('head')[0].appendChild(style);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.cache.clear();
      this.iconFontMap.clear();
    }
  }, {
    key: "generateFontAtlas",
    value: function generateFontAtlas(key, characterSet, cachedFontAtlas) {
      var _this$fontOptions = this.fontOptions,
        fontFamily = _this$fontOptions.fontFamily,
        fontWeight = _this$fontOptions.fontWeight,
        fontSize = _this$fontOptions.fontSize,
        buffer = _this$fontOptions.buffer,
        sdf = _this$fontOptions.sdf,
        radius = _this$fontOptions.radius,
        cutoff = _this$fontOptions.cutoff,
        iconfont = _this$fontOptions.iconfont;
      var canvas = cachedFontAtlas && cachedFontAtlas.data;
      if (!canvas) {
        canvas = $window.document.createElement('canvas');
        canvas.width = MAX_CANVAS_WIDTH;
      }
      var ctx = canvas.getContext('2d', {
        willReadFrequently: true
      });
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      // 1. build mapping
      var _buildMapping = buildMapping(_objectSpread({
          getFontWidth: function getFontWidth(char) {
            return ctx.measureText(char).width;
          },
          fontHeight: fontSize * HEIGHT_SCALE,
          buffer: buffer,
          characterSet: characterSet,
          maxCanvasWidth: MAX_CANVAS_WIDTH
        }, cachedFontAtlas && {
          mapping: cachedFontAtlas.mapping,
          xOffset: cachedFontAtlas.xOffset,
          yOffset: cachedFontAtlas.yOffset
        })),
        mapping = _buildMapping.mapping,
        canvasHeight = _buildMapping.canvasHeight,
        xOffset = _buildMapping.xOffset,
        yOffset = _buildMapping.yOffset;

      // 2. update canvas
      // copy old canvas data to new canvas only when height changed
      // TODO safari 不能正常更新
      var copyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(copyImageData, 0, 0);
      setTextStyle(ctx, fontFamily, fontSize, fontWeight);

      // 3. layout characters
      if (sdf) {
        var tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
        // used to store distance values from tinySDF
        // tinySDF.size equals `fontSize + buffer * 2`
        var imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);
        var _iterator = _createForOfIteratorHelper(characterSet),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var char = _step.value;
            if (iconfont) {
              // @ts-ignore
              // const icon = eval(
              //   '("' + char.replace('&#x', '\\u').replace(';', '') + '")',
              // );

              var icon = String.fromCharCode(parseInt(char.replace('&#x', '').replace(';', ''), 16));
              var iconData = tinySDF.draw(icon);
              populateAlphaChannel(iconData, imageData);
            } else {
              populateAlphaChannel(tinySDF.draw(char), imageData);
            }
            // populateAlphaChannel(tinySDF.draw(char), imageData);

            // 考虑到描边，需要保留 sdf 的 buffer，不能像 deck.gl 一样直接减去
            ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        var _iterator2 = _createForOfIteratorHelper(characterSet),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _char = _step2.value;
            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return {
        xOffset: xOffset,
        yOffset: yOffset,
        mapping: mapping,
        data: canvas,
        width: canvas.width,
        height: canvas.height
      };
    }
  }, {
    key: "getKey",
    value: function getKey() {
      var _this$fontOptions2 = this.fontOptions,
        fontFamily = _this$fontOptions2.fontFamily,
        fontWeight = _this$fontOptions2.fontWeight;
      return "".concat(fontFamily, "_").concat(fontWeight);
    }

    /**
     *
     * @param key
     * @param characterSet
     * @returns
     * 若是相同的 key，那么将字符存储到同同一个字符列表中
     */
  }, {
    key: "getNewChars",
    value: function getNewChars(key, characterSet) {
      var cachedFontAtlas = this.cache.get(key);
      if (!cachedFontAtlas) {
        return characterSet;
      }
      var newChars = [];
      var cachedMapping = cachedFontAtlas.mapping;
      var cachedCharSet = new Set(Object.keys(cachedMapping));
      var charSet = new Set(characterSet);
      charSet.forEach(function (char) {
        if (!cachedCharSet.has(char)) {
          newChars.push(char);
        }
      });
      return newChars;
    }
  }]);
  return FontService;
}(EventEmitter)) || _class);
export { FontService as default };