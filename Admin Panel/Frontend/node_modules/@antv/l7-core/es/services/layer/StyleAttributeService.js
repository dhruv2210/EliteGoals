import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _initializerDefineProperty from "@babel/runtime/helpers/esm/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/esm/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/esm/initializerWarningHelper";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _excluded = ["modelType"],
  _excluded2 = ["buffer", "update", "name"],
  _excluded3 = ["buffer", "update", "name"],
  _excluded4 = ["buffer", "update", "name"];
var _bytesPerElementMap, _dec, _dec2, _class, _class2, _descriptor;
import { executeWorkerTask } from '@antv/l7-utils';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { TYPES } from "../../types";
import { gl } from "../renderer/gl";
import StyleAttribute from "./StyleAttribute";
var bytesPerElementMap = (_bytesPerElementMap = {}, _defineProperty(_bytesPerElementMap, gl.FLOAT, 4), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_BYTE, 1), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_SHORT, 2), _bytesPerElementMap);

/**
 * 每个 Layer 都拥有一个，用于管理样式属性的注册和更新
 */
var StyleAttributeService = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec(_class = (_class2 = /*#__PURE__*/function () {
  function StyleAttributeService() {
    _classCallCheck(this, StyleAttributeService);
    _defineProperty(this, "attributesAndIndices", void 0);
    _initializerDefineProperty(this, "rendererService", _descriptor, this);
    _defineProperty(this, "attributes", []);
    _defineProperty(this, "triangulation", void 0);
    _defineProperty(this, "featureLayout", {
      sizePerElement: 0,
      elements: []
    });
  }
  _createClass(StyleAttributeService, [{
    key: "registerStyleAttribute",
    value: function registerStyleAttribute(options) {
      var attributeToUpdate = this.getLayerStyleAttribute(options.name || '');
      if (attributeToUpdate) {
        attributeToUpdate.setProps(options);
      } else {
        attributeToUpdate = new StyleAttribute(options);
        this.attributes.push(attributeToUpdate);
      }
      return attributeToUpdate;
    }
  }, {
    key: "updateScaleAttribute",
    value: function updateScaleAttribute(scaleOption) {
      this.attributes.forEach(function (attr) {
        var _attr$scale;
        var name = attr.name;
        var field = (_attr$scale = attr.scale) === null || _attr$scale === void 0 ? void 0 : _attr$scale.field;
        if (scaleOption[name] || field && scaleOption[field]) {
          // 字段类型和映射类型
          attr.needRescale = true;
          attr.needRemapping = true;
          attr.needRegenerateVertices = true;
        }
      });
    }
  }, {
    key: "updateStyleAttribute",
    value: function updateStyleAttribute(attributeName, options, updateOptions) {
      var attributeToUpdate = this.getLayerStyleAttribute(attributeName);
      if (!attributeToUpdate) {
        attributeToUpdate = this.registerStyleAttribute(_objectSpread(_objectSpread({}, options), {}, {
          name: attributeName
        }));
      }
      var scale = options.scale;
      if (scale && attributeToUpdate) {
        // TODO: 需要比较新旧值确定是否需要 rescale
        // 需要重新 scale，肯定也需要重新进行数据映射
        attributeToUpdate.scale = scale;
        attributeToUpdate.needRescale = true;
        attributeToUpdate.needRemapping = true;
        attributeToUpdate.needRegenerateVertices = true;
        if (updateOptions && updateOptions.featureRange) {
          attributeToUpdate.featureRange = updateOptions.featureRange;
        }
      }
    }
  }, {
    key: "getLayerStyleAttributes",
    value: function getLayerStyleAttributes() {
      return this.attributes;
    }
  }, {
    key: "getLayerStyleAttribute",
    value: function getLayerStyleAttribute(attributeName) {
      return this.attributes.find(function (attribute) {
        return attribute.name === attributeName;
      });
    }
  }, {
    key: "getLayerAttributeScale",
    value: function getLayerAttributeScale(name) {
      var _attribute$scale;
      var attribute = this.getLayerStyleAttribute(name);
      var scale = attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;
      if (scale && scale[0]) {
        return scale[0].func;
      }
      return null;
    }
  }, {
    key: "updateAttributeByFeatureRange",
    value: function updateAttributeByFeatureRange(attributeName, features) {
      var startFeatureIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var endFeatureIdx = arguments.length > 3 ? arguments[3] : undefined;
      var layer = arguments.length > 4 ? arguments[4] : undefined;
      var attributeToUpdate = this.attributes.find(function (attribute) {
        return attribute.name === attributeName;
      });
      if (attributeToUpdate && attributeToUpdate.descriptor) {
        var descriptor = attributeToUpdate.descriptor;
        var update = descriptor.update,
          buffer = descriptor.buffer,
          _descriptor$size = descriptor.size,
          size = _descriptor$size === void 0 ? 0 : _descriptor$size;
        var bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];
        if (update) {
          var _this$featureLayout = this.featureLayout,
            elements = _this$featureLayout.elements,
            sizePerElement = _this$featureLayout.sizePerElement;
          // 截取待更新的 feature 范围
          var featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);
          // [n, n] 中断更新
          if (!featuresToUpdate.length) {
            return;
          }
          var offset = featuresToUpdate[0].offset;
          // 以 byte 为单位计算 buffer 中的偏移
          var bufferOffsetInBytes = offset * size * bytesPerElement;
          var updatedBufferData = featuresToUpdate.map(function (_ref, attributeIdx) {
            var featureIdx = _ref.featureIdx,
              vertices = _ref.vertices,
              normals = _ref.normals;
            var verticesNumForCurrentFeature = vertices.length / sizePerElement;
            var featureData = [];
            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
              var normal = normals ?
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];
              featureData.push.apply(featureData, _toConsumableArray(update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal)));
            }
            return featureData;
          }).reduce(function (prev, cur) {
            prev.push.apply(prev, _toConsumableArray(cur));
            return prev;
          }, []);

          // 更新底层 IAttribute 中包含的 IBuffer，使用 subdata
          attributeToUpdate.vertexAttribute.updateBuffer({
            data: updatedBufferData,
            offset: bufferOffsetInBytes
          });
          // size color 触发更新事件
          layer === null || layer === void 0 ? void 0 : layer.emit("legend:".concat(attributeName), {
            type: attributeName,
            attr: attributeToUpdate
          });
        }
      }
    }
  }, {
    key: "createAttributesAndIndicesAscy",
    value: function createAttributesAndIndicesAscy(features, segmentNumber, workerOptions) {
      var _this = this;
      // 每次创建的初始化化 LayerOut
      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };
      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      }).filter(function (d) {
        return d;
      });
      var modelType = workerOptions.modelType,
        restOptions = _objectWithoutProperties(workerOptions, _excluded);
      var _this$rendererService = this.rendererService,
        createAttribute = _this$rendererService.createAttribute,
        createBuffer = _this$rendererService.createBuffer,
        createElements = _this$rendererService.createElements;
      var attributes = {};
      return new Promise(function (resolve, reject) {
        executeWorkerTask(modelType, _objectSpread({
          // Tip: worker 不支持传递 function 函数
          descriptors: _this.getDescriptorsWithOutFunc(descriptors),
          features: features,
          segmentNumber: segmentNumber
        }, restOptions)).then(function (e) {
          e.descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor) {
              // IAttribute 参数透传
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              var buffer = descriptor.buffer,
                update = descriptor.update,
                name = descriptor.name,
                rest = _objectWithoutProperties(descriptor, _excluded2);
              var vertexAttribute = createAttribute(_objectSpread({
                // IBuffer 参数透传
                buffer: createBuffer(buffer)
              }, rest));
              attributes[descriptor.name || ''] = vertexAttribute;

              // 在 StyleAttribute 上保存对 VertexAttribute 的引用
              _this.attributes[attributeIdx].vertexAttribute = vertexAttribute;
            }
          });
          _this.featureLayout = e.featureLayout;
          var elements = createElements({
            data: e.indices,
            type: gl.UNSIGNED_INT,
            count: e.indices.length
          });
          _this.attributesAndIndices = {
            attributes: attributes,
            elements: elements,
            count: null
          };
          resolve(_this.attributesAndIndices);
        }).catch(function (err) {
          console.warn(err);
          reject(err);
        });
      });
    }
  }, {
    key: "createAttributesAndIndices",
    value: function createAttributesAndIndices(features, triangulation, segmentNumber) {
      var _this2 = this;
      // 每次创建的初始化化 LayerOut
      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };
      if (triangulation) {
        this.triangulation = triangulation;
      }
      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      });
      var verticesNum = 0;
      var vecticesCount = 0; // 在不使用 element 的时候记录顶点、图层所有顶点的总数
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var vertices = [];
      var indices = [];
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var normals = [];
      var size = 3;
      features.forEach(function (feature, featureIdx) {
        // 逐 feature 进行三角化
        var _this2$triangulation = _this2.triangulation(feature, segmentNumber),
          indicesForCurrentFeature = _this2$triangulation.indices,
          verticesForCurrentFeature = _this2$triangulation.vertices,
          normalsForCurrentFeature = _this2$triangulation.normals,
          vertexSize = _this2$triangulation.size,
          indexes = _this2$triangulation.indexes,
          count = _this2$triangulation.count;
        if (typeof count === 'number') {
          vecticesCount += count;
        }
        indicesForCurrentFeature.forEach(function (i) {
          indices.push(i + verticesNum);
        });
        size = vertexSize;
        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;

        // 记录三角化结果，用于后续精确更新指定 feature
        _this2.featureLayout.sizePerElement = size;
        _this2.featureLayout.elements.push({
          featureIdx: featureIdx,
          vertices: verticesForCurrentFeature,
          normals: normalsForCurrentFeature,
          offset: verticesNum
        });
        verticesNum += verticesNumForCurrentFeature;
        // 根据 position 顶点生成其他顶点数据
        var _loop = function _loop(vertexIdx) {
          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
          var vertexIndex = 0;
          if (indexes && indexes[vertexIdx] !== undefined) {
            vertexIndex = indexes[vertexIdx];
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor && descriptor.update) {
              var _ref2;
              (_ref2 = descriptor.buffer.data).push.apply(_ref2, _toConsumableArray(descriptor.update(feature, featureIdx, vertice, vertexIdx,
              // 当前顶点所在feature索引
              normal, vertexIndex
              // 传入顶点索引 vertexIdx
              )));
            } // end if
          }); // end for each
        };
        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
          _loop(vertexIdx);
        } // end for
      }); // end features for Each
      var _this$rendererService2 = this.rendererService,
        createAttribute = _this$rendererService2.createAttribute,
        createBuffer = _this$rendererService2.createBuffer,
        createElements = _this$rendererService2.createElements;
      var attributes = {};
      descriptors.forEach(function (descriptor, attributeIdx) {
        if (descriptor) {
          // IAttribute 参数透传
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          var buffer = descriptor.buffer,
            update = descriptor.update,
            name = descriptor.name,
            rest = _objectWithoutProperties(descriptor, _excluded3);
          var vertexAttribute = createAttribute(_objectSpread({
            // IBuffer 参数透传
            buffer: createBuffer(buffer)
          }, rest));
          attributes[descriptor.name || ''] = vertexAttribute;

          // 在 StyleAttribute 上保存对 VertexAttribute 的引用
          _this2.attributes[attributeIdx].vertexAttribute = vertexAttribute;
        }
      });
      var elements = createElements({
        data: indices,
        type: gl.UNSIGNED_INT,
        count: indices.length
      });
      this.attributesAndIndices = {
        attributes: attributes,
        elements: elements,
        count: vecticesCount
      };
      return this.attributesAndIndices;
    }
  }, {
    key: "createAttributes",
    value: function createAttributes(features, triangulation) {
      var _this3 = this;
      // 每次创建的初始化化 LayerOut
      this.featureLayout = {
        sizePerElement: 0,
        elements: []
      };
      if (triangulation) {
        this.triangulation = triangulation;
      }
      var descriptors = this.attributes.map(function (attr) {
        attr.resetDescriptor();
        return attr.descriptor;
      });
      var verticesNum = 0;
      var indices = [];
      var size = 3;
      features.forEach(function (feature, featureIdx) {
        // 逐 feature 进行三角化
        var _this3$triangulation = _this3.triangulation(feature),
          indicesForCurrentFeature = _this3$triangulation.indices,
          verticesForCurrentFeature = _this3$triangulation.vertices,
          normalsForCurrentFeature = _this3$triangulation.normals,
          vertexSize = _this3$triangulation.size,
          indexes = _this3$triangulation.indexes;
        indicesForCurrentFeature.forEach(function (i) {
          indices.push(i + verticesNum);
        });
        size = vertexSize;
        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;

        // 记录三角化结果，用于后续精确更新指定 feature
        _this3.featureLayout.sizePerElement = size;
        _this3.featureLayout.elements.push({
          featureIdx: featureIdx,
          vertices: verticesForCurrentFeature,
          normals: normalsForCurrentFeature,
          offset: verticesNum
        });
        verticesNum += verticesNumForCurrentFeature;
        // 根据 position 顶点生成其他顶点数据
        var _loop2 = function _loop2(vertexIdx) {
          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];
          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);
          var vertexIndex = 0;
          if (indexes && indexes[vertexIdx] !== undefined) {
            vertexIndex = indexes[vertexIdx];
          }
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          descriptors.forEach(function (descriptor, attributeIdx) {
            if (descriptor && descriptor.update) {
              var _ref3;
              (_ref3 = descriptor.buffer.data).push.apply(_ref3, _toConsumableArray(descriptor.update(feature, featureIdx, vertice, vertexIdx,
              // 当前顶点所在feature索引
              normal, vertexIndex
              // 传入顶点索引 vertexIdx
              )));
            } // end if
          }); // end for each
        };
        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {
          _loop2(vertexIdx);
        } // end for
      }); // end features for Each
      var _this$rendererService3 = this.rendererService,
        createAttribute = _this$rendererService3.createAttribute,
        createBuffer = _this$rendererService3.createBuffer;
      var attributes = {};
      descriptors.forEach(function (descriptor, attributeIdx) {
        if (descriptor) {
          // IAttribute 参数透传
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          var buffer = descriptor.buffer,
            update = descriptor.update,
            name = descriptor.name,
            rest = _objectWithoutProperties(descriptor, _excluded4);
          var vertexAttribute = createAttribute(_objectSpread({
            // IBuffer 参数透传
            buffer: createBuffer(buffer)
          }, rest));
          attributes[descriptor.name || ''] = vertexAttribute;

          // 在 StyleAttribute 上保存对 VertexAttribute 的引用
          _this3.attributes[attributeIdx].vertexAttribute = vertexAttribute;
        }
      });
      return {
        attributes: attributes
      };
    }
  }, {
    key: "clearAllAttributes",
    value: function clearAllAttributes() {
      var _this$attributesAndIn;
      // 销毁关联的 vertex attribute buffer objects
      this.attributes.forEach(function (attribute) {
        if (attribute.vertexAttribute) {
          attribute.vertexAttribute.destroy();
        }
      });
      (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 ? void 0 : _this$attributesAndIn.elements.destroy();
      this.attributes = [];
    }
  }, {
    key: "getDescriptorsWithOutFunc",
    value: function getDescriptorsWithOutFunc(descriptors) {
      return descriptors.map(function (d) {
        return {
          buffer: d.buffer,
          name: d.name,
          size: d.size
        };
      });
    }
  }]);
  return StyleAttributeService;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "rendererService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { StyleAttributeService as default };