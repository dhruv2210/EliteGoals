import _initializerDefineProperty from "@babel/runtime/helpers/esm/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/esm/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/esm/initializerWarningHelper";
var _dec, _dec2, _class, _class2, _descriptor;
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { $window, isMini } from '@antv/l7-utils';
import EventEmitter from 'eventemitter3';
import { inject, injectable } from 'inversify';
import Hammer from 'l7hammerjs';
import 'reflect-metadata';
// @ts-ignore
import { TYPES } from "../../types";
import { InteractionEvent } from "./IInteractionService";
var DragEventMap = {
  panstart: 'dragstart',
  panmove: 'dragging',
  panend: 'dragend',
  pancancel: 'dragcancel'
};
/**
 * 由于目前 L7 与地图结合的方案为双 canvas 而非共享 WebGL Context，事件监听注册在地图底图上。
 * 除此之外，后续如果支持非地图场景，事件监听就需要注册在 L7 canvas 上。
 */
var InteractionService = (_dec = injectable(), _dec2 = inject(TYPES.IMapService), _dec(_class = (_class2 = /*#__PURE__*/function (_EventEmitter) {
  _inherits(InteractionService, _EventEmitter);
  var _super = _createSuper(InteractionService);
  function InteractionService() {
    var _this;
    _classCallCheck(this, InteractionService);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "indragging", false);
    _initializerDefineProperty(_assertThisInitialized(_this), "mapService", _descriptor, _assertThisInitialized(_this));
    _defineProperty(_assertThisInitialized(_this), "hammertime", void 0);
    _defineProperty(_assertThisInitialized(_this), "lastClickTime", 0);
    _defineProperty(_assertThisInitialized(_this), "lastClickXY", [-1, -1]);
    _defineProperty(_assertThisInitialized(_this), "clickTimer", void 0);
    _defineProperty(_assertThisInitialized(_this), "$containter", void 0);
    _defineProperty(_assertThisInitialized(_this), "onDrag", function (target) {
      var interactionTarget = _this.interactionEvent(target);
      interactionTarget.type = DragEventMap[interactionTarget.type];
      interactionTarget.type === 'dragging' ? _this.indragging = true : _this.indragging = false;
      _this.emit(InteractionEvent.Drag, interactionTarget);
    });
    _defineProperty(_assertThisInitialized(_this), "onHammer", function (target) {
      target.srcEvent.stopPropagation();
      var interactionTarget = _this.interactionEvent(target);
      _this.emit(InteractionEvent.Hover, interactionTarget);
    });
    _defineProperty(_assertThisInitialized(_this), "onTouch", function (target) {
      var touch = target.touches[0];
      // @ts-ignore
      _this.onHover({
        x: touch.pageX,
        y: touch.pageY,
        type: 'touch'
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onHover", function (event) {
      var clientX = event.clientX,
        clientY = event.clientY;
      var x = clientX;
      var y = clientY;
      var type = event.type;
      var $containter = _this.mapService.getMapContainer();
      if ($containter) {
        if (isMini) {
          // l7 - mini
          // @ts-ignore
          x = x - $containter.left - 0;
          // @ts-ignore
          y = y - $containter.top - 0;
        } else {
          var _$containter$getBound = $containter.getBoundingClientRect(),
            top = _$containter$getBound.top,
            left = _$containter$getBound.left;
          x = x - left - $containter.clientLeft;
          y = y - top - $containter.clientTop;
        }
      }
      var lngLat = _this.mapService.containerToLngLat([x, y]);
      if (type === 'click') {
        if (!isMini) {
          // l7 - mini
          if ('ontouchstart' in document.documentElement === true) {
            return;
          }
        }
        _this.isDoubleTap(x, y, lngLat);
        return;
      }
      if (type === 'touch') {
        _this.isDoubleTap(x, y, lngLat);
        return;
      }
      if (type !== 'click' && type !== 'dblclick') {
        _this.emit(InteractionEvent.Hover, {
          x: x,
          y: y,
          lngLat: lngLat,
          type: type,
          target: event
        });
      }
    });
    return _this;
  }
  _createClass(InteractionService, [{
    key: "init",
    value: function init() {
      // 注册事件在地图底图上
      this.addEventListenerOnMap();
      this.$containter = this.mapService.getMapContainer();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.hammertime) {
        this.hammertime.destroy();
      }
      this.removeEventListenerOnMap();
      this.off(InteractionEvent.Hover);
    }
  }, {
    key: "triggerHover",
    value: function triggerHover(_ref) {
      var x = _ref.x,
        y = _ref.y;
      this.emit(InteractionEvent.Hover, {
        x: x,
        y: y
      });
    }
  }, {
    key: "triggerSelect",
    value: function triggerSelect(id) {
      this.emit(InteractionEvent.Select, {
        featureId: id
      });
    }
  }, {
    key: "triggerActive",
    value: function triggerActive(id) {
      this.emit(InteractionEvent.Active, {
        featureId: id
      });
    }
  }, {
    key: "handleMiniEvent",
    value: function handleMiniEvent(e) {
      // @ts-ignore
      this.onHover({
        clientX: e.touches[0].pageX,
        clientY: e.touches[0].pageY,
        type: 'touch'
      });
    }
  }, {
    key: "addEventListenerOnMap",
    value: function addEventListenerOnMap() {
      var $containter = this.mapService.getMapContainer();
      if ($containter) {
        if (isMini) {
          $window.document.addEventListener('touchstart', this.handleMiniEvent.bind(this));
        } else {
          var hammertime = new Hammer.Manager($containter);
          // $containter.addEventListener('mousemove', this.onHover);
          // $containter.addEventListener('click', this.onHover);
          hammertime.add(new Hammer.Tap({
            event: 'dblclick',
            taps: 2
          }));
          hammertime.add(new Hammer.Tap({
            event: 'click'
          }));
          hammertime.add(new Hammer.Pan({
            threshold: 0,
            pointers: 0
          }));
          hammertime.add(new Hammer.Press({}));
          // hammertime.get('pan').set({ direction: Hammer.DIRECTION_ALL });
          // hammertime.get('pinch').set({ enable: true });
          hammertime.on('dblclick click', this.onHammer);
          hammertime.on('panstart panmove panend pancancel', this.onDrag);
          // $containter.addEventListener('touchstart', this.onTouch);
          $containter.addEventListener('mousemove', this.onHover);
          // $containter.addEventListener('click', this.onHover);
          $containter.addEventListener('mousedown', this.onHover, true);
          $containter.addEventListener('mouseup', this.onHover);
          $containter.addEventListener('contextmenu', this.onHover);
          this.hammertime = hammertime;
        }

        // Tip: 根据场景注册事件到 L7 canvas 上
      }
    }
  }, {
    key: "removeEventListenerOnMap",
    value: function removeEventListenerOnMap() {
      if (isMini) {
        $window.document.removeEventListener('touchstart', this.handleMiniEvent.bind(this));
      } else {
        var $containter = this.mapService.getMapContainer();
        if ($containter) {
          $containter.removeEventListener('mousemove', this.onHover);
          this.hammertime.off('dblclick click', this.onHammer);
          this.hammertime.off('panstart panmove panend pancancel', this.onDrag);
          // $containter.removeEventListener('touchstart', this.onTouch);
          // $containter.removeEventListener('click', this.onHover);
          $containter.removeEventListener('mousedown', this.onHover);
          $containter.removeEventListener('mouseup', this.onHover);
          // $containter.removeEventListener('dblclick', this.onHover);
          $containter.removeEventListener('contextmenu', this.onHover);
        }
      }
    }
  }, {
    key: "interactionEvent",
    value: function interactionEvent(target) {
      var type = target.type,
        pointerType = target.pointerType;
      var clientX;
      var clientY;
      if (pointerType === 'touch') {
        clientY = Math.floor(target.pointers[0].clientY);
        clientX = Math.floor(target.pointers[0].clientX);
      } else {
        clientY = Math.floor(target.srcEvent.y);
        clientX = Math.floor(target.srcEvent.x);
      }
      var $containter = this.mapService.getMapContainer();
      if ($containter) {
        var _$containter$getBound2 = $containter.getBoundingClientRect(),
          top = _$containter$getBound2.top,
          left = _$containter$getBound2.left;
        clientX -= left;
        clientY -= top;
      }
      var lngLat = this.mapService.containerToLngLat([clientX, clientY]);
      return {
        x: clientX,
        y: clientY,
        lngLat: lngLat,
        type: type,
        target: target.srcEvent
      };
    }
  }, {
    key: "isDoubleTap",
    value: function isDoubleTap(x, y, lngLat) {
      var _this2 = this;
      var nowTime = new Date().getTime();
      var type = 'click';
      if (nowTime - this.lastClickTime < 400 && Math.abs(this.lastClickXY[0] - x) < 10 && Math.abs(this.lastClickXY[1] - y) < 10) {
        this.lastClickTime = 0;
        this.lastClickXY = [-1, -1];
        if (this.clickTimer) {
          clearTimeout(this.clickTimer);
        }
        type = 'dblclick';
        this.emit(InteractionEvent.Hover, {
          x: x,
          y: y,
          lngLat: lngLat,
          type: type
        });
      } else {
        this.lastClickTime = nowTime;
        this.lastClickXY = [x, y];
        // @ts-ignore
        this.clickTimer = setTimeout(function () {
          type = 'click';
          _this2.emit(InteractionEvent.Hover, {
            x: x,
            y: y,
            lngLat: lngLat,
            type: type
          });
        }, 400);
      }
    }
  }]);
  return InteractionService;
}(EventEmitter), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mapService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { InteractionService as default };