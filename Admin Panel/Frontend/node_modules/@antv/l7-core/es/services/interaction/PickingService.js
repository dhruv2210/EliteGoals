import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _initializerDefineProperty from "@babel/runtime/helpers/esm/initializerDefineProperty";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _applyDecoratedDescriptor from "@babel/runtime/helpers/esm/applyDecoratedDescriptor";
import _initializerWarningHelper from "@babel/runtime/helpers/esm/initializerWarningHelper";
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { decodePickingColor, DOM } from '@antv/l7-utils';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { TYPES } from "../../types";
import { isEventCrash } from "../../utils/dom";
import { InteractionEvent } from "../interaction/IInteractionService";
import { gl } from "../renderer/gl";
var PickingService = (_dec = injectable(), _dec2 = inject(TYPES.IMapService), _dec3 = inject(TYPES.IRendererService), _dec4 = inject(TYPES.IGlobalConfigService), _dec5 = inject(TYPES.IInteractionService), _dec6 = inject(TYPES.ILayerService), _dec(_class = (_class2 = /*#__PURE__*/function () {
  function PickingService() {
    var _this = this;
    _classCallCheck(this, PickingService);
    _defineProperty(this, "pickedColors", void 0);
    _defineProperty(this, "pickedTileLayers", []);
    _initializerDefineProperty(this, "mapService", _descriptor, this);
    _initializerDefineProperty(this, "rendererService", _descriptor2, this);
    _initializerDefineProperty(this, "configService", _descriptor3, this);
    _initializerDefineProperty(this, "interactionService", _descriptor4, this);
    _initializerDefineProperty(this, "layerService", _descriptor5, this);
    _defineProperty(this, "pickingFBO", void 0);
    _defineProperty(this, "width", 0);
    _defineProperty(this, "height", 0);
    _defineProperty(this, "alreadyInPicking", false);
    _defineProperty(this, "pickBufferScale", 1.0);
    _defineProperty(this, "pickFromPickingFBO", function (layer, _ref) {
      var x = _ref.x,
        y = _ref.y,
        lngLat = _ref.lngLat,
        type = _ref.type,
        target = _ref.target;
      var isPicked = false;
      var _this$rendererService = _this.rendererService,
        readPixels = _this$rendererService.readPixels,
        getContainer = _this$rendererService.getContainer;
      var _this$getContainerSiz = _this.getContainerSize(getContainer()),
        width = _this$getContainerSiz.width,
        height = _this$getContainerSiz.height;
      width *= DOM.DPR;
      height *= DOM.DPR;
      var _layer$getLayerConfig = layer.getLayerConfig(),
        enableHighlight = _layer$getLayerConfig.enableHighlight,
        enableSelect = _layer$getLayerConfig.enableSelect;
      var xInDevicePixel = x * DOM.DPR;
      var yInDevicePixel = y * DOM.DPR;
      if (xInDevicePixel > width - 1 * DOM.DPR || xInDevicePixel < 0 || yInDevicePixel > height - 1 * DOM.DPR || yInDevicePixel < 0) {
        return false;
      }
      var pickedColors = readPixels({
        x: Math.floor(xInDevicePixel / _this.pickBufferScale),
        // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
        y: Math.floor((height - (y + 1) * DOM.DPR) / _this.pickBufferScale),
        width: 1,
        height: 1,
        data: new Uint8Array(1 * 1 * 4),
        framebuffer: _this.pickingFBO
      });
      _this.pickedColors = pickedColors;
      if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
        var pickedFeatureIdx = decodePickingColor(pickedColors);
        // 瓦片数据获取性能问题需要优化
        var rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
        if (pickedFeatureIdx !== layer.getCurrentPickId() && type === 'mousemove') {
          type = 'mouseenter';
        }
        var layerTarget = {
          x: x,
          y: y,
          type: type,
          lngLat: lngLat,
          featureId: pickedFeatureIdx,
          feature: rawFeature,
          target: target
        };
        if (!rawFeature) {
          // this.logger.error(
          //   '未找到颜色编码解码后的原始 feature，请检查 fragment shader 中末尾是否添加了 `gl_FragColor = filterColor(gl_FragColor);`',
          // );
        } else {
          // trigger onHover/Click callback on layer
          isPicked = true;
          layer.setCurrentPickId(pickedFeatureIdx);
          _this.triggerHoverOnLayer(layer, layerTarget); // 触发拾取事件
        }
      } else {
        // 未选中
        var _layerTarget = {
          x: x,
          y: y,
          lngLat: lngLat,
          type: layer.getCurrentPickId() !== null && type === 'mousemove' ? 'mouseout' : 'un' + type,
          featureId: null,
          target: target,
          feature: null
        };
        _this.triggerHoverOnLayer(layer, _objectSpread(_objectSpread({}, _layerTarget), {}, {
          type: 'unpick'
        }));
        _this.triggerHoverOnLayer(layer, _layerTarget);
        layer.setCurrentPickId(null);
      }
      if (enableHighlight) {
        layer.layerPickService.highlightPickedFeature(pickedColors);
      }
      if (enableSelect && type === 'click' && (pickedColors === null || pickedColors === void 0 ? void 0 : pickedColors.toString()) !== [0, 0, 0, 0].toString()) {
        var selectedId = decodePickingColor(pickedColors);
        if (layer.getCurrentSelectedId() === null || selectedId !== layer.getCurrentSelectedId()) {
          layer.layerPickService.selectFeature(pickedColors);
          layer.setCurrentSelectedId(selectedId);
        } else {
          layer.layerPickService.selectFeature(new Uint8Array([0, 0, 0, 0])); // toggle select
          layer.setCurrentSelectedId(null);
        }
      }
      return isPicked;
    });
  }
  _createClass(PickingService, [{
    key: "init",
    value: function init(id) {
      var _this$rendererService2 = this.rendererService,
        createTexture2D = _this$rendererService2.createTexture2D,
        createFramebuffer = _this$rendererService2.createFramebuffer,
        getContainer = _this$rendererService2.getContainer;
      var _this$getContainerSiz2 = this.getContainerSize(getContainer()),
        width = _this$getContainerSiz2.width,
        height = _this$getContainerSiz2.height;
      width *= DOM.DPR;
      height *= DOM.DPR;
      this.pickBufferScale = this.configService.getSceneConfig(id).pickBufferScale || 1;
      // 创建 picking framebuffer，后续实时 resize
      this.pickingFBO = createFramebuffer({
        color: createTexture2D({
          width: Math.round(width / this.pickBufferScale),
          height: Math.round(height / this.pickBufferScale),
          wrapS: gl.CLAMP_TO_EDGE,
          wrapT: gl.CLAMP_TO_EDGE
        })
      });

      // 监听 hover 事件
      this.interactionService.on(InteractionEvent.Hover, this.pickingAllLayer.bind(this));
    }
  }, {
    key: "boxPickLayer",
    value: function () {
      var _boxPickLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(layer, box, cb) {
        var _this2 = this;
        var _this$rendererService3, useFramebuffer, clear;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$rendererService3 = this.rendererService, useFramebuffer = _this$rendererService3.useFramebuffer, clear = _this$rendererService3.clear;
              this.resizePickingFBO();
              useFramebuffer(this.pickingFBO, function () {
                clear({
                  framebuffer: _this2.pickingFBO,
                  color: [0, 0, 0, 0],
                  stencil: 0,
                  depth: 1
                });
                layer.hooks.beforePickingEncode.call();
                layer.renderModels({
                  ispick: true
                });
                layer.hooks.afterPickingEncode.call();
                var features = _this2.pickBox(layer, box);
                cb(features);
              });
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function boxPickLayer(_x, _x2, _x3) {
        return _boxPickLayer.apply(this, arguments);
      }
      return boxPickLayer;
    }()
  }, {
    key: "pickBox",
    value: function pickBox(layer, box) {
      var _this3 = this;
      var _box$map = box.map(function (v) {
          var tmpV = v < 0 ? 0 : v;
          return Math.floor(tmpV * DOM.DPR / _this3.pickBufferScale);
        }),
        _box$map2 = _slicedToArray(_box$map, 4),
        xMin = _box$map2[0],
        yMin = _box$map2[1],
        xMax = _box$map2[2],
        yMax = _box$map2[3];
      var _this$rendererService4 = this.rendererService,
        readPixels = _this$rendererService4.readPixels,
        getContainer = _this$rendererService4.getContainer;
      var _this$getContainerSiz3 = this.getContainerSize(getContainer()),
        width = _this$getContainerSiz3.width,
        height = _this$getContainerSiz3.height;
      width *= DOM.DPR;
      height *= DOM.DPR;
      if (xMin > (width - 1) * DOM.DPR / this.pickBufferScale || xMax < 0 || yMin > (height - 1) * DOM.DPR / this.pickBufferScale || yMax < 0) {
        return [];
      }
      var w = Math.min(width / this.pickBufferScale, xMax) - xMin;
      var h = Math.min(height / this.pickBufferScale, yMax) - yMin;
      var pickedColors = readPixels({
        x: xMin,
        // 视口坐标系原点在左上，而 WebGL 在左下，需要翻转 Y 轴
        y: Math.floor(height / this.pickBufferScale - (yMax + 1)),
        width: w,
        height: h,
        data: new Uint8Array(w * h * 4),
        framebuffer: this.pickingFBO
      });
      var features = [];
      var featuresIdMap = {};
      for (var i = 0; i < pickedColors.length / 4; i = i + 1) {
        var color = pickedColors.slice(i * 4, i * 4 + 4);
        var pickedFeatureIdx = decodePickingColor(color);
        if (pickedFeatureIdx !== -1 && !featuresIdMap[pickedFeatureIdx]) {
          var rawFeature = layer.layerPickService.getFeatureById(pickedFeatureIdx);
          features.push(_objectSpread(_objectSpread({}, rawFeature), {}, {
            pickedFeatureIdx: pickedFeatureIdx
          }));
          featuresIdMap[pickedFeatureIdx] = true;
        }
      }
      return features;
    }

    // 动态设置鼠标光标
  }, {
    key: "handleCursor",
    value: function handleCursor(layer, type) {
      var _layer$getLayerConfig2 = layer.getLayerConfig(),
        _layer$getLayerConfig3 = _layer$getLayerConfig2.cursor,
        cursor = _layer$getLayerConfig3 === void 0 ? '' : _layer$getLayerConfig3,
        cursorEnabled = _layer$getLayerConfig2.cursorEnabled;
      if (cursorEnabled) {
        var version = this.mapService.version;
        var domContainer = version === 'GAODE2.x' ? this.mapService.getMapContainer() : this.mapService.getMarkerContainer();
        // const domContainer = this.mapService.getMarkerContainer();
        // const domContainer = this.mapService.getMapContainer();
        var defaultCursor = domContainer === null || domContainer === void 0 ? void 0 : domContainer.style.getPropertyValue('cursor');
        if (type === 'unmousemove' && defaultCursor !== '') {
          domContainer === null || domContainer === void 0 ? void 0 : domContainer.style.setProperty('cursor', '');
        } else if (type === 'mousemove') {
          domContainer === null || domContainer === void 0 ? void 0 : domContainer.style.setProperty('cursor', cursor);
        }
      }
      // const domContainer = this.mapService.getMapContainer()
      // domContainer?.style.setProperty('cursor', 'move');
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.pickingFBO.destroy();
      // this.pickingFBO = null; 清除对 webgl 实例的引用
      // @ts-ignore
      this.pickingFBO = null;
    }
  }, {
    key: "getContainerSize",
    value:
    // 获取容器的大小 - 兼容小程序环境
    function getContainerSize(container) {
      if (container.getContext) {
        return {
          width: container.width / DOM.DPR,
          height: container.height / DOM.DPR
        };
      } else {
        return container.getBoundingClientRect();
      }
    }
  }, {
    key: "pickingAllLayer",
    value: function () {
      var _pickingAllLayer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(target) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(!this.layerService.needPick(target.type) || !this.isPickingAllLayer())) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return");
            case 2:
              this.alreadyInPicking = true;
              _context2.next = 5;
              return this.pickingLayers(target);
            case 5:
              this.layerService.renderLayers();
              this.alreadyInPicking = false;
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function pickingAllLayer(_x4) {
        return _pickingAllLayer.apply(this, arguments);
      }
      return pickingAllLayer;
    }()
  }, {
    key: "isPickingAllLayer",
    value: function isPickingAllLayer() {
      // this.alreadyInPicking 避免多次重复拾取
      if (this.alreadyInPicking) {
        return false;
      }
      // this.layerService.alreadyInRendering 一个渲染序列中只进行一次拾取操作
      if (this.layerService.alreadyInRendering) {
        return false;
      }
      // this.interactionService.dragging amap2 在点击操作的时候同时会触发 dragging 的情况（避免舍去）
      if (this.interactionService.indragging) {
        return false;
      }
      // 判断当前进行 shader pick 拾取判断
      if (!this.layerService.getShaderPickStat()) {
        return false;
      }

      // 进行拾取
      return true;
    }
  }, {
    key: "resizePickingFBO",
    value: function resizePickingFBO() {
      var getContainer = this.rendererService.getContainer;
      var _this$getContainerSiz4 = this.getContainerSize(getContainer()),
        width = _this$getContainerSiz4.width,
        height = _this$getContainerSiz4.height;
      width *= DOM.DPR;
      height *= DOM.DPR;
      if (this.width !== width || this.height !== height) {
        this.pickingFBO.resize({
          width: Math.round(width / this.pickBufferScale),
          height: Math.round(height / this.pickBufferScale)
        });
        this.width = width;
        this.height = height;
      }
    }
  }, {
    key: "pickingLayers",
    value: function () {
      var _pickingLayers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(target) {
        var _this4 = this;
        var _this$rendererService5, useFramebuffer, clear;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _this$rendererService5 = this.rendererService, useFramebuffer = _this$rendererService5.useFramebuffer, clear = _this$rendererService5.clear;
              this.resizePickingFBO();
              useFramebuffer(this.pickingFBO, function () {
                var layers = _this4.layerService.getRenderList();
                layers.filter(function (layer) {
                  return layer.needPick(target.type);
                }).reverse().some(function (layer) {
                  clear({
                    framebuffer: _this4.pickingFBO,
                    color: [0, 0, 0, 0],
                    stencil: 0,
                    depth: 1
                  });
                  layer.layerPickService.pickRender(target);
                  var isPicked = _this4.pickFromPickingFBO(layer, target);
                  _this4.layerService.pickedLayerId = isPicked ? +layer.id : -1;
                  return isPicked && !layer.getLayerConfig().enablePropagation;
                });
              });
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function pickingLayers(_x5) {
        return _pickingLayers.apply(this, arguments);
      }
      return pickingLayers;
    }()
  }, {
    key: "triggerHoverOnLayer",
    value: function triggerHoverOnLayer(layer, target) {
      // layer.emit(target.type, target);
      // 判断是否发生事件冲突
      if (isEventCrash(target)) {
        // Tip: 允许用户动态设置鼠标光标
        this.handleCursor(layer, target.type);
        layer.emit(target.type, target);
      }
    }
  }]);
  return PickingService;
}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mapService", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "rendererService", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "configService", [_dec4], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "interactionService", [_dec5], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "layerService", [_dec6], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
export { PickingService as default };