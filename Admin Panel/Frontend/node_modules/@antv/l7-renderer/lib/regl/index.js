var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// src/regl/index.ts
var regl_exports = {};
__export(regl_exports, {
  default: () => ReglRendererService
});
module.exports = __toCommonJS(regl_exports);
var import_l7_utils = require("@antv/l7-utils");
var import_inversify = require("inversify");
var import_l7regl = __toESM(require("l7regl"));
var import_reflect_metadata = require("reflect-metadata");
var import_ReglAttribute = __toESM(require("./ReglAttribute"));
var import_ReglBuffer = __toESM(require("./ReglBuffer"));
var import_ReglElements = __toESM(require("./ReglElements"));
var import_ReglFramebuffer = __toESM(require("./ReglFramebuffer"));
var import_ReglModel = __toESM(require("./ReglModel"));
var import_ReglTexture2D = __toESM(require("./ReglTexture2D"));
var ReglRendererService = class {
  constructor() {
    this.createModel = (options) => new import_ReglModel.default(this.gl, options);
    this.createAttribute = (options) => new import_ReglAttribute.default(this.gl, options);
    this.createBuffer = (options) => new import_ReglBuffer.default(this.gl, options);
    this.createElements = (options) => new import_ReglElements.default(this.gl, options);
    this.createTexture2D = (options) => new import_ReglTexture2D.default(this.gl, options);
    this.createFramebuffer = (options) => new import_ReglFramebuffer.default(this.gl, options);
    this.useFramebuffer = (framebuffer, drawCommands) => {
      this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    };
    this.clear = (options) => {
      var _a;
      const { color, depth, stencil, framebuffer = null } = options;
      const reglClearOptions = {
        color,
        depth,
        stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
      (_a = this.gl) == null ? void 0 : _a.clear(reglClearOptions);
    };
    this.viewport = ({
      x,
      y,
      width,
      height
    }) => {
      this.gl._gl.viewport(x, y, width, height);
      this.width = width;
      this.height = height;
      this.gl._refresh();
    };
    this.readPixels = (options) => {
      const { framebuffer, x, y, width, height } = options;
      const readPixelsOptions = {
        x,
        y,
        width,
        height
      };
      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }
      return this.gl.read(readPixelsOptions);
    };
    this.getViewportSize = () => {
      return {
        width: this.gl._gl.drawingBufferWidth,
        height: this.gl._gl.drawingBufferHeight
      };
    };
    this.getContainer = () => {
      var _a;
      if (import_l7_utils.isMini) {
        return this.canvas;
      } else {
        return (_a = this.canvas) == null ? void 0 : _a.parentElement;
      }
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.gl._gl;
    };
    this.destroy = () => {
      var _a, _b, _c;
      this.canvas = null;
      (_c = (_b = (_a = this.gl) == null ? void 0 : _a._gl) == null ? void 0 : _b.getExtension("WEBGL_lose_context")) == null ? void 0 : _c.loseContext();
      this.gl.destroy();
      this.gl = null;
    };
  }
  async init(canvas, cfg, gl) {
    this.canvas = canvas;
    if (gl) {
      this.gl = gl;
    } else {
      this.gl = await new Promise((resolve, reject) => {
        (0, import_l7regl.default)({
          canvas: this.canvas,
          attributes: {
            alpha: true,
            // use TAA instead of MSAA
            // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
            antialias: cfg.antialias,
            premultipliedAlpha: true,
            preserveDrawingBuffer: cfg.preserveDrawingBuffer,
            stencil: cfg.stencil
          },
          // TODO: use extensions
          extensions: [
            "OES_element_index_uint",
            "OES_standard_derivatives",
            // wireframe
            "ANGLE_instanced_arrays"
            // VSM shadow map
          ],
          optionalExtensions: [
            "oes_texture_float_linear",
            "OES_texture_float",
            "EXT_texture_filter_anisotropic",
            "EXT_blend_minmax",
            "WEBGL_depth_texture",
            "WEBGL_lose_context"
          ],
          profile: true,
          onDone: (err, r) => {
            if (err || !r) {
              reject(err);
            }
            resolve(r);
          }
        });
      });
    }
    this.extensionObject = {
      OES_texture_float: this.testExtension("OES_texture_float")
    };
  }
  getPointSizeRange() {
    return this.gl._gl.getParameter(this.gl._gl.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
    this.gl({
      cull: {
        enable: false,
        face: "back"
      },
      viewport: {
        x: 0,
        y: 0,
        height: this.width,
        width: this.height
      },
      blend: {
        enable: true,
        equation: "add"
      },
      framebuffer: null
    });
    this.gl._refresh();
  }
  setBaseState() {
    this.gl({
      cull: {
        enable: false,
        face: "back"
      },
      viewport: {
        x: 0,
        y: 0,
        height: this.width,
        width: this.height
      },
      blend: {
        enable: false,
        equation: "add"
      },
      framebuffer: null
    });
    this.gl._refresh();
  }
  setCustomLayerDefaults() {
    const gl = this.getGLContext();
    gl.disable(gl.CULL_FACE);
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
};
ReglRendererService = __decorateClass([
  (0, import_inversify.injectable)()
], ReglRendererService);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
