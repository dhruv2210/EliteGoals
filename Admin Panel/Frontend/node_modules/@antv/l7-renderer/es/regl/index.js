import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _dec, _class;
import _regeneratorRuntime from "@babel/runtime/regenerator";
/**
 * render w/ regl
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md
 */

import { isMini } from '@antv/l7-utils';
import { injectable } from 'inversify';
import regl from 'l7regl';
import 'reflect-metadata';
import ReglAttribute from "./ReglAttribute";
import ReglBuffer from "./ReglBuffer";
import ReglElements from "./ReglElements";
import ReglFramebuffer from "./ReglFramebuffer";
import ReglModel from "./ReglModel";
import ReglTexture2D from "./ReglTexture2D";

/**
 * regl renderer
 */
var ReglRendererService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function () {
  function ReglRendererService() {
    var _this = this;
    _classCallCheck(this, ReglRendererService);
    _defineProperty(this, "createModel", function (options) {
      return new ReglModel(_this.gl, options);
    });
    _defineProperty(this, "createAttribute", function (options) {
      return new ReglAttribute(_this.gl, options);
    });
    _defineProperty(this, "createBuffer", function (options) {
      return new ReglBuffer(_this.gl, options);
    });
    _defineProperty(this, "createElements", function (options) {
      return new ReglElements(_this.gl, options);
    });
    _defineProperty(this, "createTexture2D", function (options) {
      return new ReglTexture2D(_this.gl, options);
    });
    _defineProperty(this, "createFramebuffer", function (options) {
      return new ReglFramebuffer(_this.gl, options);
    });
    _defineProperty(this, "useFramebuffer", function (framebuffer, drawCommands) {
      _this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    });
    _defineProperty(this, "clear", function (options) {
      var _this$gl;
      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clear-the-draw-buffer
      var color = options.color,
        depth = options.depth,
        stencil = options.stencil,
        _options$framebuffer = options.framebuffer,
        framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
      var reglClearOptions = {
        color: color,
        depth: depth,
        stencil: stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
      (_this$gl = _this.gl) === null || _this$gl === void 0 ? void 0 : _this$gl.clear(reglClearOptions);
    });
    _defineProperty(this, "viewport", function (_ref) {
      var x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height;
      // use WebGL context directly
      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#unsafe-escape-hatch
      _this.gl._gl.viewport(x, y, width, height);
      _this.width = width;
      _this.height = height;
      _this.gl._refresh();
    });
    _defineProperty(this, "readPixels", function (options) {
      var framebuffer = options.framebuffer,
        x = options.x,
        y = options.y,
        width = options.width,
        height = options.height;
      var readPixelsOptions = {
        x: x,
        y: y,
        width: width,
        height: height
      };
      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }
      return _this.gl.read(readPixelsOptions);
    });
    _defineProperty(this, "getViewportSize", function () {
      return {
        width: _this.gl._gl.drawingBufferWidth,
        height: _this.gl._gl.drawingBufferHeight
      };
    });
    _defineProperty(this, "getContainer", function () {
      if (isMini) {
        return _this.canvas;
      } else {
        var _this$canvas;
        return (_this$canvas = _this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.parentElement;
      }
    });
    _defineProperty(this, "getCanvas", function () {
      // return this.$container?.getElementsByTagName('canvas')[0] || null;
      return _this.canvas;
    });
    _defineProperty(this, "getGLContext", function () {
      return _this.gl._gl;
    });
    _defineProperty(this, "destroy", function () {
      var _this$gl2, _this$gl2$_gl, _this$gl2$_gl$getExte;
      // this.canvas = null 清除对 webgl 实例的引用
      // @ts-ignore
      _this.canvas = null;

      // make sure release webgl context
      (_this$gl2 = _this.gl) === null || _this$gl2 === void 0 ? void 0 : (_this$gl2$_gl = _this$gl2._gl) === null || _this$gl2$_gl === void 0 ? void 0 : (_this$gl2$_gl$getExte = _this$gl2$_gl.getExtension('WEBGL_lose_context')) === null || _this$gl2$_gl$getExte === void 0 ? void 0 : _this$gl2$_gl$getExte.loseContext();

      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clean-up
      _this.gl.destroy();

      // @ts-ignore
      _this.gl = null;
    });
  }
  _createClass(ReglRendererService, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(canvas, cfg, gl) {
        var _this2 = this;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // this.$container = $container;
              this.canvas = canvas;
              if (!gl) {
                _context.next = 5;
                break;
              }
              this.gl = gl;
              _context.next = 8;
              break;
            case 5:
              _context.next = 7;
              return new Promise(function (resolve, reject) {
                regl({
                  canvas: _this2.canvas,
                  attributes: {
                    alpha: true,
                    // use TAA instead of MSAA
                    // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
                    antialias: cfg.antialias,
                    premultipliedAlpha: true,
                    preserveDrawingBuffer: cfg.preserveDrawingBuffer,
                    stencil: cfg.stencil
                  },
                  // TODO: use extensions
                  extensions: ['OES_element_index_uint', 'OES_standard_derivatives',
                  // wireframe
                  'ANGLE_instanced_arrays' // VSM shadow map
                  ],

                  optionalExtensions: ['oes_texture_float_linear', 'OES_texture_float', 'EXT_texture_filter_anisotropic', 'EXT_blend_minmax', 'WEBGL_depth_texture', 'WEBGL_lose_context'],
                  profile: true,
                  onDone: function onDone(err, r) {
                    if (err || !r) {
                      reject(err);
                    }
                    // @ts-ignore
                    resolve(r);
                  }
                });
              });
            case 7:
              this.gl = _context.sent;
            case 8:
              this.extensionObject = {
                OES_texture_float: this.testExtension('OES_texture_float')
              };
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init(_x, _x2, _x3) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "getPointSizeRange",
    value: function getPointSizeRange() {
      return this.gl._gl.getParameter(this.gl._gl.ALIASED_POINT_SIZE_RANGE);
    }
  }, {
    key: "testExtension",
    value: function testExtension(name) {
      // OES_texture_float
      return !!this.getGLContext().getExtension(name);
    }
  }, {
    key: "setState",
    value:
    // TODO: 临时方法
    function setState() {
      this.gl({
        cull: {
          enable: false,
          face: 'back'
        },
        viewport: {
          x: 0,
          y: 0,
          height: this.width,
          width: this.height
        },
        blend: {
          enable: true,
          equation: 'add'
        },
        framebuffer: null
      });
      this.gl._refresh();
    }
  }, {
    key: "setBaseState",
    value: function setBaseState() {
      this.gl({
        cull: {
          enable: false,
          face: 'back'
        },
        viewport: {
          x: 0,
          y: 0,
          height: this.width,
          width: this.height
        },
        blend: {
          enable: false,
          equation: 'add'
        },
        framebuffer: null
      });
      this.gl._refresh();
    }
  }, {
    key: "setCustomLayerDefaults",
    value: function setCustomLayerDefaults() {
      var gl = this.getGLContext();
      gl.disable(gl.CULL_FACE);
    }
  }, {
    key: "setDirty",
    value: function setDirty(flag) {
      this.isDirty = flag;
    }
  }, {
    key: "getDirty",
    value: function getDirty() {
      return this.isDirty;
    }
  }]);
  return ReglRendererService;
}()) || _class);
export { ReglRendererService as default };