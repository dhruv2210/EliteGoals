import _typeof from "@babel/runtime/helpers/esm/typeof";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { gl } from '@antv/l7-core';
import { isPlainObject, isTypedArray } from 'lodash';
import { blendEquationMap, blendFuncMap, cullFaceMap, depthFuncMap, primitiveMap, stencilFuncMap, stencilOpMap } from "./constants";
/**
 * adaptor for regl.DrawCommand
 */
var ReglModel = /*#__PURE__*/function () {
  function ReglModel(reGl, options) {
    _classCallCheck(this, ReglModel);
    _defineProperty(this, "destroyed", false);
    _defineProperty(this, "uniforms", {});
    this.reGl = reGl;
    var vs = options.vs,
      fs = options.fs,
      attributes = options.attributes,
      uniforms = options.uniforms,
      primitive = options.primitive,
      count = options.count,
      elements = options.elements,
      depth = options.depth,
      cull = options.cull,
      instances = options.instances;
    var reglUniforms = {};
    this.options = options;
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
      Object.keys(uniforms).forEach(function (uniformName) {
        // use regl prop API
        // @ts-ignore
        reglUniforms[uniformName] = reGl.prop(uniformName);
      });
    }
    var reglAttributes = {};
    Object.keys(attributes).forEach(function (name) {
      reglAttributes[name] = attributes[name].get();
    });
    var drawParams = {
      attributes: reglAttributes,
      frag: fs,
      uniforms: reglUniforms,
      vert: vs,
      // @ts-ignore
      colorMask: reGl.prop('colorMask'),
      blend: {
        // @ts-ignore
        enable: reGl.prop('blend.enable'),
        // @ts-ignore
        func: reGl.prop('blend.func'),
        // @ts-ignore
        equation: reGl.prop('blend.equation'),
        // @ts-ignore
        color: reGl.prop('blend.color')
      },
      stencil: {
        // @ts-ignore
        enable: reGl.prop('stencil.enable'),
        // @ts-ignore
        mask: reGl.prop('stencil.mask'),
        // @ts-ignore
        func: reGl.prop('stencil.func'),
        // @ts-ignore
        opFront: reGl.prop('stencil.opFront'),
        // @ts-ignore
        opBack: reGl.prop('stencil.opBack')
      },
      primitive: primitiveMap[primitive === undefined ? gl.TRIANGLES : primitive]
    };
    if (instances) {
      drawParams.instances = instances;
    }

    // Tip:
    // elements 中可能包含 count，此时不应传入
    // count 和 elements 相比、count 优先
    if (count) {
      drawParams.count = count;
    } else if (elements) {
      drawParams.elements = elements.get();
    }
    this.initDepthDrawParams({
      depth: depth
    }, drawParams);
    // this.initBlendDrawParams({ blend }, drawParams);
    // this.initStencilDrawParams({ stencil }, drawParams);
    this.initCullDrawParams({
      cull: cull
    }, drawParams);
    this.drawCommand = reGl(drawParams);
    this.drawParams = drawParams;
  }
  _createClass(ReglModel, [{
    key: "updateAttributesAndElements",
    value: function updateAttributesAndElements(attributes, elements) {
      var reglAttributes = {};
      Object.keys(attributes).forEach(function (name) {
        reglAttributes[name] = attributes[name].get();
      });
      this.drawParams.attributes = reglAttributes;
      this.drawParams.elements = elements.get();
      this.drawCommand = this.reGl(this.drawParams);
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(attributes) {
      var reglAttributes = {};
      Object.keys(attributes).forEach(function (name) {
        reglAttributes[name] = attributes[name].get();
      });
      this.drawParams.attributes = reglAttributes;
      this.drawCommand = this.reGl(this.drawParams);
    }
  }, {
    key: "addUniforms",
    value: function addUniforms(uniforms) {
      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), this.extractUniforms(uniforms));
    }
  }, {
    key: "draw",
    value: function draw(options, pick) {
      // console.log('options', this.drawParams)
      if (this.drawParams.attributes && Object.keys(this.drawParams.attributes).length === 0) {
        return;
      }
      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), this.extractUniforms(options.uniforms || {}));
      var reglDrawProps = {};
      Object.keys(uniforms).forEach(function (uniformName) {
        var type = _typeof(uniforms[uniformName]);
        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) ||
        // @ts-ignore
        uniforms[uniformName].BYTES_PER_ELEMENT) {
          reglDrawProps[uniformName] = uniforms[uniformName];
        } else {
          reglDrawProps[uniformName] = uniforms[uniformName].get();
        }
      });
      // 更新 blend
      // @ts-ignore
      reglDrawProps.blend = pick // picking 操作不应该使用 blend
      ? this.getBlendDrawParams({
        blend: {
          enable: false
        }
      }) : this.getBlendDrawParams(options);

      // 更新stentil 配置
      // @ts-ignore
      reglDrawProps.stencil = this.getStencilDrawParams(options);
      // @ts-ignore
      reglDrawProps.colorMask = this.getColorMaskDrawParams(options, pick);

      // 在进行拾取操作的绘制中，不应该使用叠加模式 - picking 根据拾取的颜色作为判断的输入，而叠加模式会产生新的，在 id 序列中不存在的颜色
      this.drawCommand(reglDrawProps);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$drawParams, _this$drawParams$elem;
      // @ts-ignore
      (_this$drawParams = this.drawParams) === null || _this$drawParams === void 0 ? void 0 : (_this$drawParams$elem = _this$drawParams.elements) === null || _this$drawParams$elem === void 0 ? void 0 : _this$drawParams$elem.destroy();
      if (this.options.attributes) {
        Object.values(this.options.attributes).forEach(function (attr) {
          // @ts-ignore
          attr === null || attr === void 0 ? void 0 : attr.destroy();
        });
      }
      this.destroyed = true;
    }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer
     */
  }, {
    key: "initDepthDrawParams",
    value: function initDepthDrawParams(_ref, drawParams) {
      var depth = _ref.depth;
      if (depth) {
        drawParams.depth = {
          enable: depth.enable === undefined ? true : !!depth.enable,
          mask: depth.mask === undefined ? true : !!depth.mask,
          func: depthFuncMap[depth.func || gl.LESS],
          range: depth.range || [0, 1]
        };
      }
    }
  }, {
    key: "getBlendDrawParams",
    value: function getBlendDrawParams(_ref2) {
      var blend = _ref2.blend;
      var _ref3 = blend || {},
        enable = _ref3.enable,
        func = _ref3.func,
        equation = _ref3.equation,
        _ref3$color = _ref3.color,
        color = _ref3$color === void 0 ? [0, 0, 0, 0] : _ref3$color;
      // @ts-ignore
      return {
        enable: !!enable,
        func: {
          srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
          srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
          dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
          dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
        },
        equation: {
          rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
          alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
        },
        color: color
      };
    }
    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
     */
  }, {
    key: "getStencilDrawParams",
    value: function getStencilDrawParams(_ref4) {
      var stencil = _ref4.stencil;
      var _ref5 = stencil || {},
        enable = _ref5.enable,
        _ref5$mask = _ref5.mask,
        mask = _ref5$mask === void 0 ? -1 : _ref5$mask,
        _ref5$func = _ref5.func,
        func = _ref5$func === void 0 ? {
          cmp: gl.ALWAYS,
          ref: 0,
          mask: -1
        } : _ref5$func,
        _ref5$opFront = _ref5.opFront,
        opFront = _ref5$opFront === void 0 ? {
          fail: gl.KEEP,
          zfail: gl.KEEP,
          zpass: gl.KEEP
        } : _ref5$opFront,
        _ref5$opBack = _ref5.opBack,
        opBack = _ref5$opBack === void 0 ? {
          fail: gl.KEEP,
          zfail: gl.KEEP,
          zpass: gl.KEEP
        } : _ref5$opBack;
      return {
        enable: !!enable,
        mask: mask,
        func: _objectSpread(_objectSpread({}, func), {}, {
          cmp: stencilFuncMap[func.cmp]
        }),
        opFront: {
          fail: stencilOpMap[opFront.fail],
          zfail: stencilOpMap[opFront.zfail],
          zpass: stencilOpMap[opFront.zpass]
        },
        opBack: {
          fail: stencilOpMap[opBack.fail],
          zfail: stencilOpMap[opBack.zfail],
          zpass: stencilOpMap[opBack.zpass]
        }
      };
    }
  }, {
    key: "getColorMaskDrawParams",
    value: function getColorMaskDrawParams(_ref6, pick) {
      var stencil = _ref6.stencil;
      // TODO: 重构相关参数
      // 掩膜模式下，颜色通道全部关闭
      var colorMask = stencil !== null && stencil !== void 0 && stencil.enable && stencil.opFront && !pick ? [false, false, false, false] : [true, true, true, true]; // 非掩码模式下，颜色通道全部开启
      return colorMask;
    }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
     */
  }, {
    key: "initCullDrawParams",
    value: function initCullDrawParams(_ref7, drawParams) {
      var cull = _ref7.cull;
      if (cull) {
        var enable = cull.enable,
          _cull$face = cull.face,
          face = _cull$face === void 0 ? gl.BACK : _cull$face;
        drawParams.cull = {
          enable: !!enable,
          face: cullFaceMap[face]
        };
      }
    }

    /**
     * 考虑结构体命名, eg:
     * a: { b: 1 }  ->  'a.b'
     * a: [ { b: 1 } ] -> 'a[0].b'
     */
  }, {
    key: "extractUniforms",
    value: function extractUniforms(uniforms) {
      var _this = this;
      var extractedUniforms = {};
      Object.keys(uniforms).forEach(function (uniformName) {
        _this.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');
      });
      return extractedUniforms;
    }
  }, {
    key: "extractUniformsRecursively",
    value: function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
      var _this2 = this;
      if (uniformValue === null || typeof uniformValue === 'number' ||
      // u_A: 1
      typeof uniformValue === 'boolean' ||
      // u_A: false
      Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' ||
      // u_A: [1, 2, 3]
      isTypedArray(uniformValue) ||
      // u_A: Float32Array
      // @ts-ignore
      uniformValue === '' || 'resize' in uniformValue) {
        uniforms["".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;
        return;
      }

      // u_Struct.a.b.c
      if (isPlainObject(uniformValue)) {
        Object.keys(uniformValue).forEach(function (childName) {
          _this2.extractUniformsRecursively(childName,
          // @ts-ignore
          uniformValue[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName));
        });
      }

      // u_Struct[0].a
      if (Array.isArray(uniformValue)) {
        uniformValue.forEach(function (child, idx) {
          Object.keys(child).forEach(function (childName) {
            _this2.extractUniformsRecursively(childName,
            // @ts-ignore
            child[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName, "[").concat(idx, "]"));
          });
        });
      }
    }
  }]);
  return ReglModel;
}();
export { ReglModel as default };